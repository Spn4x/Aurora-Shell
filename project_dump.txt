======================================================================
### FILE: ././uninstall/meson-private/sanitycheckc.c
======================================================================
int main(void) { int class=0; return class; }

======================================================================
### FILE: ././widgets/control-center/src/wifi_scanner.h
======================================================================
#ifndef WIFI_SCANNER_H
#define WIFI_SCANNER_H

#include <glib.h>
#include "network_manager.h"

// Callback function prototype: it will be called with a fresh list of networks.
// The receiver of this callback is responsible for freeing the GList.
typedef void (*WifiScanResultCallback)(GList *networks, gpointer user_data);

typedef struct _WifiScanner WifiScanner;

// Creates a new WifiScanner object.
WifiScanner* wifi_scanner_new(WifiScanResultCallback callback, gpointer user_data);

// Starts the periodic scanning.
void wifi_scanner_start(WifiScanner *scanner, guint interval_seconds);

// Stops the periodic scanning.
void wifi_scanner_stop(WifiScanner *scanner);

// Triggers an immediate, one-time scan.
void wifi_scanner_trigger_scan(WifiScanner *scanner);

// Frees the scanner object.
void wifi_scanner_free(WifiScanner *scanner);

#endif // WIFI_SCANNER_H
======================================================================
### FILE: ././widgets/control-center/src/utils.h
======================================================================
#ifndef UTILS_H
#define UTILS_H

#include <glib.h>

// Runs a command and returns its standard output as a newly allocated string.
// The caller is responsible for freeing the returned string with g_free().
// Returns NULL on error.
gchar* run_command(const char *command_line);

#endif // UTILS_H
======================================================================
### FILE: ././widgets/control-center/src/bluetooth_manager.h
======================================================================
#ifndef BLUETOOTH_MANAGER_H
#define BLUETOOTH_MANAGER_H

#include <glib.h>

// Callback prototype for async operations.
typedef void (*BluetoothOperationCallback)(gboolean success, gpointer user_data);

// --- NEW: Callback for device list updates ---
// This will be called automatically when devices are found, disappear, or change state.
typedef void (*BluetoothDeviceUpdateCallback)(GList *devices, gpointer user_data);

// A struct to hold information about a single Bluetooth device.
typedef struct {
    gchar *address; // MAC address
    gchar *name;
    gboolean is_connected;
    gchar *object_path; // Internal D-Bus path
} BluetoothDevice;

// --- NEW: Core Manager Lifecycle & Discovery Control ---
gboolean bluetooth_manager_init(BluetoothDeviceUpdateCallback update_callback, gpointer user_data);
void bluetooth_manager_shutdown();
void bluetooth_manager_start_discovery();
void bluetooth_manager_stop_discovery();
// --- END NEW ---

// --- Power Control ---
gboolean is_bluetooth_powered();
void set_bluetooth_powered_async(gboolean powered, BluetoothOperationCallback callback, gpointer user_data);

// Gets a list of all paired/known and recently scanned Bluetooth devices.
// This is now a cheap, synchronous call that returns the manager's cached list.
GList* get_available_bluetooth_devices();

// Asynchronously attempts to connect to a Bluetooth device by its address.
void connect_to_bluetooth_device_async(const gchar *address,
                                       BluetoothOperationCallback callback,
                                       gpointer user_data);

// Asynchronously disconnects from a Bluetooth device by its address.
void disconnect_bluetooth_device_async(const gchar *address,
                                       BluetoothOperationCallback callback,
                                       gpointer user_data);

// Frees a single BluetoothDevice struct.
void bluetooth_device_free(gpointer data);

// Frees a GList of BluetoothDevice structs.
void free_bluetooth_device_list(GList *list);

#endif // BLUETOOTH_MANAGER_H
======================================================================
### FILE: ././widgets/control-center/src/qr.h
======================================================================
#ifndef QR_H
#define QR_H

#include <gtk/gtk.h>

// Callback for when the QR code is ready (or has failed)
// The pixbuf will be NULL on failure. The caller owns the returned pixbuf.
typedef void (*WifiQRCodeCallback)(GdkPixbuf *qr_code, gpointer user_data);

// Asynchronously fetches credentials and generates a QR code for the given SSID.
void generate_wifi_qr_code_async(const gchar *ssid, WifiQRCodeCallback callback, gpointer user_data);

#endif // QR_H
======================================================================
### FILE: ././widgets/control-center/src/audio_manager.h
======================================================================
#ifndef AUDIO_MANAGER_H
#define AUDIO_MANAGER_H

#include <glib.h>

// Callback for async operations
typedef void (*AudioOperationCallback)(gboolean success, gpointer user_data);

// Represents one audio output device (a sink)
typedef struct {
    guint id;
    gchar *name;
    gboolean is_default; // Very useful to know which one is active
} AudioSink;

// Represents the complete state of the default audio device
typedef struct {
    gint volume; // 0-100
    gboolean is_muted;
} AudioSinkState;

// Gets the current list of available audio sinks.
// The caller is responsible for freeing the list with free_audio_sink_list().
GList* get_audio_sinks();

// Gets the current volume and mute state of the default sink.
// The caller is responsible for freeing the returned struct.
AudioSinkState* get_default_sink_state();

// Asynchronously sets the volume of the default sink.
void set_default_sink_volume_async(gint volume, AudioOperationCallback callback, gpointer user_data);

// Asynchronously sets the default sink by its ID.
void set_default_sink_async(guint sink_id, AudioOperationCallback callback, gpointer user_data);

// Utility functions to free the memory of our structs
void audio_sink_free(gpointer data);
void free_audio_sink_list(GList *list);

#endif // AUDIO_MANAGER_H
======================================================================
### FILE: ././widgets/control-center/src/bluetooth_scanner.h
======================================================================
#ifndef BLUETOOTH_SCANNER_H
#define BLUETOOTH_SCANNER_H

#include <glib.h>
#include "bluetooth_manager.h"

// Callback function prototype: it will be called with a fresh list of devices.
// The receiver of this callback is responsible for freeing the GList.
typedef void (*BluetoothScanResultCallback)(GList *devices, gpointer user_data);

typedef struct _BluetoothScanner BluetoothScanner;

// Creates a new BluetoothScanner object.
BluetoothScanner* bluetooth_scanner_new(BluetoothScanResultCallback callback, gpointer user_data);

// Starts device discovery.
void bluetooth_scanner_start(BluetoothScanner *scanner);

// Stops device discovery.
void bluetooth_scanner_stop(BluetoothScanner *scanner);

// Triggers an immediate refresh of the UI from the manager's cache.
void bluetooth_scanner_trigger_scan(BluetoothScanner *scanner);

// Frees the scanner object.
void bluetooth_scanner_free(BluetoothScanner *scanner);

#endif // BLUETOOTH_SCANNER_H
======================================================================
### FILE: ././widgets/control-center/src/audio_manager.c
======================================================================
#include "audio_manager.h"
#include "utils.h" // For run_command
#include <gio/gio.h>
#include <string.h>
#include <stdlib.h>

// --- Data Structures for Async Tasks ---
typedef struct {
    guint id_or_volume;
} AudioTaskData;

typedef struct {
    AudioOperationCallback user_callback;
    gpointer user_data;
} AudioFinishData;

// --- Freeing Functions ---
void audio_sink_free(gpointer data) {
    if (!data) return;
    AudioSink *sink = (AudioSink*)data;
    g_free(sink->name);
    g_free(sink);
}
void free_audio_sink_list(GList *list) {
    g_list_free_full(list, audio_sink_free);
}

// --- Syncrhonous "Get" Functions ---

AudioSinkState* get_default_sink_state() {
    g_autofree gchar *output = run_command("wpctl get-volume @DEFAULT_SINK@");
    if (!output) return NULL;

    AudioSinkState *state = g_new0(AudioSinkState, 1);
    state->volume = 0;
    state->is_muted = FALSE;

    if (strstr(output, "[MUTED]")) {
        state->is_muted = TRUE;
    }

    const char *vol_str = strstr(output, "Volume: ");
    if (vol_str) {
        double vol_float = atof(vol_str + 8);
        state->volume = (gint)(vol_float * 100);
    }
    return state;
}

GList* get_audio_sinks() {
    g_autofree gchar *output = run_command("wpctl status");
    if (!output) return NULL;

    GList *sinks = NULL;
    gboolean in_sinks_section = FALSE;
    gchar **lines = g_strsplit(output, "\n", -1);

    for (int i = 0; lines[i] != NULL; i++) {
        const char *line = lines[i];

        if (strstr(line, "Sinks:")) {
            in_sinks_section = TRUE;
            continue;
        }
        if (in_sinks_section && (strstr(line, "Sink endpoints:") || strstr(line, "Sources:"))) {
            break; // End of sinks section
        }
        if (!in_sinks_section || strstr(line, "Easy Effects Sink")) {
            continue;
        }

        const char *dot = strchr(line, '.');
        if (!dot) continue;

        const char *id_start = strpbrk(line, "0123456789");
        if (!id_start) continue;

        AudioSink *sink = g_new0(AudioSink, 1);
        sink->is_default = (strstr(line, "*") != NULL);

        g_autofree gchar *id_str = g_strndup(id_start, dot - id_start);
        sink->id = (guint)atoi(id_str);

        const char *name_start = dot + 2; // Skip ". "
        const char *name_end = strstr(name_start, "[vol:");
        gchar *temp_name = name_end ? g_strndup(name_start, name_end - name_start) : g_strdup(name_start);
        sink->name = g_strstrip(temp_name);
        
        sinks = g_list_append(sinks, sink);
    }

    g_strfreev(lines);
    return sinks;
}

// --- Asynchronous "Set" Functions (using GTask) ---

static void on_async_operation_finished(GObject *s, GAsyncResult *res, gpointer d) {
    AudioFinishData *finish_data = d;
    gboolean success = g_task_propagate_boolean(G_TASK(res), NULL);
    if (finish_data->user_callback) {
        finish_data->user_callback(success, finish_data->user_data);
    }
    g_free(finish_data);
}

static void set_volume_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) {
    AudioTaskData *data = g_task_get_task_data(task);
    gchar *cmd = g_strdup_printf("wpctl set-volume @DEFAULT_SINK@ %u%%", data->id_or_volume);
    gint status;
    g_spawn_command_line_sync(cmd, NULL, NULL, &status, NULL);
    g_free(cmd);
    g_task_return_boolean(task, status == 0);
    g_free(data);
}

void set_default_sink_volume_async(gint volume, AudioOperationCallback cb, gpointer ud) {
    AudioTaskData *task_data = g_new0(AudioTaskData, 1);
    task_data->id_or_volume = (guint)volume;
    AudioFinishData *finish_data = g_new0(AudioFinishData, 1);
    finish_data->user_callback = cb;
    finish_data->user_data = ud;
    GTask *task = g_task_new(NULL, NULL, on_async_operation_finished, finish_data);
    g_task_set_task_data(task, task_data, NULL);
    g_task_run_in_thread(task, set_volume_thread_func);
    g_object_unref(task);
}

static void set_sink_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) {
    AudioTaskData *data = g_task_get_task_data(task);
    gchar *cmd = g_strdup_printf("wpctl set-default %u", data->id_or_volume);
    gint status;
    g_spawn_command_line_sync(cmd, NULL, NULL, &status, NULL);
    g_free(cmd);
    g_task_return_boolean(task, status == 0);
    g_free(data);
}

void set_default_sink_async(guint sink_id, AudioOperationCallback cb, gpointer ud) {
    AudioTaskData *task_data = g_new0(AudioTaskData, 1);
    task_data->id_or_volume = sink_id;
    AudioFinishData *finish_data = g_new0(AudioFinishData, 1);
    finish_data->user_callback = cb;
    finish_data->user_data = ud;
    GTask *task = g_task_new(NULL, NULL, on_async_operation_finished, finish_data);
    g_task_set_task_data(task, task_data, NULL);
    g_task_run_in_thread(task, set_sink_thread_func);
    g_object_unref(task);
}
======================================================================
### FILE: ././widgets/control-center/src/wifi_scanner.c
======================================================================
#include "wifi_scanner.h"
#include "network_manager.h"

struct _WifiScanner {
    guint timer_id;
    WifiScanResultCallback callback;
    gpointer user_data;
};

// This is the function that gets called by the timer.
static gboolean on_scan_timer_tick(gpointer user_data) {
    WifiScanner *scanner = (WifiScanner*)user_data;
    
    // Perform the scan and call the main callback.
    wifi_scanner_trigger_scan(scanner);

    // Return G_SOURCE_CONTINUE to keep the timer running.
    return G_SOURCE_CONTINUE;
}

WifiScanner* wifi_scanner_new(WifiScanResultCallback callback, gpointer user_data) {
    WifiScanner *scanner = g_new0(WifiScanner, 1);
    scanner->callback = callback;
    scanner->user_data = user_data;
    return scanner;
}

void wifi_scanner_start(WifiScanner *scanner, guint interval_seconds) {
    if (scanner->timer_id > 0) {
        // Already running
        return;
    }
    // Run the timer every `interval_seconds`.
    scanner->timer_id = g_timeout_add_seconds(interval_seconds, on_scan_timer_tick, scanner);
    
    // Trigger one scan immediately on start so the UI isn't empty.
    wifi_scanner_trigger_scan(scanner);
}

void wifi_scanner_stop(WifiScanner *scanner) {
    if (scanner->timer_id > 0) {
        g_source_remove(scanner->timer_id);
        scanner->timer_id = 0;
    }
}

void wifi_scanner_trigger_scan(WifiScanner *scanner) {
    if (!scanner || !scanner->callback) {
        return;
    }
    g_print("[FORGET DEBUG] 7. 'wifi_scanner_trigger_scan' is now calling the backend to get fresh network data.\n");
    GList *networks = get_available_wifi_networks();
    scanner->callback(networks, scanner->user_data);
}

void wifi_scanner_free(WifiScanner *scanner) {
    wifi_scanner_stop(scanner);
    g_free(scanner);
}
======================================================================
### FILE: ././widgets/control-center/src/main.c
======================================================================
#include <gtk/gtk.h>
#include <glib-unix.h>

#include "wifi_scanner.h"
#include "bluetooth_scanner.h"
#include "network_manager.h"
#include "bluetooth_manager.h"
#include "audio_manager.h"
#include "brightness_manager.h"
#include "system_monitor.h"
#include "qr.h"

const guint WIFI_SCAN_INTERVAL_SECONDS = 10;
const guint BT_SCAN_INTERVAL_SECONDS = 15;
const int LIST_REQUESTED_HEIGHT = 250;

// --- Main State Struct ---
typedef struct {
    GtkRevealer *stack_revealer;
    GtkStack *main_stack;
    GtkWidget *wifi_toggle, *bt_toggle, *audio_toggle;
    gulong wifi_toggle_handler_id, bt_toggle_handler_id, audio_toggle_handler_id;
    WifiScanner *wifi_scanner;
    BluetoothScanner *bt_scanner;
    SystemMonitor *system_monitor;
    
      GtkWidget *wifi_connected_header;
    GtkWidget *wifi_connected_list_box;
    GtkWidget *wifi_available_header;
    GtkWidget *wifi_available_list_box;
    
    GtkWidget *bt_list_box, *bt_list_overlay, *bt_list_spinner;
    GtkWidget *audio_list_box;
    GtkWidget *system_volume_slider;
    gulong system_volume_handler_id;
    GtkWidget *brightness_slider;
    gulong brightness_slider_handler_id;
    gboolean airplane_mode_active;
    gboolean wifi_was_on_before_airplane;
    gboolean bt_was_on_before_airplane;

       GtkWidget *bt_connected_header;
    GtkWidget *bt_connected_list_box;
    GtkWidget *bt_available_header;
    GtkWidget *bt_available_list_box;
    GtkWidget *bt_header_spinner;
    
} AppWidgets;

typedef struct {
    AppWidgets *widgets;
    GtkWidget *row_widget; // The widget that was clicked to initiate the connection
} WifiOpContext;

// --- Password Prompt Structs ---
typedef void (*PasswordCancelCallback)(gpointer user_data);
typedef void (*PasswordReadyCallback)(const gchar *password, gpointer user_data);
typedef struct {
    GtkWindow *window;
    GtkPasswordEntry *password_entry;
    PasswordReadyCallback ready_callback;
    PasswordCancelCallback cancel_callback;
    gpointer user_data;
} PasswordDialogState;
typedef struct {
    AppWidgets *widgets;
    WifiNetwork *network;
    GtkWidget *connecting_widget;
} PasswordDialogContext;

typedef struct {
    AppWidgets *widgets;
    GtkWidget *row_widget;
} BluetoothOperationContext;




// --- Forward Declarations ---
static void on_wifi_network_clicked(GtkButton *button, gpointer user_data);
static void on_wifi_operation_finished(gboolean success, gpointer user_data);
static void on_password_ready(const gchar *password, gpointer user_data);
static void on_password_cancelled(gpointer user_data);
static void show_password_prompt(GtkWindow *parent_window, const gchar *ssid, PasswordReadyCallback ready_callback, PasswordCancelCallback cancel_callback, gpointer user_data);
static const char* get_wifi_icon_name_for_signal(int strength);
static WifiNetwork* get_wifi_network_from_widget(GtkWidget *list_item);
static void update_wifi_widget_state(GtkWidget *button, WifiNetwork *net);
static void on_wifi_right_click(GtkGestureClick *gesture, int n_press, double x, double y, gpointer user_data);
static void on_popover_closed(GtkPopover *popover, gpointer user_data);
static GtkWidget* create_popover_action_button(const char* icon_name, const char* label);
static void on_details_button_clicked(GtkButton *button, GtkPopover *parent_popover);
static void on_connect_button_clicked(GtkButton *button, GtkPopover *popover);
static void on_disconnect_button_clicked(GtkButton *button, GtkPopover *popover);
static void on_forget_button_clicked(GtkButton *button, GtkPopover *popover);
static GtkWidget* create_list_entry(const char* icon, const char* label_text, gboolean is_active);
static void on_audio_sink_clicked(GtkButton *button, AudioSink *sink);
static void toggle_airplane_mode(GtkToggleButton *button, AppWidgets *widgets);
static void update_audio_device_list(AppWidgets *widgets);
static AppWidgets* get_widgets_from_child(GtkWidget *child_widget);
static void on_expandable_toggle_toggled(GtkToggleButton *toggled_button, AppWidgets *widgets);
// static void on_bt_disconnect_button_clicked(GtkButton *button, GtkPopover *popover);
static void on_bluetooth_right_click(GtkGestureClick *gesture, int n_press, double x, double y, gpointer user_data);
// static void on_device_state_changed(GDBusConnection *connection, const gchar *sender_name, const gchar *object_path, const gchar *interface_name, const gchar *signal_name, GVariant *parameters, gpointer user_data);
// static void subscribe_to_wifi_device_signals(AppWidgets *widgets);
static void on_wifi_scan_results(GList *networks, gpointer user_data);
static void on_bt_scan_results(GList *devices, gpointer user_data);

static gboolean initial_state_update(gpointer user_data);

static void on_qr_button_clicked(GtkButton *button, gpointer user_data);
static void on_qr_code_received(GdkPixbuf *pixbuf, gpointer user_data);

static void on_qr_button_pressed(GtkGestureClick *gesture, int n_press, double x, double y, gpointer user_data);

typedef struct {
    GtkWidget *parent_widget; // The button that was clicked
    GtkPopover *spinner_popover;
    gchar *ssid;
} QRCodeCallbackContext;


typedef struct {
    GtkPopover *parent_popover;
    GtkWidget *parent_widget;
} DetailsCallbackContext;

// NEW HANDLER: This is called when the details are ready
static void on_details_received(WifiNetworkDetails *details, gpointer user_data) {
    DetailsCallbackContext *context = user_data;
    if (!details) {
        g_warning("Failed to receive network details.");
        g_free(context);
        return;
    }

    // This is the UI-building logic moved from the old click handler
    GtkPopover *details_popover = GTK_POPOVER(gtk_popover_new());
    g_signal_connect(details_popover, "closed", G_CALLBACK(on_popover_closed), NULL);

    GtkWidget *grid = gtk_grid_new();
    gtk_widget_add_css_class(grid, "details-grid");
    gtk_grid_set_column_spacing(GTK_GRID(grid), 12);
    gtk_grid_set_row_spacing(GTK_GRID(grid), 6);
    
    gtk_grid_attach(GTK_GRID(grid), gtk_label_new("Signal:"), 0, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(grid), gtk_label_new(g_strdup_printf("%d%%", details->strength)), 1, 0, 1, 1);
    
    gtk_grid_attach(GTK_GRID(grid), gtk_label_new("Security:"), 0, 1, 1, 1);
    gtk_grid_attach(GTK_GRID(grid), gtk_label_new(details->security), 1, 1, 1, 1);
    
    if (details->ip_address) {
        gtk_grid_attach(GTK_GRID(grid), gtk_label_new("IP Address:"), 0, 2, 1, 1);
        gtk_grid_attach(GTK_GRID(grid), gtk_label_new(details->ip_address), 1, 2, 1, 1);
    }
    if (details->mac_address) {
        gtk_grid_attach(GTK_GRID(grid), gtk_label_new("MAC Address:"), 0, 3, 1, 1);
        gtk_grid_attach(GTK_GRID(grid), gtk_label_new(details->mac_address), 1, 3, 1, 1);
    }

    gtk_popover_set_child(details_popover, grid);
    gtk_widget_set_parent(GTK_WIDGET(details_popover), context->parent_widget);
    gtk_popover_popup(details_popover);
    
    free_wifi_network_details(details);
    g_free(context);
}



// --- Cleanup & Helpers ---
static void control_center_cleanup(gpointer data) {
    AppWidgets *widgets = (AppWidgets *)data;
    if (!widgets) return;
    //if (widgets->dbus_connection && widgets->device_state_changed_handler_id > 0) {
        //g_dbus_connection_signal_unsubscribe(widgets->dbus_connection, //widgets->device_state_changed_handler_id);
    //}
    //g_clear_object(&widgets->dbus_connection);
    wifi_scanner_stop(widgets->wifi_scanner);
    bluetooth_scanner_stop(widgets->bt_scanner);
    wifi_scanner_free(widgets->wifi_scanner);
    bluetooth_scanner_free(widgets->bt_scanner);
    system_monitor_free(widgets->system_monitor);

    // --- NEW: Shutdown the Bluetooth manager ---
    bluetooth_manager_shutdown();
    // --- END NEW ---

    g_free(widgets);
}

static void on_popover_closed(GtkPopover *popover, gpointer user_data) {
    (void)user_data;
    if (gtk_widget_get_parent(GTK_WIDGET(popover))) {
        gtk_widget_unparent(GTK_WIDGET(popover));
    }
}

static AppWidgets* get_widgets_from_child(GtkWidget *child_widget) {
    GtkWidget *ancestor = child_widget;
    while (ancestor) {
        const char* name = gtk_widget_get_name(ancestor);
        if (name && g_strcmp0(name, "aurora-control-center") == 0) {
            return g_object_get_data(G_OBJECT(ancestor), "app-widgets");
        }
        ancestor = gtk_widget_get_parent(ancestor);
    }
    return NULL;
}

// --- Password Prompt UI & Logic ---
static void on_password_cancelled(gpointer user_data) {
    PasswordDialogContext *context = user_data;
    if (!context) return;
    g_print("[UI] Password prompt cancelled. Reverting spinner.\n");
    if (context->connecting_widget) {
        GtkWidget* box = gtk_button_get_child(GTK_BUTTON(context->connecting_widget));
        GtkWidget* icon_stack = gtk_widget_get_first_child(box);
        if (icon_stack && GTK_IS_STACK(icon_stack)) {
            gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "icon");
        }
    }
    g_free(context);
}

static void on_password_dialog_connect_clicked(GtkButton *button, gpointer user_data) {
    (void)button;
    PasswordDialogState *dialog_state = user_data;
    const gchar *password = gtk_editable_get_text(GTK_EDITABLE(dialog_state->password_entry));
    if (dialog_state->cancel_callback) {
        g_signal_handlers_disconnect_by_func(dialog_state->window, G_CALLBACK(dialog_state->cancel_callback), dialog_state->user_data);
    }
    if (dialog_state->ready_callback) {
        dialog_state->ready_callback(password, dialog_state->user_data);
    }
    gtk_window_destroy(dialog_state->window);
}

static void show_password_prompt(GtkWindow *parent_window, const gchar *ssid, PasswordReadyCallback ready_callback, PasswordCancelCallback cancel_callback, gpointer user_data) {
    GtkWindow *window = GTK_WINDOW(gtk_window_new());
    gtk_window_set_transient_for(window, parent_window);
    gtk_window_set_modal(window, TRUE);
    gtk_window_set_title(window, "Connect to Wi-Fi Network");
    gtk_window_set_default_size(window, 350, -1);
    gtk_window_set_resizable(window, FALSE);
    PasswordDialogState *dialog_state = g_new0(PasswordDialogState, 1);
    dialog_state->window = window;
    dialog_state->ready_callback = ready_callback;
    dialog_state->cancel_callback = cancel_callback;
    dialog_state->user_data = user_data;
    g_object_set_data_full(G_OBJECT(window), "dialog-state", dialog_state, g_free);
    g_signal_connect_swapped(window, "destroy", G_CALLBACK(cancel_callback), user_data);
    GtkWidget *main_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 12);
    gtk_widget_set_margin_start(main_box, 15);
    gtk_widget_set_margin_end(main_box, 15);
    gtk_widget_set_margin_top(main_box, 15);
    gtk_widget_set_margin_bottom(main_box, 15);
    gtk_window_set_child(window, main_box);
    GtkWidget *header = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(header), "<span weight='bold'>Password required</span>");
    gtk_label_set_xalign(GTK_LABEL(header), 0.0);
    GtkWidget *ssid_label = gtk_label_new(ssid);
    gtk_label_set_xalign(GTK_LABEL(ssid_label), 0.0);
    dialog_state->password_entry = GTK_PASSWORD_ENTRY(gtk_password_entry_new());
    gtk_widget_grab_focus(GTK_WIDGET(dialog_state->password_entry));
    GtkWidget *action_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
    gtk_widget_set_halign(action_box, GTK_ALIGN_END);
    GtkWidget *cancel_button = gtk_button_new_with_label("Cancel");
    GtkWidget *connect_button = gtk_button_new_with_label("Connect");
    gtk_widget_add_css_class(connect_button, "suggested-action");
    g_signal_connect_swapped(cancel_button, "clicked", G_CALLBACK(gtk_window_destroy), window);
    g_signal_connect(connect_button, "clicked", G_CALLBACK(on_password_dialog_connect_clicked), dialog_state);
    gtk_window_set_default_widget(window, connect_button);
    gtk_box_append(GTK_BOX(action_box), cancel_button);
    gtk_box_append(GTK_BOX(action_box), connect_button);
    gtk_box_append(GTK_BOX(main_box), header);
    gtk_box_append(GTK_BOX(main_box), ssid_label);
    gtk_box_append(GTK_BOX(main_box), GTK_WIDGET(dialog_state->password_entry));
    gtk_box_append(GTK_BOX(main_box), action_box);
    gtk_window_present(window);
}





// ADD this small helper function near the top of main.c, with the other forward declarations.
static gboolean rescan_after_delay(gpointer user_data) {
    AppWidgets *widgets = user_data;
    if (widgets && widgets->wifi_scanner) {
        wifi_scanner_trigger_scan(widgets->wifi_scanner);
    }
    return G_SOURCE_REMOVE; // Run only once
}

// NEW HELPER: Updates just the sublabel of a Wi-Fi list row.
static void update_wifi_row_sublabel(GtkWidget *row_widget, const gchar *text) {
    if (!row_widget || !GTK_IS_BUTTON(row_widget)) return;

    GtkWidget *box = gtk_button_get_child(GTK_BUTTON(row_widget));
    if (!box) return;

    // The text container is usually the second widget in the box (after the icon stack).
    GtkWidget *text_container = gtk_widget_get_next_sibling(gtk_widget_get_first_child(box));
    if (text_container && GTK_IS_BOX(text_container)) {
        GtkWidget *sublabel_widget = gtk_widget_get_last_child(text_container);
        if (sublabel_widget && GTK_IS_LABEL(sublabel_widget) && gtk_widget_has_css_class(sublabel_widget, "connected-sublabel")) {
            gtk_label_set_text(GTK_LABEL(sublabel_widget), text);
            gtk_widget_set_visible(sublabel_widget, TRUE);
        }
    }
}

static void on_wifi_operation_finished(gboolean success, gpointer user_data) {
    WifiOpContext *context = user_data;
    g_print("[FORGET DEBUG] 5. Callback 'on_wifi_operation_finished' received. Success: %s\n", success ? "TRUE" : "FALSE");
    
    if (!context || !context->widgets) {
        g_warning("[FORGET DEBUG] Context or widgets are NULL in callback. Aborting.\n");
        if (context) g_free(context);
        return;
    }

    if (success) {
        g_print("[FORGET DEBUG] 6. Success branch: Triggering IMMEDIATE scan.\n");
        wifi_scanner_trigger_scan(context->widgets->wifi_scanner);
    } else {
        g_print("[FORGET DEBUG] 6. Failure branch: Showing error message and scheduling delayed scan.\n");
        if (context->row_widget) {
            GtkWidget* box = gtk_button_get_child(GTK_BUTTON(context->row_widget));
            GtkWidget* icon_stack = gtk_widget_get_first_child(box);
            if (icon_stack && GTK_IS_STACK(icon_stack)) {
                gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "icon");
            }
            update_wifi_row_sublabel(context->row_widget, "Authentication failed");
        }
        g_timeout_add(2500, rescan_after_delay, context->widgets);
    }

    g_free(context);
}

// The callback that runs AFTER the background connect/disconnect thread finishes.
static void on_bt_operation_finished(gboolean success, gpointer user_data) {
    // --- ADD THIS LOG ---
    g_print("[UI DEBUG] on_bt_operation_finished callback received. Success: %s\n", success ? "TRUE" : "FALSE");

    (void)success; // We don't use the success flag here, but it's good to see it.
    AppWidgets *widgets = user_data;
    if(!widgets) return;

    // This is safe to call even if the spinner wasn't started.
    gtk_spinner_stop(GTK_SPINNER(widgets->bt_list_spinner));
    gtk_widget_set_sensitive(gtk_overlay_get_child(GTK_OVERLAY(widgets->bt_list_overlay)), TRUE);

    // A refresh is needed for both connect and disconnect to update the list state.
    // --- ADD THIS LOG ---
    g_print("[UI DEBUG] Triggering UI refresh from on_bt_operation_finished.\n");
    bluetooth_scanner_trigger_scan(widgets->bt_scanner);
}

static void on_sink_set_finished(gboolean success, gpointer user_data) {
    if (success) update_audio_device_list(user_data);
}

static void on_password_ready(const gchar *password, gpointer user_data) {
    PasswordDialogContext *context = user_data;
    AppWidgets *widgets = context->widgets;
    WifiNetwork *net = context->network;
    // Pass our new, smarter callback
    WifiOpContext *op_context = g_new0(WifiOpContext, 1);
    op_context->widgets = widgets;
    op_context->row_widget = context->connecting_widget;
    add_and_activate_wifi_connection_async(net->ssid, net->object_path, password, net->is_secure, on_wifi_operation_finished, op_context);
    // The context is freed by the cancel handler on the dialog destroy signal
}

// NEW HELPER: Creates a styled button for our new popover menu.
static GtkWidget* create_popover_action_button(const char* icon_name, const char* label) {
    GtkWidget *button = gtk_button_new();
    gtk_widget_add_css_class(button, "popover-action-button");
    
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 8);
    gtk_button_set_child(GTK_BUTTON(button), box);
    
    GtkWidget *icon = gtk_image_new_from_icon_name(icon_name);
    gtk_widget_add_css_class(icon, "dim-label");
    
    GtkWidget *label_widget = gtk_label_new(label);
    gtk_label_set_xalign(GTK_LABEL(label_widget), 0.0);
    
    gtk_box_append(GTK_BOX(box), icon);
    gtk_box_append(GTK_BOX(box), label_widget);
    
    return button;
}

// NEW HANDLER: This is called when the "Details" button is clicked.
static void on_details_button_clicked(GtkButton *button, GtkPopover *parent_popover) {
    // Close the first menu immediately
    gtk_popover_popdown(parent_popover);
    
    // Retrieve the data we attached earlier
    WifiNetwork *net = g_object_get_data(G_OBJECT(button), "wifi-network-data");
    GtkWidget *parent_widget = g_object_get_data(G_OBJECT(button), "parent-widget");
    if (!net || !parent_widget) return;

    // Create a context to pass to our callback
    DetailsCallbackContext *context = g_new0(DetailsCallbackContext, 1);
    context->parent_popover = parent_popover;
    context->parent_widget = parent_widget;

    // Start the asynchronous operation. The UI will be updated in on_details_received.
    get_wifi_network_details_async(net->object_path, on_details_received, context);
}

// --- Click Handlers (Left-Click) ---
static void on_qr_button_pressed(GtkGestureClick *gesture, int n_press, double x, double y, gpointer user_data) {
    (void)n_press; (void)x; (void)y; (void)user_data;

    // Use the GTK_GESTURE() macro to cast the GtkGestureClick* to a GtkGesture*
    gtk_gesture_set_state(GTK_GESTURE(gesture), GTK_EVENT_SEQUENCE_CLAIMED);

    g_print("[UI DEBUG] Gesture captured click on QR button!\n");
    GtkWidget *button = gtk_event_controller_get_widget(GTK_EVENT_CONTROLLER(gesture));
    on_qr_button_clicked(GTK_BUTTON(button), NULL);
}

static void on_wifi_network_clicked(GtkButton *button, gpointer user_data) {
    // The user_data is now unused, we get the data from the button.
    (void)user_data;
    WifiNetwork *net = get_wifi_network_from_widget(GTK_WIDGET(button));
    AppWidgets *widgets = get_widgets_from_child(GTK_WIDGET(button));
    if (!widgets || !net || net->is_active) return; // Added !net check

    GtkWidget* box = gtk_button_get_child(GTK_BUTTON(button));
    GtkWidget* icon_stack = gtk_widget_get_first_child(box);
    // ... the rest of the function is identical to your existing code ...
    if (icon_stack && GTK_IS_STACK(icon_stack)) {
        GtkWidget* spinner = gtk_stack_get_child_by_name(GTK_STACK(icon_stack), "spinner");
        if(spinner) gtk_spinner_start(GTK_SPINNER(spinner));
        gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "spinner");
    }
    
    // Create the context for the async operation callback.
    WifiOpContext *op_context = g_new0(WifiOpContext, 1);
    op_context->widgets = widgets;
    op_context->row_widget = GTK_WIDGET(button);

    g_autofree gchar *existing_connection_path = find_connection_for_ssid(net->ssid);
    if (existing_connection_path) {
        activate_wifi_connection_async(existing_connection_path, net->object_path, on_wifi_operation_finished, op_context);
    } else {
        if (net->is_secure) {
            PasswordDialogContext *context = g_new0(PasswordDialogContext, 1);
            context->widgets = widgets;
            context->network = net;
            context->connecting_widget = GTK_WIDGET(button);
            GtkWindow *parent_window = GTK_WINDOW(gtk_widget_get_root(GTK_WIDGET(button)));
            show_password_prompt(parent_window, net->ssid, on_password_ready, on_password_cancelled, context);
            // Free the op_context if we are showing a password prompt, as it will be created again in on_password_ready
            g_free(op_context);
        } else {
            add_and_activate_wifi_connection_async(net->ssid, net->object_path, NULL, net->is_secure, on_wifi_operation_finished, op_context);
        }
    }
}

static void on_bluetooth_device_clicked(GtkButton *button, gpointer user_data) {
    BluetoothDevice *dev = (BluetoothDevice*)user_data;
    AppWidgets *widgets = get_widgets_from_child(GTK_WIDGET(button));
    if (!widgets || dev->is_connected) {
        return;
    }

    // --- START MODIFICATION ---
    // Instead of disabling the whole list, show a spinner on the clicked row.
    GtkWidget* box = gtk_button_get_child(GTK_BUTTON(button));
    GtkWidget* icon_stack = gtk_widget_get_first_child(box);
    if (icon_stack && GTK_IS_STACK(icon_stack)) {
        GtkWidget* spinner = gtk_stack_get_child_by_name(GTK_STACK(icon_stack), "spinner");
        if(spinner) gtk_spinner_start(GTK_SPINNER(spinner));
        gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "spinner");
    }
    // --- END MODIFICATION ---

    connect_to_bluetooth_device_async(dev->address, on_bt_operation_finished, widgets);
}

static void on_audio_sink_clicked(GtkButton *button, AudioSink *sink) {
    AppWidgets *widgets = get_widgets_from_child(GTK_WIDGET(button));
    if(!widgets) {
        return;
    }
    set_default_sink_async(sink->id, on_sink_set_finished, widgets);
}

static void toggle_airplane_mode(GtkToggleButton *button, AppWidgets *widgets) {
    gboolean is_active = gtk_toggle_button_get_active(button);

    if (is_active) {
        // --- Turning Airplane Mode ON ---
        widgets->airplane_mode_active = TRUE;
        
        // Store the current state of Wi-Fi and Bluetooth
        widgets->wifi_was_on_before_airplane = is_wifi_enabled();
        widgets->bt_was_on_before_airplane = is_bluetooth_powered();

        // Turn them off if they are currently on
        if (widgets->wifi_was_on_before_airplane) {
            set_wifi_enabled_async(FALSE, NULL, NULL);
        }
        if (widgets->bt_was_on_before_airplane) {
            set_bluetooth_powered_async(FALSE, NULL, NULL);
        }
        
    } else {
        // --- Turning Airplane Mode OFF ---
        widgets->airplane_mode_active = FALSE;
        
        // Restore their previous states
        if (widgets->wifi_was_on_before_airplane) {
            set_wifi_enabled_async(TRUE, NULL, NULL);
        }
        if (widgets->bt_was_on_before_airplane) {
            set_bluetooth_powered_async(TRUE, NULL, NULL);
        }
    }
}

// --- Click Handlers (Right-Click Popover Actions) ---
static void on_forget_button_clicked(GtkButton *button, GtkPopover *popover) {
    gtk_popover_popdown(popover);
    AppWidgets *widgets = get_widgets_from_child(GTK_WIDGET(button));
    if (!widgets) return;

    const char *ssid = g_object_get_data(G_OBJECT(button), "ssid-to-forget");
    g_print("\n\n[FORGET DEBUG] 1. 'Forget' button clicked for SSID: '%s'\n", ssid);
    
    GtkWidget *row_widget = g_object_get_data(G_OBJECT(button), "parent-widget");

    WifiOpContext *op_context = g_new0(WifiOpContext, 1);
    op_context->widgets = widgets;
    op_context->row_widget = row_widget;
    forget_wifi_connection_async(ssid, on_wifi_operation_finished, op_context);
}

static void on_disconnect_button_clicked(GtkButton *button, GtkPopover *popover) {
    gtk_popover_popdown(popover);
    AppWidgets *widgets = get_widgets_from_child(GTK_WIDGET(button));
    if (!widgets) return;

    WifiOpContext *op_context = g_new0(WifiOpContext, 1);
    op_context->widgets = widgets;
    op_context->row_widget = NULL; // No specific row for this operation
    disconnect_wifi_async(on_wifi_operation_finished, op_context);
}

// The helper function that actually calls the disconnect logic.
static void on_bt_do_disconnect(const gchar* address, GtkWidget* row_widget, AppWidgets* widgets) {
    g_print("[UI DEBUG] on_bt_do_disconnect called for address: %s\n", address);

    if (!widgets || !row_widget) return;

    // <<< FIX: The spinner is inside the row_widget (a GtkBox) now.
    GtkWidget* icon_stack = gtk_widget_get_first_child(row_widget);
    if (icon_stack && GTK_IS_STACK(icon_stack)) {
        GtkWidget* spinner = gtk_stack_get_child_by_name(GTK_STACK(icon_stack), "spinner");
        if(spinner) gtk_spinner_start(GTK_SPINNER(spinner));
        gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "spinner");
    }

    g_print("[UI DEBUG] -> Calling disconnect_bluetooth_device_async...\n");
    disconnect_bluetooth_device_async(address, on_bt_operation_finished, widgets);
}


// The handler for the small "connect" icon button on a disconnected device row.
static void on_bt_row_connect_button_clicked(GtkButton *button, gpointer user_data) {
    (void)user_data;
    BluetoothDevice *dev = g_object_get_data(G_OBJECT(button), "device-data");
    GtkWidget *row_widget = g_object_get_data(G_OBJECT(button), "parent-row-widget");
    AppWidgets *widgets = get_widgets_from_child(row_widget);
    
    if (dev && row_widget && widgets && !dev->is_connected) {
        g_print("[UI DEBUG] Connect button clicked for device: '%s' (%s)\n", dev->name, dev->address);
        
        // <<< FIX: The spinner is inside the row_widget (a GtkBox) now.
        // We find it by getting the first child of the box.
        GtkWidget* icon_stack = gtk_widget_get_first_child(row_widget);
        if (icon_stack && GTK_IS_STACK(icon_stack)) {
            GtkWidget* spinner = gtk_stack_get_child_by_name(GTK_STACK(icon_stack), "spinner");
            if(spinner) gtk_spinner_start(GTK_SPINNER(spinner));
            gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "spinner");
        }
        
        g_print("[UI DEBUG] -> Calling connect_to_bluetooth_device_async...\n");
        connect_to_bluetooth_device_async(dev->address, on_bt_operation_finished, widgets);
    }
}


// The handler for the small "disconnect" icon button on a connected device row.
static void on_bt_row_disconnect_button_clicked(GtkButton *button, gpointer user_data) {
    (void)user_data; // This handler doesn't use the user_data parameter, so we mark it as unused.

    // We get all the necessary data from the GObjects themselves.
    BluetoothDevice *dev = g_object_get_data(G_OBJECT(button), "device-data");
    GtkWidget *row_widget = g_object_get_data(G_OBJECT(button), "parent-row-widget");
    AppWidgets *widgets = get_widgets_from_child(row_widget);
    
    // Ensure all data was retrieved successfully before proceeding.
    if (dev && row_widget && widgets) {
        // --- ADD THIS LOG ---
        g_print("[UI DEBUG] Disconnect ICON button clicked for device: '%s' (%s)\n", dev->name, dev->address);
        
        // --- ADD THIS LOG ---
        g_print("[UI DEBUG] -> Calling on_bt_do_disconnect...\n");
        on_bt_do_disconnect(dev->address, row_widget, widgets);
    }
}

// NEW HANDLER for the "Connect" button in the right-click menu
static void on_connect_button_clicked(GtkButton *button, GtkPopover *popover) {
    gtk_popover_popdown(popover); // Close the menu first

    // Retrieve the data we attached to the button
    WifiNetwork *net = g_object_get_data(G_OBJECT(button), "wifi-network-data");
    AppWidgets *widgets = g_object_get_data(G_OBJECT(button), "app-widgets-data");
    // Get the original row widget that the popover is attached to
    GtkWidget *row_widget = gtk_widget_get_parent(GTK_WIDGET(popover));

    if (!widgets || !net || net->is_active) {
        return;
    }

    // Create context for the callback
    WifiOpContext *op_context = g_new0(WifiOpContext, 1);
    op_context->widgets = widgets;
    op_context->row_widget = row_widget; // Pass the original row widget

    g_autofree gchar *existing_connection_path = find_connection_for_ssid(net->ssid);
    if (existing_connection_path) {
        activate_wifi_connection_async(existing_connection_path, net->object_path, on_wifi_operation_finished, op_context);
    } else {
        // We'll need to add a password prompt here in the future, but for now, it will
        // attempt to connect to open networks or use a previously known password.
        add_and_activate_wifi_connection_async(net->ssid, net->object_path, NULL, net->is_secure, on_wifi_operation_finished, op_context);
    }
}

// Helper to get the BluetoothDevice data back from a row widget.
static BluetoothDevice* get_bluetooth_device_from_widget(GtkWidget *row_widget) {
    if (!row_widget) return NULL;
    return g_object_get_data(G_OBJECT(row_widget), "device-data");
}

// The "smart update" function. Modifies a row in-place without rebuilding it.
static void update_bt_widget_state(GtkWidget *row_hbox, BluetoothDevice *dev) {
    GtkWidget* icon_stack = gtk_widget_get_first_child(row_hbox);
    if (!icon_stack) return;

    // Reset Spinner
    if (GTK_IS_STACK(icon_stack)) {
        gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "icon");
    }

    // Update Active State
    if (dev->is_connected) {
        gtk_widget_add_css_class(row_hbox, "active-network");
    } else {
        gtk_widget_remove_css_class(row_hbox, "active-network");
    }

    // --- Update Connect/Disconnect Button ---
    GtkWidget *button_to_remove = NULL;
    GtkWidget *child = gtk_widget_get_first_child(row_hbox);
    while (child) {
        if (gtk_widget_has_css_class(child, "connect-button") || gtk_widget_has_css_class(child, "disconnect-button")) {
            button_to_remove = child;
            break;
        }
        child = gtk_widget_get_next_sibling(child);
    }
    if (button_to_remove) {
        gtk_box_remove(GTK_BOX(row_hbox), button_to_remove);
    }

    if (dev->is_connected) {
        GtkWidget *disconnect_button = gtk_button_new_from_icon_name("network-wired-disconnected-symbolic");
        gtk_widget_add_css_class(disconnect_button, "disconnect-button");
        gtk_widget_set_tooltip_text(disconnect_button, "Disconnect");
        g_object_set_data(G_OBJECT(disconnect_button), "device-data", dev);
        g_object_set_data(G_OBJECT(disconnect_button), "parent-row-widget", row_hbox);
        g_signal_connect(disconnect_button, "clicked", G_CALLBACK(on_bt_row_disconnect_button_clicked), NULL);
        gtk_box_append(GTK_BOX(row_hbox), disconnect_button);
    } else {
        GtkWidget *connect_button = gtk_button_new_from_icon_name("network-wired-symbolic");
        gtk_widget_add_css_class(connect_button, "connect-button");
        gtk_widget_set_tooltip_text(connect_button, "Connect");
        g_object_set_data(G_OBJECT(connect_button), "device-data", dev);
        g_object_set_data(G_OBJECT(connect_button), "parent-row-widget", row_hbox);
        g_signal_connect(connect_button, "clicked", G_CALLBACK(on_bt_row_connect_button_clicked), NULL);
        gtk_box_append(GTK_BOX(row_hbox), connect_button);
    }
}


// HELPER 1: Correctly gets the WifiNetwork data back from a list item's controller.
static WifiNetwork* get_wifi_network_from_widget(GtkWidget *list_item) {
    return g_object_get_data(G_OBJECT(list_item), "wifi-network-data");
}

// HELPER 2: Updates the UI of an existing row widget without destroying it.
static void update_wifi_widget_state(GtkWidget *button, WifiNetwork *net) {
    GtkWidget *box = gtk_button_get_child(GTK_BUTTON(button));
    if (!box) return;
 
    // --- Update the Icon and Spinner ---
    GtkWidget *icon_stack = gtk_widget_get_first_child(box);
    if (icon_stack && GTK_IS_STACK(icon_stack)) {
        GtkWidget *icon = gtk_stack_get_child_by_name(GTK_STACK(icon_stack), "icon");
        if (icon && GTK_IS_IMAGE(icon)) {
            const char *icon_name = get_wifi_icon_name_for_signal(net->strength);
            gtk_image_set_from_icon_name(GTK_IMAGE(icon), icon_name);
        }
        // Ensure spinner is always hidden on a refresh. It's only shown on click.
        gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "icon");
    }
 
    // --- Update the Active State ---
    if (net->is_active) {
        gtk_widget_add_css_class(button, "active-network");
    } else {
        gtk_widget_remove_css_class(button, "active-network");
    }
    
    // --- FIX: Update the sublabel text, which was previously skipped ---
    const gchar *sublabel_text = NULL;
    if (net->is_active) {
        switch (net->connectivity) {
            case WIFI_STATE_CONNECTED: sublabel_text = "Connected"; break;
            case WIFI_STATE_LIMITED: sublabel_text = "Connected / No Internet Access"; break;
            case WIFI_STATE_CONNECTING: sublabel_text = "Connecting..."; break;
            default: sublabel_text = "Connected"; break;
        }
    } else if (net->is_known) {
        sublabel_text = "Saved";
    }

    // Find the container for the text labels (it's the next sibling after the icon_stack)
    GtkWidget *text_container = icon_stack ? gtk_widget_get_next_sibling(icon_stack) : NULL;
    
    // We can only update the sublabel if the widget was created with one (i.e., text_container is a GtkBox).
    if (text_container && GTK_IS_BOX(text_container)) {
        GtkWidget *sublabel_widget = gtk_widget_get_last_child(text_container);
        if (sublabel_widget && GTK_IS_LABEL(sublabel_widget) && gtk_widget_has_css_class(sublabel_widget, "connected-sublabel")) {
            if (sublabel_text) {
                gtk_label_set_text(GTK_LABEL(sublabel_widget), sublabel_text);
                gtk_widget_set_visible(sublabel_widget, TRUE);
            } else {
                gtk_widget_set_visible(sublabel_widget, FALSE);
            }
        }
    }
}

// --- Gesture Handlers (Right-Click) ---
static void on_wifi_right_click(GtkGestureClick *gesture, int n_press, double x, double y, gpointer user_data) {
    (void)n_press; (void)x; (void)y; (void)user_data;

    // This tells GTK that the right-click has been handled, allowing subsequent clicks on the popover buttons to work correctly.
    gtk_gesture_set_state(GTK_GESTURE(gesture), GTK_EVENT_SEQUENCE_CLAIMED);

    GtkWidget *button_widget = gtk_event_controller_get_widget(GTK_EVENT_CONTROLLER(gesture));
    WifiNetwork *net = get_wifi_network_from_widget(button_widget);
    AppWidgets *widgets = get_widgets_from_child(button_widget);
    if (!net) return;
    
    GtkPopover *popover = GTK_POPOVER(gtk_popover_new());
    g_signal_connect(popover, "closed", G_CALLBACK(on_popover_closed), NULL);

    GtkWidget *menu_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_popover_set_child(popover, menu_box);

    GtkWidget *details_button = create_popover_action_button("dialog-information-symbolic", "Details");
    g_object_set_data(G_OBJECT(details_button), "wifi-network-data", net);
    g_object_set_data(G_OBJECT(details_button), "parent-widget", button_widget);
    g_signal_connect(details_button, "clicked", G_CALLBACK(on_details_button_clicked), popover);
    gtk_box_append(GTK_BOX(menu_box), details_button);

    gtk_box_append(GTK_BOX(menu_box), gtk_separator_new(GTK_ORIENTATION_HORIZONTAL));

    if (net->is_active) {
        GtkWidget *disconnect_button = create_popover_action_button("network-wired-disconnected-symbolic", "Disconnect");
        g_signal_connect(disconnect_button, "clicked", G_CALLBACK(on_disconnect_button_clicked), popover);
        gtk_box_append(GTK_BOX(menu_box), disconnect_button);
    } else {
        GtkWidget *connect_button = create_popover_action_button("network-wired-symbolic", "Connect");
        g_object_set_data(G_OBJECT(connect_button), "wifi-network-data", net);
        g_object_set_data(G_OBJECT(connect_button), "app-widgets-data", widgets);
        g_signal_connect(connect_button, "clicked", G_CALLBACK(on_connect_button_clicked), popover);
        gtk_box_append(GTK_BOX(menu_box), connect_button);

        if (net->is_known) {
            GtkWidget *forget_button = create_popover_action_button("edit-delete-symbolic", "Forget");
            g_object_set_data(G_OBJECT(forget_button), "ssid-to-forget", (gpointer)net->ssid);
            
            // *** THE FIX WAS HERE ***
            // The 'parent-widget' data must be set on the 'forget_button' itself, not the details button.
            g_object_set_data(G_OBJECT(forget_button), "parent-widget", button_widget);
            
            g_signal_connect(forget_button, "clicked", G_CALLBACK(on_forget_button_clicked), popover);
            gtk_box_append(GTK_BOX(menu_box), forget_button);
        }
    }
    
    gtk_widget_set_parent(GTK_WIDGET(popover), button_widget);
    gtk_popover_popup(popover);
}

// The handler for the "Disconnect" button in the right-click popover menu.
static void on_bt_popover_disconnect_clicked(GtkButton *button, GtkPopover *popover) {
    gtk_popover_popdown(popover);
    AppWidgets *widgets = get_widgets_from_child(GTK_WIDGET(button));
    if (!widgets) return;

    const char *address = g_object_get_data(G_OBJECT(button), "address-to-disconnect");
    GtkWidget *row_widget = g_object_get_data(G_OBJECT(button), "parent-row-widget");

    // --- ADD THIS LOG ---
    g_print("[UI DEBUG] Popover Disconnect clicked for address: %s\n", address);
    
    // --- ADD THIS LOG ---
    g_print("[UI DEBUG] -> Calling on_bt_do_disconnect....\n");
    on_bt_do_disconnect(address, row_widget, widgets);
}

static void on_bluetooth_right_click(GtkGestureClick *gesture, int n_press, double x, double y, gpointer user_data) {
    (void)n_press; (void)x; (void)y;
    BluetoothDevice *dev = user_data;
    if (!dev->is_connected) {
        return;
    }

    GtkWidget *button_widget = gtk_event_controller_get_widget(GTK_EVENT_CONTROLLER(gesture));
    
    GtkPopover *popover = GTK_POPOVER(gtk_popover_new());
    g_signal_connect(popover, "closed", G_CALLBACK(on_popover_closed), NULL);

    GtkWidget *menu_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_popover_set_child(popover, menu_box);

    GtkWidget *disconnect_button = create_popover_action_button("network-wired-disconnected-symbolic", "Disconnect");
    g_object_set_data(G_OBJECT(disconnect_button), "address-to-disconnect", (gpointer)dev->address);
    // --- START MODIFICATION ---
    // Store a reference to the main row widget
    g_object_set_data(G_OBJECT(disconnect_button), "parent-row-widget", button_widget);
    // --- END MODIFICATION ---
    g_signal_connect(disconnect_button, "clicked", G_CALLBACK(on_bt_popover_disconnect_clicked), popover);
    gtk_box_append(GTK_BOX(menu_box), disconnect_button);

    gtk_widget_set_parent(GTK_WIDGET(popover), button_widget);
    gtk_popover_popup(popover);
}



// --- UI Update & Change Handlers ---
static void on_system_volume_changed(GtkRange *range, gpointer user_data) {
    (void)user_data;
    gint value = (gint)gtk_range_get_value(range);
    set_default_sink_volume_async(value, NULL, NULL);
}

static void on_brightness_changed(GtkRange *range, gpointer user_data) {
    (void)user_data;
    gint value = (gint)gtk_range_get_value(range);
    set_brightness_async(value);
}

static void on_system_event(SystemEventType type, gpointer user_data) {
    AppWidgets *widgets = user_data;
    if(!widgets) {
        return;
    }

    switch (type) {
        case SYSTEM_EVENT_VOLUME_CHANGED: {
            AudioSinkState *state = get_default_sink_state();
            if (state) {
                g_signal_handler_block(widgets->system_volume_slider, widgets->system_volume_handler_id);
                gtk_range_set_value(GTK_RANGE(widgets->system_volume_slider), state->volume);
                g_signal_handler_unblock(widgets->system_volume_slider, widgets->system_volume_handler_id);
                g_free(state);
            }
            break;
        }
        case SYSTEM_EVENT_BRIGHTNESS_CHANGED: {
            gint brightness = get_current_brightness();
            if (brightness >= 0) {
                g_signal_handler_block(widgets->brightness_slider, widgets->brightness_slider_handler_id);
                gtk_range_set_value(GTK_RANGE(widgets->brightness_slider), brightness);
                g_signal_handler_unblock(widgets->brightness_slider, widgets->brightness_slider_handler_id);
            }
            break;
        }
    }
}

// --- UI Construction Helpers ---
static GtkWidget* create_list_entry(const char* icon, const char* label_text, gboolean is_active) {
    GtkWidget *button = gtk_button_new();
    gtk_widget_add_css_class(button, "list-item-button");

    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
    gtk_button_set_child(GTK_BUTTON(button), box);

    gtk_box_append(GTK_BOX(box), gtk_image_new_from_icon_name(icon));

    GtkWidget *label = gtk_label_new(label_text);
    gtk_widget_set_halign(label, GTK_ALIGN_START);
    gtk_widget_set_hexpand(label, TRUE);
    gtk_box_append(GTK_BOX(box), label);

    // --- MODIFICATION IS HERE ---
    if (is_active) {
        // Replace the GtkLabel with a GtkImage using a standard checkmark icon.
        GtkWidget *check_icon = gtk_image_new_from_icon_name("object-select-symbolic");
        gtk_widget_add_css_class(check_icon, "active-symbol");
        gtk_box_append(GTK_BOX(box), check_icon);
    }
    // --- END MODIFICATION ---

    return button;
}

static const char* get_wifi_icon_name_for_signal(int strength) {
    if (strength > 80) return "network-wireless-signal-excellent-symbolic";
    if (strength > 55) return "network-wireless-signal-good-symbolic";
    if (strength > 30) return "network-wireless-signal-ok-symbolic";
    if (strength > 5)  return "network-wireless-signal-weak-symbolic";
    return "network-wireless-signal-none-symbolic";
}

// --- List Update Functions ---
static void update_audio_device_list(AppWidgets *widgets) {
    if (!widgets) return;
    GtkWidget *list_box = widgets->audio_list_box;
    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(list_box))) {
        gtk_box_remove(GTK_BOX(list_box), child);
    }
    GList *sinks = get_audio_sinks();
    if (g_list_length(sinks) == 0) {
        gtk_box_append(GTK_BOX(list_box), gtk_label_new("No audio devices found."));
    } else {
        for (GList *l = sinks; l != NULL; l = l->next) {
            AudioSink *sink_from_scan = l->data;
            AudioSink *sink_copy = g_new0(AudioSink, 1);
            *sink_copy = *sink_from_scan;
            sink_copy->name = g_strdup(sink_from_scan->name);

            GtkWidget *entry_button = create_list_entry("audio-card-symbolic", sink_copy->name, sink_copy->is_default);
            g_signal_connect(entry_button, "clicked", G_CALLBACK(on_audio_sink_clicked), sink_copy);
            g_signal_connect_swapped(entry_button, "destroy", G_CALLBACK(audio_sink_free), sink_copy);
            gtk_box_append(GTK_BOX(list_box), entry_button);
        }
    }
    free_audio_sink_list(sinks);
}

// NEW HANDLER: Called by the bluetooth_manager when the device list changes.
static void on_bt_devices_updated(GList *devices, gpointer user_data) {
    // This function simply forwards the updated list to your existing UI logic.
    // We keep the old on_bt_scan_results function to avoid rewriting all the UI code.
    on_bt_scan_results(devices, user_data);
}

// The final callback that displays the QR code
static void on_qr_code_received(GdkPixbuf *pixbuf, gpointer user_data) {
    QRCodeCallbackContext *context = user_data;
    
    if (context->spinner_popover) {
        gtk_popover_popdown(context->spinner_popover);
    }

    GtkPopover *qr_popover = GTK_POPOVER(gtk_popover_new());
    gtk_widget_add_css_class(GTK_WIDGET(qr_popover), "qr-code-popover"); // Add class to popover
    g_signal_connect(qr_popover, "closed", G_CALLBACK(on_popover_closed), NULL);

    if (pixbuf) {
        GtkWidget *popover_content_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
        
        GdkPaintable *paintable = GDK_PAINTABLE(gdk_texture_new_for_pixbuf(pixbuf));
        GtkWidget *qr_image = gtk_image_new_from_paintable(paintable);
        gtk_image_set_pixel_size(GTK_IMAGE(qr_image), 256);
        
        g_autofree gchar *label_text = g_strdup_printf("Scan to connect to \"%s\"", context->ssid);
        GtkWidget *info_label = gtk_label_new(label_text);
        gtk_label_set_wrap(GTK_LABEL(info_label), TRUE);
        gtk_widget_add_css_class(info_label, "dim-label"); // Keep for fallback
        gtk_widget_add_css_class(info_label, "qr-info-label"); // Add our specific class

        gtk_box_append(GTK_BOX(popover_content_box), qr_image);
        gtk_box_append(GTK_BOX(popover_content_box), info_label);

        gtk_widget_set_margin_top(popover_content_box, 15);
        gtk_widget_set_margin_bottom(popover_content_box, 15);
        gtk_widget_set_margin_start(popover_content_box, 15);
        gtk_widget_set_margin_end(popover_content_box, 15);

        gtk_popover_set_child(qr_popover, popover_content_box);

    } else {
        GtkWidget *error_label = gtk_label_new("Could not retrieve Wi-Fi password.\nCheck terminal for D-Bus or Polkit errors.");
        gtk_label_set_wrap(GTK_LABEL(error_label), TRUE);
        gtk_widget_set_margin_start(error_label, 15);
        gtk_widget_set_margin_end(error_label, 15);
        gtk_widget_set_margin_top(error_label, 15);
        gtk_widget_set_margin_bottom(error_label, 15);
        gtk_popover_set_child(qr_popover, error_label);
    }

    gtk_widget_set_parent(GTK_WIDGET(qr_popover), context->parent_widget);
    gtk_popover_popup(qr_popover);
    
    g_free(context->ssid);
    g_free(context);
}


static void on_qr_button_clicked(GtkButton *button, gpointer user_data) {
    (void)user_data;
    WifiNetwork *net = g_object_get_data(G_OBJECT(button), "wifi-network-data");
    if (!net) return;
    
    GtkPopover *spinner_popover = GTK_POPOVER(gtk_popover_new());
    GtkWidget *spinner = gtk_spinner_new();
    gtk_spinner_start(GTK_SPINNER(spinner));
    gtk_widget_set_margin_start(spinner, 15);
    gtk_widget_set_margin_end(spinner, 15);
    gtk_widget_set_margin_top(spinner, 15);
    gtk_widget_set_margin_bottom(spinner, 15);
    gtk_popover_set_child(spinner_popover, spinner);
    gtk_widget_set_parent(GTK_WIDGET(spinner_popover), GTK_WIDGET(button));
    gtk_popover_popup(spinner_popover);

    QRCodeCallbackContext *context = g_new0(QRCodeCallbackContext, 1);
    context->parent_widget = GTK_WIDGET(button);
    context->spinner_popover = spinner_popover;
    context->ssid = g_strdup(net->ssid); 
    
    generate_wifi_qr_code_async(net->ssid, on_qr_code_received, context);
}



// This helper function makes our icon usage robust.
static const char* get_best_available_icon(const char **icon_names) {
    GtkIconTheme *icon_theme = gtk_icon_theme_get_for_display(gdk_display_get_default());
    for (int i = 0; icon_names[i] != NULL; i++) {
        if (gtk_icon_theme_has_icon(icon_theme, icon_names[i])) {
            return icon_names[i];
        }
    }
    // Return the last icon in the list as the ultimate fallback.
    return icon_names[g_strv_length((gchar**)icon_names) - 1];
}

static void on_wifi_scan_results(GList *networks, gpointer user_data) {
    AppWidgets *widgets = (AppWidgets*)user_data;
    if (!widgets || !widgets->wifi_connected_list_box || !widgets->wifi_available_list_box) { 
        free_wifi_network_list(networks); 
        return; 
    }

    GtkWidget *connected_list = widgets->wifi_connected_list_box;
    GtkWidget *available_list = widgets->wifi_available_list_box;

    GHashTable *existing_widgets = g_hash_table_new(g_str_hash, g_str_equal);
    for (GtkWidget *child = gtk_widget_get_first_child(connected_list); child != NULL; child = gtk_widget_get_next_sibling(child)) {
        WifiNetwork *net = get_wifi_network_from_widget(child);
        if (net && net->ssid) g_hash_table_insert(existing_widgets, (gpointer)net->ssid, child);
    }
    for (GtkWidget *child = gtk_widget_get_first_child(available_list); child != NULL; child = gtk_widget_get_next_sibling(child)) {
        WifiNetwork *net = get_wifi_network_from_widget(child);
        if (net && net->ssid) g_hash_table_insert(existing_widgets, (gpointer)net->ssid, child);
    }

    GHashTable *seen_ssids = g_hash_table_new(g_str_hash, g_str_equal);
    for (GList *l = networks; l != NULL; l = l->next) {
        WifiNetwork *net_from_scan = l->data;
        if (!net_from_scan || !net_from_scan->ssid) continue;

        g_hash_table_insert(seen_ssids, (gpointer)net_from_scan->ssid, GINT_TO_POINTER(1));
        GtkWidget *existing_button = g_hash_table_lookup(existing_widgets, net_from_scan->ssid);

        if (existing_button) {
            WifiNetwork *net_copy = get_wifi_network_from_widget(existing_button);
            net_copy->strength = net_from_scan->strength;
            net_copy->is_active = net_from_scan->is_active;
            net_copy->connectivity = net_from_scan->connectivity;
            net_copy->is_known = net_from_scan->is_known;
            update_wifi_widget_state(existing_button, net_copy);
            GtkWidget *box = gtk_button_get_child(GTK_BUTTON(existing_button));
            GtkWidget *last_child = gtk_widget_get_last_child(box);
            gboolean qr_button_exists = (last_child && gtk_widget_has_css_class(last_child, "wifi-qr-button"));
            if (net_copy->is_active && !qr_button_exists) {
                GtkWidget *qr_button = gtk_button_new_from_icon_name("view-grid-symbolic");
                gtk_widget_add_css_class(qr_button, "wifi-qr-button");
                gtk_widget_set_tooltip_text(qr_button, "Show QR code to connect");
                gtk_widget_set_valign(qr_button, GTK_ALIGN_CENTER);
                g_object_set_data(G_OBJECT(qr_button), "wifi-network-data", net_copy);
                GtkGesture *qr_click_gesture = gtk_gesture_click_new();
                g_signal_connect(qr_click_gesture, "pressed", G_CALLBACK(on_qr_button_pressed), NULL);
                gtk_widget_add_controller(qr_button, GTK_EVENT_CONTROLLER(qr_click_gesture));
                gtk_box_append(GTK_BOX(box), qr_button);
            } else if (!net_copy->is_active && qr_button_exists) {
                gtk_box_remove(GTK_BOX(box), last_child);
            }
            GtkWidget *current_parent = gtk_widget_get_parent(existing_button);
            if (net_copy->is_active && current_parent != connected_list) {
                gtk_widget_unparent(existing_button);
                gtk_box_append(GTK_BOX(connected_list), existing_button);
            } else if (!net_copy->is_active && current_parent != available_list) {
                gtk_widget_unparent(existing_button);
                gtk_box_append(GTK_BOX(available_list), existing_button);
            }
        } else {
            WifiNetwork *net_copy = g_new0(WifiNetwork, 1);
            *net_copy = *net_from_scan;
            net_copy->ssid = g_strdup(net_from_scan->ssid);
            net_copy->object_path = g_strdup(net_from_scan->object_path);
            GtkWidget *entry_button = gtk_button_new();
            g_object_set_data_full(G_OBJECT(entry_button), "wifi-network-data", net_copy, (GDestroyNotify)wifi_network_free);
            gtk_widget_add_css_class(entry_button, "list-item-button");
            GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
            gtk_button_set_child(GTK_BUTTON(entry_button), box);
            GtkWidget *icon_stack = gtk_stack_new();
            gtk_widget_set_valign(icon_stack, GTK_ALIGN_CENTER);
            const char *icon_name = get_wifi_icon_name_for_signal(net_copy->strength);
            gtk_stack_add_named(GTK_STACK(icon_stack), gtk_image_new_from_icon_name(icon_name), "icon");
            gtk_stack_add_named(GTK_STACK(icon_stack), gtk_spinner_new(), "spinner");
            gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "icon");
            gtk_box_append(GTK_BOX(box), icon_stack);
            GtkWidget *text_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
            gtk_widget_set_hexpand(text_vbox, TRUE);
            gtk_box_append(GTK_BOX(box), text_vbox);
            GtkWidget *label = gtk_label_new(net_copy->ssid);
            gtk_label_set_xalign(GTK_LABEL(label), 0.0);
            gtk_box_append(GTK_BOX(text_vbox), label);
            GtkWidget *sublabel = gtk_label_new("");
            gtk_widget_add_css_class(sublabel, "connected-sublabel");
            gtk_label_set_xalign(GTK_LABEL(sublabel), 0.0);
            gtk_box_append(GTK_BOX(text_vbox), sublabel);
            const gchar *sublabel_text = NULL;
            if (net_copy->is_active) {
                switch (net_copy->connectivity) {
                    case WIFI_STATE_CONNECTED: sublabel_text = "Connected"; break;
                    case WIFI_STATE_LIMITED: sublabel_text = "Connected / No Internet Access"; break;
                    case WIFI_STATE_CONNECTING: sublabel_text = "Connecting..."; break;
                    default: sublabel_text = "Connected"; break;
                }
            } else if (net_copy->is_known) {
                sublabel_text = "Saved";
            }
            if (sublabel_text) {
                gtk_label_set_text(GTK_LABEL(sublabel), sublabel_text);
                gtk_widget_set_visible(sublabel, TRUE);
            } else {
                gtk_widget_set_visible(sublabel, FALSE);
            }
            if (net_copy->is_secure) {
                GtkWidget *secure_icon = gtk_image_new_from_icon_name("network-wireless-encrypted-symbolic");
                gtk_widget_set_valign(secure_icon, GTK_ALIGN_CENTER);
                gtk_box_append(GTK_BOX(box), secure_icon);
            }
            g_signal_connect(entry_button, "clicked", G_CALLBACK(on_wifi_network_clicked), NULL);

            // *** THE FIX: Use GtkGestureClick on the "released" signal. ***
            GtkGesture *right_click = gtk_gesture_click_new();
            gtk_gesture_single_set_button(GTK_GESTURE_SINGLE(right_click), GDK_BUTTON_SECONDARY);
            g_signal_connect(right_click, "released", G_CALLBACK(on_wifi_right_click), NULL);
            gtk_widget_add_controller(entry_button, GTK_EVENT_CONTROLLER(right_click));
            // *** END FIX ***

            if (net_copy->is_active) {
                GtkWidget *qr_button = gtk_button_new_from_icon_name("view-grid-symbolic");
                gtk_widget_add_css_class(qr_button, "wifi-qr-button");
                gtk_widget_set_tooltip_text(qr_button, "Show QR code to connect");
                gtk_widget_set_valign(qr_button, GTK_ALIGN_CENTER);
                g_object_set_data(G_OBJECT(qr_button), "wifi-network-data", net_copy);
                GtkGesture *qr_click_gesture = gtk_gesture_click_new();
                g_signal_connect(qr_click_gesture, "pressed", G_CALLBACK(on_qr_button_pressed), NULL);
                gtk_widget_add_controller(qr_button, GTK_EVENT_CONTROLLER(qr_click_gesture));
                gtk_box_append(GTK_BOX(box), qr_button);
                gtk_box_append(GTK_BOX(connected_list), entry_button);
            } else {
                gtk_box_append(GTK_BOX(available_list), entry_button);
            }
        }
    }

    GList *widgets_to_remove = NULL;
    GHashTableIter iter;
    gpointer key, value;
    g_hash_table_iter_init(&iter, existing_widgets);
    while (g_hash_table_iter_next(&iter, &key, &value)) {
        if (!g_hash_table_contains(seen_ssids, key)) {
            widgets_to_remove = g_list_prepend(widgets_to_remove, value);
        }
    }
    for (GList *l = widgets_to_remove; l != NULL; l = l->next) {
        GtkWidget *widget_to_remove = l->data;
        if (GTK_IS_WIDGET(widget_to_remove)) {
            gtk_widget_unparent(widget_to_remove);
        }
    }
    g_list_free(widgets_to_remove);
    g_hash_table_destroy(existing_widgets);
    g_hash_table_destroy(seen_ssids);

    gboolean has_connected = (gtk_widget_get_first_child(connected_list) != NULL);
    gboolean has_available = (gtk_widget_get_first_child(available_list) != NULL);
    if (!is_wifi_enabled()) {
        GtkWidget *child;
        while ((child = gtk_widget_get_first_child(connected_list))) { gtk_box_remove(GTK_BOX(connected_list), child); }
        while ((child = gtk_widget_get_first_child(available_list))) { gtk_box_remove(GTK_BOX(available_list), child); }
        GtkWidget *label = gtk_label_new("Wi-Fi is turned off");
        gtk_widget_set_vexpand(label, TRUE);
        gtk_widget_set_valign(label, GTK_ALIGN_CENTER);
        gtk_box_append(GTK_BOX(available_list), label);
        has_connected = FALSE;
        has_available = TRUE;
    }
    gtk_widget_set_visible(widgets->wifi_connected_header, has_connected);
    gtk_widget_set_visible(widgets->wifi_available_header, has_available);
    free_wifi_network_list(networks);
}

static void on_bt_scan_results(GList *devices, gpointer user_data) {
    AppWidgets *widgets = (AppWidgets*)user_data;
    if(!widgets || !widgets->bt_connected_list_box || !widgets->bt_available_list_box) {
        free_bluetooth_device_list(devices);
        return;
    }

    gtk_spinner_stop(GTK_SPINNER(widgets->bt_header_spinner));
    GtkWidget *connected_list = widgets->bt_connected_list_box;
    GtkWidget *available_list = widgets->bt_available_list_box;

    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(connected_list)) != NULL) { gtk_box_remove(GTK_BOX(connected_list), child); }
    while ((child = gtk_widget_get_first_child(available_list)) != NULL) { gtk_box_remove(GTK_BOX(available_list), child); }

    gboolean has_connected = FALSE;
    gboolean has_available = FALSE;

    if (g_list_length(devices) == 0) {
        GtkWidget *placeholder = gtk_label_new("No Bluetooth devices found.");
        gtk_widget_set_vexpand(placeholder, TRUE);
        gtk_widget_set_valign(placeholder, GTK_ALIGN_CENTER);
        gtk_box_append(GTK_BOX(available_list), placeholder);
    } else {
        for (GList *l = devices; l != NULL; l = l->next) {
            BluetoothDevice *dev = l->data;
            BluetoothDevice *dev_copy = g_new0(BluetoothDevice, 1);
            dev_copy->address = g_strdup(dev->address);
            dev_copy->name = g_strdup(dev->name);
            dev_copy->is_connected = dev->is_connected;

            GtkWidget *row_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
            gtk_widget_add_css_class(row_hbox, "list-item-button");
            g_object_set_data_full(G_OBJECT(row_hbox), "device-data", dev_copy, (GDestroyNotify)bluetooth_device_free);

            GtkWidget *icon_stack = gtk_stack_new();
            gtk_widget_set_valign(icon_stack, GTK_ALIGN_CENTER);
            gtk_stack_add_named(GTK_STACK(icon_stack), gtk_image_new_from_icon_name("bluetooth-active-symbolic"), "icon");
            gtk_stack_add_named(GTK_STACK(icon_stack), gtk_spinner_new(), "spinner");
            gtk_stack_set_visible_child_name(GTK_STACK(icon_stack), "icon");
            gtk_box_append(GTK_BOX(row_hbox), icon_stack);
            
            // --- THIS IS THE KEY CONDITIONAL LOGIC ---
            if (dev->is_connected) {
                // If connected, create the VBox for Name + Sublabel
                GtkWidget *text_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
                gtk_widget_set_hexpand(text_vbox, TRUE);
                gtk_box_append(GTK_BOX(row_hbox), text_vbox);

                GtkWidget *label = gtk_label_new(dev_copy->name);
                gtk_label_set_xalign(GTK_LABEL(label), 0.0);
                gtk_box_append(GTK_BOX(text_vbox), label);

                GtkWidget *sublabel = gtk_label_new("Connected");
                gtk_widget_add_css_class(sublabel, "connected-sublabel");
                gtk_label_set_xalign(GTK_LABEL(sublabel), 0.0);
                gtk_box_append(GTK_BOX(text_vbox), sublabel);

            } else {
                // If not connected, just add the name label directly
                GtkWidget *label = gtk_label_new(dev_copy->name);
                gtk_label_set_xalign(GTK_LABEL(label), 0.0);
                gtk_widget_set_hexpand(label, TRUE);
                gtk_widget_set_valign(label, GTK_ALIGN_CENTER); // Center it vertically
                gtk_box_append(GTK_BOX(row_hbox), label);
            }

            update_bt_widget_state(row_hbox, dev_copy);

            GtkGesture *right_click = gtk_gesture_click_new();
            gtk_gesture_single_set_button(GTK_GESTURE_SINGLE(right_click), GDK_BUTTON_SECONDARY);
            g_signal_connect(right_click, "pressed", G_CALLBACK(on_bluetooth_right_click), dev_copy);
            gtk_widget_add_controller(row_hbox, GTK_EVENT_CONTROLLER(right_click));

            if (dev->is_connected) {
                gtk_box_append(GTK_BOX(connected_list), row_hbox);
                has_connected = TRUE;
            } else {
                gtk_box_append(GTK_BOX(available_list), row_hbox);
                has_available = TRUE;
            }
        }
    }

    gtk_widget_set_visible(widgets->bt_connected_header, has_connected);
    gtk_widget_set_visible(widgets->bt_available_header, has_available || g_list_length(devices) == 0);

    free_bluetooth_device_list(devices);
}

// --- Page & Section Builders ---
static GtkWidget* create_wifi_page(AppWidgets *widgets) {
    // The main container for the page is a vertical box
    GtkWidget *page_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_widget_set_margin_top(GTK_WIDGET(page_vbox), 8);

    // --- SECTION 1: Connected Network ---
    // Note: Wi-Fi usually only has one connected network, so the header is singular.
    widgets->wifi_connected_header = gtk_label_new("Connected network");
    gtk_widget_add_css_class(widgets->wifi_connected_header, "bt-header"); // Reuse bt-header style
    gtk_label_set_xalign(GTK_LABEL(widgets->wifi_connected_header), 0.0);
    gtk_widget_set_visible(widgets->wifi_connected_header, FALSE); // Hide initially
    gtk_box_append(GTK_BOX(page_vbox), widgets->wifi_connected_header);

    widgets->wifi_connected_list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_box_append(GTK_BOX(page_vbox), widgets->wifi_connected_list_box);

    // --- SECTION 2: Available Networks ---
    widgets->wifi_available_header = gtk_label_new("Available networks");
    gtk_widget_add_css_class(widgets->wifi_available_header, "bt-header"); // Reuse bt-header style
    gtk_label_set_xalign(GTK_LABEL(widgets->wifi_available_header), 0.0);
    gtk_widget_set_visible(widgets->wifi_available_header, FALSE); // Hide initially
    gtk_box_append(GTK_BOX(page_vbox), widgets->wifi_available_header);
    
    widgets->wifi_available_list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_box_append(GTK_BOX(page_vbox), widgets->wifi_available_list_box);

    // Create one scrolled window to contain the whole page
    GtkWidget *scrolled_window = gtk_scrolled_window_new();
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_window), page_vbox);
    gtk_widget_set_size_request(scrolled_window, -1, LIST_REQUESTED_HEIGHT);
    gtk_widget_set_vexpand(scrolled_window, FALSE);
    gtk_widget_set_valign(scrolled_window, GTK_ALIGN_START);

    // We can reuse the overlay logic for a central spinner if needed for connect/disconnect ops
    GtkWidget *overlay = gtk_overlay_new();
    gtk_overlay_set_child(GTK_OVERLAY(overlay), scrolled_window);
    
    return overlay;
}

static GtkWidget* create_bluetooth_page(AppWidgets *widgets) {
    // The main container for the page is a vertical box
    GtkWidget *page_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_widget_set_margin_top(GTK_WIDGET(page_vbox), 8);

    // --- SECTION 1: Connected Devices ---
    widgets->bt_connected_header = gtk_label_new("Connected devices");
    gtk_widget_add_css_class(widgets->bt_connected_header, "bt-header");
    gtk_label_set_xalign(GTK_LABEL(widgets->bt_connected_header), 0.0);
    gtk_widget_set_visible(widgets->bt_connected_header, FALSE); // Hide initially
    gtk_box_append(GTK_BOX(page_vbox), widgets->bt_connected_header);

    widgets->bt_connected_list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_box_append(GTK_BOX(page_vbox), widgets->bt_connected_list_box);

    // --- SECTION 2: Available Devices ---
    GtkWidget *available_header_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
    widgets->bt_available_header = available_header_box;
    gtk_widget_add_css_class(widgets->bt_available_header, "bt-header");
    gtk_widget_set_visible(widgets->bt_available_header, FALSE); // Hide initially
    
    GtkWidget* available_label = gtk_label_new("Available devices");
    gtk_widget_set_hexpand(available_label, TRUE);
    gtk_label_set_xalign(GTK_LABEL(available_label), 0.0);
    
    widgets->bt_header_spinner = gtk_spinner_new();

    gtk_box_append(GTK_BOX(available_header_box), available_label);
    gtk_box_append(GTK_BOX(available_header_box), widgets->bt_header_spinner);
    gtk_box_append(GTK_BOX(page_vbox), widgets->bt_available_header);
    
    widgets->bt_available_list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_box_append(GTK_BOX(page_vbox), widgets->bt_available_list_box);

    // Create one scrolled window to contain the whole page
    GtkWidget *scrolled_window = gtk_scrolled_window_new();
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_window), page_vbox);
    gtk_widget_set_size_request(scrolled_window, -1, LIST_REQUESTED_HEIGHT);
    gtk_widget_set_vexpand(scrolled_window, FALSE);
    gtk_widget_set_valign(scrolled_window, GTK_ALIGN_START);

    // The overlay now goes around this single scrolled window
    GtkWidget *overlay = gtk_overlay_new();
    gtk_overlay_set_child(GTK_OVERLAY(overlay), scrolled_window);
    
    // We still keep the main spinner for initial loading or major operations
    widgets->bt_list_spinner = gtk_spinner_new();
    gtk_widget_set_halign(widgets->bt_list_spinner, GTK_ALIGN_CENTER);
    gtk_widget_set_valign(widgets->bt_list_spinner, GTK_ALIGN_CENTER);
    gtk_overlay_add_overlay(GTK_OVERLAY(overlay), widgets->bt_list_spinner);
    widgets->bt_list_overlay = overlay;

    return overlay;
}

static GtkWidget* create_audio_page(AppWidgets *widgets) {
    GtkWidget *list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_widget_set_margin_top(list_box, 8);
    widgets->audio_list_box = list_box;

    GtkWidget *scrolled_window = gtk_scrolled_window_new();
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_window), list_box);
    gtk_widget_set_size_request(scrolled_window, -1, LIST_REQUESTED_HEIGHT);
    gtk_widget_set_vexpand(scrolled_window, FALSE);
    gtk_widget_set_valign(scrolled_window, GTK_ALIGN_START);
    return scrolled_window;
}



static gboolean reveal_on_idle(gpointer user_data) {
    gtk_revealer_set_reveal_child(GTK_REVEALER(user_data), TRUE);
    return G_SOURCE_REMOVE;
}

static void on_expandable_toggle_toggled(GtkToggleButton *toggled_button, AppWidgets *widgets) {
    if (!widgets) return;

    if (!gtk_toggle_button_get_active(toggled_button)) {
        gboolean any_active = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widgets->wifi_toggle)) ||
                              gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widgets->bt_toggle)) ||
                              gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widgets->audio_toggle));
        if (!any_active) {
            gtk_revealer_set_reveal_child(widgets->stack_revealer, FALSE);
            wifi_scanner_stop(widgets->wifi_scanner);
            bluetooth_scanner_stop(widgets->bt_scanner);
        }
        return;
    }

    const char *target_page = NULL;
    GtkWidget *other_toggle1 = NULL, *other_toggle2 = NULL;
    gulong handler_id1 = 0, handler_id2 = 0;

    wifi_scanner_stop(widgets->wifi_scanner);
    bluetooth_scanner_stop(widgets->bt_scanner);

    if (toggled_button == GTK_TOGGLE_BUTTON(widgets->wifi_toggle)) {
        target_page = "wifi_page";
        other_toggle1 = widgets->bt_toggle;     handler_id1 = widgets->bt_toggle_handler_id;
        other_toggle2 = widgets->audio_toggle;  handler_id2 = widgets->audio_toggle_handler_id;
        wifi_scanner_start(widgets->wifi_scanner, WIFI_SCAN_INTERVAL_SECONDS);
    }   else if (toggled_button == GTK_TOGGLE_BUTTON(widgets->bt_toggle)) {
        target_page = "bt_page";
        other_toggle1 = widgets->wifi_toggle;   handler_id1 = widgets->wifi_toggle_handler_id;
        other_toggle2 = widgets->audio_toggle;  handler_id2 = widgets->audio_toggle_handler_id;

        // --- START OF CORRECTION ---
        // Make the "Available devices" header visible and start its spinner
        // to show that a scan is in progress.
        gtk_widget_set_visible(widgets->bt_available_header, TRUE);
        gtk_spinner_start(GTK_SPINNER(widgets->bt_header_spinner));
        // --- END OF CORRECTION ---
        
        bluetooth_scanner_start(widgets->bt_scanner);
    }  else if (toggled_button == GTK_TOGGLE_BUTTON(widgets->audio_toggle)) {
        target_page = "audio_page";
        other_toggle1 = widgets->wifi_toggle;   handler_id1 = widgets->wifi_toggle_handler_id;
        other_toggle2 = widgets->bt_toggle;     handler_id2 = widgets->bt_toggle_handler_id;
        update_audio_device_list(widgets);
    }

    g_signal_handler_block(other_toggle1, handler_id1);
    g_signal_handler_block(other_toggle2, handler_id2);
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(other_toggle1), FALSE);
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(other_toggle2), FALSE);
    g_signal_handler_unblock(other_toggle1, handler_id1);
    g_signal_handler_unblock(other_toggle2, handler_id2);

    if (target_page) {
        gtk_stack_set_visible_child_name(widgets->main_stack, target_page);
        g_idle_add(reveal_on_idle, widgets->stack_revealer);
    }
}

static GtkWidget* create_square_toggle(const char* icon_name, const char* text) {
    GtkWidget *button = gtk_toggle_button_new();
    gtk_widget_add_css_class(button, "square-toggle");

    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 4);
    gtk_widget_set_halign(box, GTK_ALIGN_CENTER);
    gtk_widget_set_valign(box, GTK_ALIGN_CENTER);
    gtk_button_set_child(GTK_BUTTON(button), box);

    GtkWidget *icon = gtk_image_new_from_icon_name(icon_name);
    GtkWidget *label = gtk_label_new(text);
    gtk_box_append(GTK_BOX(box), icon);
    gtk_box_append(GTK_BOX(box), label);
    return button;
}

static GtkWidget* create_pill_slider(const char* icon_name) {
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 12);
    gtk_widget_add_css_class(box, "pill-slider");

    GtkWidget *icon = gtk_image_new_from_icon_name(icon_name);
    GtkWidget *slider = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL, 0, 100, 1);
    gtk_scale_set_draw_value(GTK_SCALE(slider), FALSE);
    gtk_widget_set_hexpand(slider, TRUE);

    gtk_box_append(GTK_BOX(box), icon);
    gtk_box_append(GTK_BOX(box), slider);
    return box;
}

static gboolean initial_state_update(gpointer user_data) {
    AppWidgets *widgets = user_data;
    if(!widgets) {
        return G_SOURCE_REMOVE;
    }
    on_system_event(SYSTEM_EVENT_VOLUME_CHANGED, widgets);
    on_system_event(SYSTEM_EVENT_BRIGHTNESS_CHANGED, widgets);
    return G_SOURCE_REMOVE;
}

// --- Main Plugin Entry Point ---
// --- Main Plugin Entry Point ---
G_MODULE_EXPORT GtkWidget* create_widget(const char *config_string) {
    (void)config_string;
    
    // 1. Create the state struct FIRST, so we can pass its pointer around.
    AppWidgets *widgets = g_new0(AppWidgets, 1);

    // --- MODIFICATION IS HERE ---
    // 2. Initialize the network manager and the new bluetooth manager.
    if (!network_manager_init()) {
        g_critical("Control Center Plugin: Failed to initialize NetworkManager.");
        g_free(widgets);
        return NULL;
    }
    
    // Initialize the event-driven Bluetooth manager, passing our UI update callback.
    if (!bluetooth_manager_init(on_bt_devices_updated, widgets)) {
        g_critical("Control Center Plugin: Failed to initialize BluetoothManager.");
        network_manager_shutdown(); // Clean up the already-initialized manager
        g_free(widgets);
        return NULL;
    }
    // --- END MODIFICATION ---

    // 3. Get a connection to the system D-Bus and subscribe to the RELIABLE signal.
   // widgets->dbus_connection = g_bus_get_sync(G_BUS_TYPE_SYSTEM, NULL, NULL);
    //if (widgets->dbus_connection) {
    //    subscribe_to_wifi_device_signals(widgets);
   // }

    // --- The rest of the function builds the UI as before ---
    
    GtkWidget *root_widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);
    gtk_widget_set_name(root_widget, "aurora-control-center");
    gtk_widget_add_css_class(root_widget, "control-center-widget");
    g_object_set_data_full(G_OBJECT(root_widget), "app-widgets", widgets, (GDestroyNotify)control_center_cleanup);

    // Top Grid (Wi-Fi, BT, etc.)
    GtkWidget *top_toggle_grid = gtk_grid_new();
    gtk_grid_set_column_spacing(GTK_GRID(top_toggle_grid), 8);
    gtk_grid_set_row_spacing(GTK_GRID(top_toggle_grid), 8);
    gtk_box_append(GTK_BOX(root_widget), top_toggle_grid);

    widgets->wifi_toggle = create_square_toggle("network-wireless-symbolic", "Wi-Fi");
    widgets->bt_toggle = create_square_toggle("bluetooth-active-symbolic", "Bluetooth");
    widgets->audio_toggle = create_square_toggle("audio-card-symbolic", "Audio");
    GtkWidget *airplane_toggle = create_square_toggle("airplane-mode-symbolic", "Airplane");
    gtk_grid_attach(GTK_GRID(top_toggle_grid), widgets->wifi_toggle, 0, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(top_toggle_grid), widgets->bt_toggle, 1, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(top_toggle_grid), widgets->audio_toggle, 2, 0, 1, 1);
    gtk_grid_attach(GTK_GRID(top_toggle_grid), airplane_toggle, 3, 0, 1, 1);
    
    // Expandable content area (Revealer + Stack)
    widgets->stack_revealer = GTK_REVEALER(gtk_revealer_new());
    gtk_revealer_set_transition_type(widgets->stack_revealer, GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN);
    gtk_revealer_set_transition_duration(widgets->stack_revealer, 250);
    widgets->main_stack = GTK_STACK(gtk_stack_new());
    gtk_widget_add_css_class(GTK_WIDGET(widgets->main_stack), "expandable-content-area");
    gtk_revealer_set_child(widgets->stack_revealer, GTK_WIDGET(widgets->main_stack));
    gtk_stack_add_named(widgets->main_stack, create_wifi_page(widgets), "wifi_page");
    gtk_stack_add_named(widgets->main_stack, create_bluetooth_page(widgets), "bt_page");
    gtk_stack_add_named(widgets->main_stack, create_audio_page(widgets), "audio_page");
    gtk_box_append(GTK_BOX(root_widget), GTK_WIDGET(widgets->stack_revealer));

    // Sliders Box
    GtkWidget *sliders_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_add_css_class(sliders_box, "sliders-box");
    
    GtkWidget* volume_label = gtk_label_new("System Volume");
    gtk_widget_add_css_class(volume_label, "slider-label");
    gtk_box_append(GTK_BOX(sliders_box), volume_label);
    
    GtkWidget *system_slider_box = create_pill_slider("audio-volume-high-symbolic");
    widgets->system_volume_slider = gtk_widget_get_last_child(system_slider_box);
    gtk_box_append(GTK_BOX(sliders_box), system_slider_box);

    GtkWidget* brightness_label = gtk_label_new("Brightness");
    gtk_widget_add_css_class(brightness_label, "slider-label");
    gtk_box_append(GTK_BOX(sliders_box), brightness_label);

    GtkWidget *brightness_slider_box = create_pill_slider("display-brightness-symbolic");
    widgets->brightness_slider = gtk_widget_get_last_child(brightness_slider_box);
    gtk_box_append(GTK_BOX(sliders_box), brightness_slider_box);
    gtk_box_append(GTK_BOX(root_widget), sliders_box);
    
    // Initialization & Signal Connections
    widgets->wifi_scanner = wifi_scanner_new(on_wifi_scan_results, widgets);
    widgets->bt_scanner = bluetooth_scanner_new(on_bt_scan_results, widgets);
    widgets->system_monitor = system_monitor_new(on_system_event, widgets);

    widgets->wifi_toggle_handler_id = g_signal_connect(widgets->wifi_toggle, "toggled", G_CALLBACK(on_expandable_toggle_toggled), widgets);
    widgets->bt_toggle_handler_id = g_signal_connect(widgets->bt_toggle, "toggled", G_CALLBACK(on_expandable_toggle_toggled), widgets);
    widgets->audio_toggle_handler_id = g_signal_connect(widgets->audio_toggle, "toggled", G_CALLBACK(on_expandable_toggle_toggled), widgets);
    g_signal_connect(airplane_toggle, "toggled", G_CALLBACK(toggle_airplane_mode), widgets);
    widgets->system_volume_handler_id = g_signal_connect(widgets->system_volume_slider, "value-changed", G_CALLBACK(on_system_volume_changed), NULL);
    widgets->brightness_slider_handler_id = g_signal_connect(widgets->brightness_slider, "value-changed", G_CALLBACK(on_brightness_changed), NULL);
    
    g_idle_add(initial_state_update, widgets);

    return root_widget;
}
======================================================================
### FILE: ././widgets/control-center/src/network_manager.c
======================================================================
#include "network_manager.h"
#include <gio/gio.h>
#include <string.h>

// D-Bus constants for NetworkManager
#define NM_DBUS_SERVICE "org.freedesktop.NetworkManager"
#define NM_DBUS_PATH "/org/freedesktop/NetworkManager"
#define NM_DBUS_INTERFACE "org.freedesktop.NetworkManager"
#define NM_DEVICE_INTERFACE "org.freedesktop.NetworkManager.Device"
#define NM_WIRELESS_DEVICE_INTERFACE "org.freedesktop.NetworkManager.Device.Wireless"
#define NM_AP_INTERFACE "org.freedesktop.NetworkManager.AccessPoint"
#define NM_SETTINGS_PATH "/org/freedesktop/NetworkManager/Settings"
#define NM_SETTINGS_INTERFACE "org.freedesktop.NetworkManager.Settings"
#define NM_SETTINGS_CONNECTION_INTERFACE "org.freedesktop.NetworkManager.Settings.Connection"
#define NM_DEVICE_TYPE_WIFI 2
#define NM_STATE_ASLEEP 10

// --- NEW D-BUS CONSTANTS ---
#define NM_CONNECTIVITY_UNKNOWN 0
#define NM_CONNECTIVITY_NONE    1
#define NM_CONNECTIVITY_PORTAL  2
#define NM_CONNECTIVITY_LIMITED 3
#define NM_CONNECTIVITY_FULL    4

// --- Context and Data Structures ---
typedef struct {
    GDBusProxy *nm_proxy;
    GDBusProxy *settings_proxy;
} NetworkManagerContext;
static NetworkManagerContext *g_context = NULL;

typedef struct { NetworkOperationCallback user_callback; gpointer user_data; } OperationFinishData;
typedef struct { gchar *ssid; gchar *ap_path; gchar *password; gboolean is_secure; } AddConnectionTaskData;
typedef struct { gchar *connection_path; gchar *ap_path; } ActivateConnectionTaskData;
typedef struct { gchar *ssid; } ForgetTaskData;
typedef struct { gboolean enabled; } SetEnabledTaskData;

// --- Forward Declarations for GTask functions ---
static void on_operation_finished(GObject *s, GAsyncResult *res, gpointer user_data);
static void forget_task_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c);
static void disconnect_task_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c);
static void add_and_activate_connection_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c);
static void activate_connection_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c);
static void set_enabled_task_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c);

// --- Memory management for task data ---
static void add_connection_task_data_free(gpointer data) { AddConnectionTaskData *d = data; if (!d) return; g_free(d->ssid); g_free(d->ap_path); g_free(d->password); g_free(d); }
static void activate_connection_task_data_free(gpointer data) { ActivateConnectionTaskData *d = data; if (!d) return; g_free(d->connection_path); g_free(d->ap_path); g_free(d); }
static void forget_task_data_free(gpointer data) { ForgetTaskData *d = data; if (!d) return; g_free(d->ssid); g_free(d); }

// --- Helper Functions ---
static gchar* find_wifi_device_path() {
    g_return_val_if_fail(g_context && g_context->nm_proxy, NULL);
    g_autoptr(GVariant) devices_variant = g_dbus_proxy_get_cached_property(g_context->nm_proxy, "AllDevices");
    if (!devices_variant) { g_warning("Could not get AllDevices property"); return NULL; }
    const gchar **device_paths = g_variant_get_objv(devices_variant, NULL);
    gchar *wifi_device_path = NULL;
    for (int i = 0; device_paths && device_paths[i] != NULL; ++i) {
        g_autoptr(GDBusProxy) device_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, device_paths[i], NM_DEVICE_INTERFACE, NULL, NULL);
        if (device_proxy) {
            g_autoptr(GVariant) type_v = g_dbus_proxy_get_cached_property(device_proxy, "DeviceType");
            if (type_v && g_variant_get_uint32(type_v) == NM_DEVICE_TYPE_WIFI) {
                wifi_device_path = g_strdup(device_paths[i]);
                break;
            }
        }
    }
    return wifi_device_path;
}

// --- Detailed Network Info Functions ---
void free_wifi_network_details(WifiNetworkDetails *details) { if (!details) return; g_free(details->ssid); g_free(details->security); g_free(details->ip_address); g_free(details->mac_address); g_free(details); }
typedef struct { gchar *ap_path; } GetDetailsTaskData;
typedef struct { WifiDetailsCallback user_callback; gpointer user_data; } GetDetailsFinishData;

static void get_details_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) {
    (void)s; (void)d; (void)c;
    GetDetailsTaskData *data = g_task_get_task_data(task);
    g_autoptr(GError) error = NULL;
    g_autoptr(GDBusProxy) ap_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, data->ap_path, NM_AP_INTERFACE, NULL, &error);
    if (error) { g_warning("Failed to create AP proxy for details: %s", error->message); g_task_return_pointer(task, NULL, NULL); return; }
    WifiNetworkDetails *details = g_new0(WifiNetworkDetails, 1);
    g_autoptr(GVariant) ssid_v = g_dbus_proxy_get_cached_property(ap_proxy, "Ssid");
    if (ssid_v) { gsize len; const guint8 *ssid_bytes = g_variant_get_fixed_array(ssid_v, &len, sizeof(guint8)); details->ssid = g_strndup((const gchar*)ssid_bytes, len); }
    g_autoptr(GVariant) strength_v = g_dbus_proxy_get_cached_property(ap_proxy, "Strength");
    if (strength_v) details->strength = g_variant_get_byte(strength_v);
    g_autoptr(GVariant) mac_v = g_dbus_proxy_get_cached_property(ap_proxy, "HwAddress");
    if (mac_v) details->mac_address = g_variant_dup_string(mac_v, NULL);
    g_autoptr(GVariant) rsnflags_v = g_dbus_proxy_get_cached_property(ap_proxy, "RsnFlags");
    if (rsnflags_v && g_variant_get_uint32(rsnflags_v) != 0) { details->security = g_strdup("WPA2/WPA3"); }
    else { g_autoptr(GVariant) wpaflags_v = g_dbus_proxy_get_cached_property(ap_proxy, "WpaFlags"); if (wpaflags_v && g_variant_get_uint32(wpaflags_v) != 0) { details->security = g_strdup("WPA"); } else { details->security = g_strdup("Open"); } }
    g_autofree gchar *wifi_dev_path = find_wifi_device_path();
    if (wifi_dev_path) {
        g_autoptr(GDBusProxy) wireless_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, wifi_dev_path, NM_WIRELESS_DEVICE_INTERFACE, NULL, NULL);
        if (wireless_proxy) {
            g_autoptr(GVariant) active_ap_v = g_dbus_proxy_get_cached_property(wireless_proxy, "ActiveAccessPoint");
            const gchar *active_ap_path = active_ap_v ? g_variant_get_string(active_ap_v, NULL) : NULL;
            if (active_ap_path && g_strcmp0(active_ap_path, data->ap_path) == 0) {
                g_autoptr(GVariant) active_conn_v = g_dbus_proxy_get_cached_property(g_context->nm_proxy, "PrimaryConnection");
                const gchar* active_conn_path = active_conn_v ? g_variant_get_string(active_conn_v, NULL) : NULL;
                if(active_conn_path) {
                    g_autoptr(GDBusProxy) conn_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, active_conn_path, "org.freedesktop.NetworkManager.Connection.Active", NULL, NULL);
                    g_autoptr(GVariant) ip4_config_v = g_dbus_proxy_get_cached_property(conn_proxy, "Ip4Config");
                    const gchar* ip4_config_path = ip4_config_v ? g_variant_get_string(ip4_config_v, NULL) : NULL;
                    if(ip4_config_path && g_strcmp0(ip4_config_path, "/") != 0) {
                        g_autoptr(GDBusProxy) ip4_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, ip4_config_path, "org.freedesktop.NetworkManager.IP4Config", NULL, NULL);
                        g_autoptr(GVariant) addr_data_v = g_dbus_proxy_get_cached_property(ip4_proxy, "AddressData");
                        if (addr_data_v) {
                            GVariantIter iter; GVariant *addr_dict_variant; g_variant_iter_init(&iter, addr_data_v);
                            if (g_variant_iter_next(&iter, "a{sv}", &addr_dict_variant)) {
                                GVariantIter dict_iter; gchar *key; GVariant *value; g_variant_iter_init(&dict_iter, addr_dict_variant);
                                while (g_variant_iter_next(&dict_iter, "{sv}", &key, &value)) {
                                    if (g_strcmp0(key, "address") == 0) details->ip_address = g_variant_dup_string(value, NULL);
                                    g_free(key); g_variant_unref(value);
                                    if(details->ip_address) break;
                                }
                                g_variant_unref(addr_dict_variant);
                            }
                        }
                    }
                }
            }
        }
    }
    g_task_return_pointer(task, details, (GDestroyNotify)free_wifi_network_details);
}

static void on_get_details_finished(GObject *s, GAsyncResult *res, gpointer user_data) { (void)s; GetDetailsFinishData *finish_data = user_data; g_autoptr(GError) error = NULL; WifiNetworkDetails *details = g_task_propagate_pointer(G_TASK(res), &error); if (error) { g_warning("Failed to get network details: %s", error->message); g_clear_pointer(&details, free_wifi_network_details); } if (finish_data->user_callback) { finish_data->user_callback(details, finish_data->user_data); } else { if (details) free_wifi_network_details(details); } g_free(finish_data); }
void get_wifi_network_details_async(const gchar *ap_path, WifiDetailsCallback cb, gpointer ud) { GetDetailsTaskData *td = g_new0(GetDetailsTaskData, 1); td->ap_path = g_strdup(ap_path); GetDetailsFinishData *fd = g_new0(GetDetailsFinishData, 1); fd->user_callback = cb; fd->user_data = ud; GTask *task = g_task_new(NULL, NULL, on_get_details_finished, fd); g_task_set_task_data(task, td, (GDestroyNotify)g_free); g_task_run_in_thread(task, get_details_thread_func); g_object_unref(task); }
gboolean is_connection_forgettable(const gchar *connection_path, gboolean is_network_secure) { g_return_val_if_fail(connection_path != NULL, FALSE); if (!is_network_secure) return TRUE; g_autoptr(GDBusProxy) conn_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, connection_path, NM_SETTINGS_CONNECTION_INTERFACE, NULL, NULL); if (!conn_proxy) return FALSE; g_autoptr(GVariant) settings_variant = g_dbus_proxy_call_sync(conn_proxy, "GetSettings", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL); if (!settings_variant) return FALSE; g_autoptr(GVariant) settings_dict = g_variant_get_child_value(settings_variant, 0); g_autoptr(GVariant) security_settings = g_variant_lookup_value(settings_dict, "802-11-wireless-security", G_VARIANT_TYPE("a{sv}")); if (security_settings == NULL) return FALSE; return (g_variant_lookup_value(security_settings, "psk", G_VARIANT_TYPE_STRING) != NULL); }

// --- Init and Shutdown ---
gboolean network_manager_init() { g_return_val_if_fail(g_context == NULL, TRUE); g_autoptr(GError) error = NULL; g_context = g_new0(NetworkManagerContext, 1); g_autoptr(GDBusConnection) connection = g_bus_get_sync(G_BUS_TYPE_SYSTEM, NULL, &error); if (error) { g_warning("Failed to get D-Bus system bus connection: %s", error->message); network_manager_shutdown(); return FALSE; } g_context->nm_proxy = g_dbus_proxy_new_sync( connection, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, NM_DBUS_PATH, NM_DBUS_INTERFACE, NULL, &error ); if (error || g_context->nm_proxy == NULL) { g_warning("Failed to create NM proxy: %s", error ? error->message : "Proxy creation returned NULL"); g_clear_error(&error); network_manager_shutdown(); return FALSE; } g_context->settings_proxy = g_dbus_proxy_new_sync( connection, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, NM_SETTINGS_PATH, NM_SETTINGS_INTERFACE, NULL, &error ); if (error || g_context->settings_proxy == NULL) { g_warning("Failed to create NM Settings proxy: %s", error ? error->message : "Proxy creation returned NULL"); network_manager_shutdown(); return FALSE; } g_print("NetworkManager D-Bus interface initialized successfully.\n"); return TRUE; }
void network_manager_shutdown() { if (!g_context) return; g_clear_object(&g_context->nm_proxy); g_clear_object(&g_context->settings_proxy); g_free(g_context); g_context = NULL; g_print("NetworkManager D-Bus interface shut down.\n"); }
static void on_operation_finished(GObject *s, GAsyncResult *res, gpointer user_data) { (void)s; OperationFinishData *finish_data = user_data; gboolean success = g_task_propagate_boolean(G_TASK(res), NULL); if (finish_data && finish_data->user_callback) { finish_data->user_callback(success, finish_data->user_data); } g_free(finish_data); }

// --- Radio Control Implementation ---
gboolean is_wifi_enabled() { g_return_val_if_fail(g_context && g_context->nm_proxy, FALSE); g_autoptr(GVariant) prop = g_dbus_proxy_get_cached_property(g_context->nm_proxy, "WirelessEnabled"); return prop ? g_variant_get_boolean(prop) : FALSE; }
gboolean is_airplane_mode_active() { g_return_val_if_fail(g_context && g_context->nm_proxy, FALSE); g_autoptr(GVariant) prop = g_dbus_proxy_get_cached_property(g_context->nm_proxy, "State"); return prop ? (g_variant_get_uint32(prop) == NM_STATE_ASLEEP) : FALSE; }
void set_wifi_enabled_async(gboolean enabled, NetworkOperationCallback cb, gpointer ud) { SetEnabledTaskData *td = g_new0(SetEnabledTaskData, 1); td->enabled = enabled; OperationFinishData *fd = g_new0(OperationFinishData, 1); fd->user_callback = cb; fd->user_data = ud; GTask *t = g_task_new(NULL, NULL, on_operation_finished, fd); g_task_set_task_data(t, td, g_free); g_task_run_in_thread(t, set_enabled_task_thread_func); g_object_unref(t); }
static void set_enabled_task_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) { (void)s; (void)d; (void)c; SetEnabledTaskData *data = g_task_get_task_data(task); g_autoptr(GError) error = NULL; g_dbus_proxy_call_sync(g_context->nm_proxy, "org.freedesktop.DBus.Properties.Set", g_variant_new("(ssv)", NM_DBUS_INTERFACE, "WirelessEnabled", g_variant_new_boolean(data->enabled)), G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error); g_task_return_boolean(task, error == NULL); }

// --- Network List & Profile Functions ---
static gint sort_networks(gconstpointer a, gconstpointer b) { const WifiNetwork *na = a; const WifiNetwork *nb = b; if (na->is_active && !nb->is_active) return -1; if (!na->is_active && nb->is_active) return 1; if (na->strength > nb->strength) return -1; if (na->strength < nb->strength) return 1; return g_strcmp0(na->ssid, nb->ssid); }

GList* get_available_wifi_networks() {
    g_print("\n--- [WIFI DEBUG] Starting get_available_wifi_networks ---\n");
    g_autofree gchar *wifi_device_path = find_wifi_device_path();
    if (!wifi_device_path) {
        g_warning("[WIFI WARNING] No Wi-Fi device path found. Aborting scan.");
        return NULL;
    }

    g_autoptr(GError) error = NULL;
    g_autoptr(GDBusProxy) wireless_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, wifi_device_path, NM_WIRELESS_DEVICE_INTERFACE, NULL, &error);
    if (error) { g_warning("[WIFI WARNING] Failed to create wireless device proxy: %s", error->message); return NULL; }

    g_autoptr(GVariant) aps_variant = g_dbus_proxy_call_sync(wireless_proxy, "GetAllAccessPoints", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
    if (!aps_variant) { g_warning("[WIFI WARNING] GetAllAccessPoints call returned NULL."); return NULL; }
    
    g_autoptr(GVariant) active_ap_variant = g_dbus_proxy_get_cached_property(wireless_proxy, "ActiveAccessPoint");
    const gchar *active_ap_path = active_ap_variant ? g_variant_get_string(active_ap_variant, NULL) : NULL;

    guint32 global_connectivity = NM_CONNECTIVITY_UNKNOWN;
    g_autoptr(GVariant) connectivity_variant = g_dbus_proxy_get_cached_property(g_context->nm_proxy, "Connectivity");
    if (connectivity_variant) { global_connectivity = g_variant_get_uint32(connectivity_variant); }
    
    // --- DEBUG: Get and print all saved connections ---
    GHashTable *saved_ssids = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
    g_autoptr(GVariant) connections_variant = g_dbus_proxy_call_sync(g_context->settings_proxy, "ListConnections", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
    if (connections_variant) {
        g_print("[WIFI DEBUG] Found saved system connections. Parsing SSIDs:\n");
        g_autoptr(GVariantIter) iter;
        g_variant_get(connections_variant, "(ao)", &iter);
        const gchar *conn_path;
        while (g_variant_iter_loop(iter, "o", &conn_path)) {
            g_autoptr(GDBusProxy) conn_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, conn_path, NM_SETTINGS_CONNECTION_INTERFACE, NULL, NULL);
            if (!conn_proxy) continue;
            g_autoptr(GVariant) settings_variant = g_dbus_proxy_call_sync(conn_proxy, "GetSettings", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
            if (!settings_variant) continue;
            g_autoptr(GVariant) settings_dict = g_variant_get_child_value(settings_variant, 0);
            g_autoptr(GVariant) wifi_settings = g_variant_lookup_value(settings_dict, "802-11-wireless", G_VARIANT_TYPE("a{sv}"));
            if (!wifi_settings) continue;
            g_autoptr(GVariant) ssid_variant = g_variant_lookup_value(wifi_settings, "ssid", G_VARIANT_TYPE("ay"));
            if (ssid_variant) {
                gsize len;
                const gchar *ssid_bytes = g_variant_get_fixed_array(ssid_variant, &len, sizeof(guint8));
                g_autofree gchar *ssid_str = g_strndup(ssid_bytes, len);
                g_print("    -> Found saved SSID: '%s'\n", ssid_str);
                // Use g_hash_table_replace to handle potential duplicates
                g_hash_table_replace(saved_ssids, g_strdup(ssid_str), GINT_TO_POINTER(1));
            }
        }
    } else {
        g_warning("[WIFI WARNING] ListConnections call failed. Cannot determine saved networks.");
    }

    g_print("[WIFI DEBUG] Iterating through visible Access Points:\n");
    GList *networks = NULL;
    g_autoptr(GVariantIter) ap_iter;
    g_variant_get(aps_variant, "(ao)", &ap_iter);
    const gchar *ap_path;

    while (g_variant_iter_loop(ap_iter, "o", &ap_path)) {
        g_autoptr(GDBusProxy) ap_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, ap_path, NM_AP_INTERFACE, NULL, NULL);
        if (!ap_proxy) continue;

        g_autoptr(GVariant) ssid_v = g_dbus_proxy_get_cached_property(ap_proxy, "Ssid");
        if (!ssid_v) continue;

        gsize n_elements;
        const guint8 *ssid_bytes = g_variant_get_fixed_array(ssid_v, &n_elements, sizeof(guint8));
        g_autofree gchar *ssid_str = g_strndup((const gchar*)ssid_bytes, n_elements);
        if(strlen(ssid_str) == 0) { continue; }
        
        WifiNetwork *net = g_new0(WifiNetwork, 1);
        net->ssid = g_strdup(ssid_str);
        net->object_path = g_strdup(ap_path);
        g_autoptr(GVariant) strength_v = g_dbus_proxy_get_cached_property(ap_proxy, "Strength");
        net->strength = strength_v ? g_variant_get_byte(strength_v) : 0;
        
        net->is_active = (active_ap_path && g_strcmp0(ap_path, active_ap_path) == 0);
        
        g_autoptr(GVariant) flags_v = g_dbus_proxy_get_cached_property(ap_proxy, "Flags");
        g_autoptr(GVariant) wpaflags_v = g_dbus_proxy_get_cached_property(ap_proxy, "WpaFlags");
        g_autoptr(GVariant) rsnflags_v = g_dbus_proxy_get_cached_property(ap_proxy, "RsnFlags");
        guint32 flags = flags_v ? g_variant_get_uint32(flags_v) : 0;
        guint32 wpa_flags = wpaflags_v ? g_variant_get_uint32(wpaflags_v) : 0;
        guint32 rsn_flags = rsnflags_v ? g_variant_get_uint32(rsnflags_v) : 0;
        net->is_secure = (flags != 0 || wpa_flags != 0 || rsn_flags != 0);

        // --- THE DEBUGGED CHECK ---
        net->is_known = g_hash_table_contains(saved_ssids, net->ssid);
        g_print("    -> Checking AP: '%s'. Is it saved? %s\n", net->ssid, net->is_known ? "YES" : "NO");

        if (net->is_active) {
            switch (global_connectivity) {
                case NM_CONNECTIVITY_FULL:    net->connectivity = WIFI_STATE_CONNECTED; break;
                case NM_CONNECTIVITY_LIMITED:
                case NM_CONNECTIVITY_PORTAL:  net->connectivity = WIFI_STATE_LIMITED; break;
                default:                      net->connectivity = WIFI_STATE_CONNECTING; break;
            }
        } else {
            net->connectivity = WIFI_STATE_DISCONNECTED;
        }

        networks = g_list_prepend(networks, net);
    }
    
    g_hash_table_destroy(saved_ssids);
    g_print("--- [WIFI DEBUG] Finished get_available_wifi_networks ---\n");
    return g_list_sort(networks, sort_networks);
}


gchar* find_connection_for_ssid(const gchar *ssid) { g_return_val_if_fail(g_context && g_context->settings_proxy, NULL); g_autoptr(GVariant) connections_variant = g_dbus_proxy_call_sync(g_context->settings_proxy, "ListConnections", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL); if (!connections_variant) return NULL; gchar *found_path = NULL; g_autoptr(GVariantIter) iter; g_variant_get(connections_variant, "(ao)", &iter); const gchar *conn_path; while (g_variant_iter_loop(iter, "o", &conn_path)) { g_autoptr(GDBusProxy) conn_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, conn_path, NM_SETTINGS_CONNECTION_INTERFACE, NULL, NULL); if (!conn_proxy) continue; g_autoptr(GVariant) settings_variant = g_dbus_proxy_call_sync(conn_proxy, "GetSettings", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL); if (!settings_variant) continue; g_autoptr(GVariant) settings_dict = g_variant_get_child_value(settings_variant, 0); g_autoptr(GVariant) wifi_settings = g_variant_lookup_value(settings_dict, "802-11-wireless", G_VARIANT_TYPE("a{sv}")); if (!wifi_settings) continue; g_autoptr(GVariant) ssid_variant = g_variant_lookup_value(wifi_settings, "ssid", G_VARIANT_TYPE("ay")); if (ssid_variant) { gsize len; const gchar *ssid_bytes = g_variant_get_fixed_array(ssid_variant, &len, sizeof(guint8)); if (len == strlen(ssid) && memcmp(ssid_bytes, ssid, len) == 0) { found_path = g_strdup(conn_path); break; } } } return found_path; }
void activate_wifi_connection_async(const gchar *connection_path, const gchar *ap_path, NetworkOperationCallback cb, gpointer ud) { ActivateConnectionTaskData *td = g_new0(ActivateConnectionTaskData, 1); td->connection_path = g_strdup(connection_path); td->ap_path = g_strdup(ap_path); OperationFinishData *fd = g_new0(OperationFinishData, 1); fd->user_callback = cb; fd->user_data = ud; GTask *t = g_task_new(NULL, NULL, on_operation_finished, fd); g_task_set_task_data(t, td, activate_connection_task_data_free); g_task_run_in_thread(t, activate_connection_thread_func); g_object_unref(t); }
static void activate_connection_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) { (void)s; (void)d; (void)c; ActivateConnectionTaskData *data = g_task_get_task_data(task); g_autofree gchar *device_path = find_wifi_device_path(); if (!device_path) { g_warning("No Wi-Fi device for activation."); g_task_return_boolean(task, FALSE); return; } g_autoptr(GError) error = NULL; g_dbus_proxy_call_sync(g_context->nm_proxy, "ActivateConnection", g_variant_new("(ooo)", data->connection_path, device_path, data->ap_path), G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error); if (error) { g_warning("Failed to activate connection %s: %s", data->connection_path, error->message); g_task_return_boolean(task, FALSE); } else { g_task_return_boolean(task, TRUE); } }
void add_and_activate_wifi_connection_async(const gchar *ssid, const gchar *ap_path, const gchar *password, gboolean is_secure, NetworkOperationCallback cb, gpointer ud) { AddConnectionTaskData *td = g_new0(AddConnectionTaskData, 1); td->ssid = g_strdup(ssid); td->ap_path = g_strdup(ap_path); td->password = g_strdup(password); td->is_secure = is_secure; OperationFinishData *fd = g_new0(OperationFinishData, 1); fd->user_callback = cb; fd->user_data = ud; GTask *t = g_task_new(NULL, NULL, on_operation_finished, fd); g_task_set_task_data(t, td, add_connection_task_data_free); g_task_run_in_thread(t, add_and_activate_connection_thread_func); g_object_unref(t); }
static void add_and_activate_connection_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) { (void)s; (void)d; (void)c; AddConnectionTaskData *data = g_task_get_task_data(task); g_autofree gchar *device_path = find_wifi_device_path(); if (!device_path) { g_warning("No Wi-Fi device for new connection."); g_task_return_boolean(task, FALSE); return; } g_autoptr(GError) error = NULL; GPtrArray *entries = g_ptr_array_new_with_free_func((GDestroyNotify) g_variant_unref); GVariantBuilder builder; g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT); g_variant_builder_add(&builder, "{sv}", "type", g_variant_new_string("802-11-wireless")); g_variant_builder_add(&builder, "{sv}", "id", g_variant_new_string(data->ssid)); g_autofree gchar* uuid = g_uuid_string_random(); g_variant_builder_add(&builder, "{sv}", "uuid", g_variant_new_string(uuid)); g_ptr_array_add(entries, g_variant_new_dict_entry(g_variant_new_string("connection"), g_variant_builder_end(&builder))); g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT); g_autoptr(GVariant) ssid_v = g_variant_new_from_data(G_VARIANT_TYPE("ay"), data->ssid, strlen(data->ssid), TRUE, NULL, NULL); g_variant_builder_add(&builder, "{sv}", "ssid", ssid_v); g_variant_builder_add(&builder, "{sv}", "mode", g_variant_new_string("infrastructure")); g_ptr_array_add(entries, g_variant_new_dict_entry(g_variant_new_string("802-11-wireless"), g_variant_builder_end(&builder))); g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT); g_variant_builder_add(&builder, "{sv}", "method", g_variant_new_string("auto")); g_ptr_array_add(entries, g_variant_new_dict_entry(g_variant_new_string("ipv4"), g_variant_builder_end(&builder))); if (data->is_secure) { g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT); g_variant_builder_add(&builder, "{sv}", "key-mgmt", g_variant_new_string("wpa-psk")); if (data->password && data->password[0] != '\0') { g_variant_builder_add(&builder, "{sv}", "psk", g_variant_new_string(data->password)); } g_ptr_array_add(entries, g_variant_new_dict_entry(g_variant_new_string("802-11-wireless-security"), g_variant_builder_end(&builder))); } GVariant *settings = g_variant_new_array(G_VARIANT_TYPE_DICT_ENTRY, (GVariant **)entries->pdata, entries->len); g_ptr_array_free(entries, TRUE); g_dbus_proxy_call_sync(g_context->nm_proxy, "AddAndActivateConnection", g_variant_new("(a{sa{sv}}oo)", settings, device_path, data->ap_path), G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error); if (error) { g_warning("Failed to add connection: %s", error->message); g_task_return_boolean(task, FALSE); } else { g_print("D-Bus call successful.\n"); g_task_return_boolean(task, TRUE); } }
void forget_wifi_connection_async(const gchar *ssid, NetworkOperationCallback cb, gpointer ud) { ForgetTaskData *td = g_new0(ForgetTaskData, 1); td->ssid = g_strdup(ssid); OperationFinishData *fd = g_new0(OperationFinishData, 1); fd->user_callback = cb; fd->user_data = ud; GTask *t = g_task_new(NULL, NULL, on_operation_finished, fd); g_task_set_task_data(t, td, forget_task_data_free); g_task_run_in_thread(t, forget_task_thread_func); g_object_unref(t); }
static void forget_task_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) { 
    (void)s; (void)d; (void)c; 
    ForgetTaskData *data = g_task_get_task_data(task); 
    g_print("[FORGET DEBUG] 2. Background thread started for SSID: '%s'\n", data->ssid);
    gboolean overall_success = TRUE; 
    g_autofree gchar *connection_to_forget = find_connection_for_ssid(data->ssid); 
    
    if (connection_to_forget) { 
        g_print("[FORGET DEBUG] 3. Found profile to delete at D-Bus path: %s\n", connection_to_forget); 
        g_autoptr(GDBusProxy) conn_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, connection_to_forget, NM_SETTINGS_CONNECTION_INTERFACE, NULL, NULL); 
        if (conn_proxy) { 
            g_autoptr(GError) delete_error = NULL; 
            g_dbus_proxy_call_sync(conn_proxy, "Delete", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &delete_error); 
            if(delete_error) { 
                g_warning("[FORGET DEBUG] 4. D-Bus 'Delete' call FAILED: %s", delete_error->message); 
                overall_success = FALSE; 
            } else {
                g_print("[FORGET DEBUG] 4. D-Bus 'Delete' call SUCCEEDED.\n");
            }
        } else { 
            g_warning("[FORGET DEBUG] 4. FAILED to create D-Bus proxy for the connection.\n");
            overall_success = FALSE; 
        } 
    } else {
        g_print("[FORGET DEBUG] 3. No saved profile found for SSID '%s'. Nothing to delete.\n", data->ssid);
        // If there's nothing to forget, we can consider it a "success" in that the desired state is achieved.
        overall_success = TRUE;
    }
    
    g_task_return_boolean(task, overall_success); 
}
void disconnect_wifi_async(NetworkOperationCallback cb, gpointer ud) { OperationFinishData *fd = g_new0(OperationFinishData, 1); fd->user_callback = cb; fd->user_data = ud; GTask *t = g_task_new(NULL, NULL, on_operation_finished, fd); g_task_run_in_thread(t, disconnect_task_thread_func); g_object_unref(t); }
static void disconnect_task_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) { (void)s; (void)d; (void)c; g_autofree gchar *device_path = find_wifi_device_path(); if (!device_path) { g_warning("No Wi-Fi device to disconnect."); g_task_return_boolean(task, FALSE); return; } g_autoptr(GError) error = NULL; g_autoptr(GDBusProxy) device_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, NM_DBUS_SERVICE, device_path, NM_DEVICE_INTERFACE, NULL, &error); if (error) { g_warning("Failed to create device proxy for disconnect: %s", error->message); g_task_return_boolean(task, FALSE); return; } g_dbus_proxy_call_sync(device_proxy, "Disconnect", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error); g_task_return_boolean(task, error == NULL); }

void wifi_network_free(gpointer data) { if (!data) return; WifiNetwork *net = (WifiNetwork*)data; g_free(net->ssid); g_free(net->object_path); g_free(net); }
void free_wifi_network_list(GList *list) { g_list_free_full(list, wifi_network_free); }
======================================================================
### FILE: ././widgets/control-center/src/brightness_manager.c
======================================================================
#include "brightness_manager.h"
#include "utils.h" // For run_command
#include <gio/gio.h>
#include <stdlib.h> // Needed for atoi

// Get current brightness as percentage
gint get_current_brightness() {
    // Use separate 'get' and 'max' calls for robustness instead of the machine-readable format.
    g_autofree gchar *current_str = run_command("brightnessctl get");
    g_autofree gchar *max_str = run_command("brightnessctl max");

    if (!current_str || !max_str) {
        g_warning("Failed to run brightnessctl 'get' or 'max' command.");
        return -1;
    }

    // atoi is sufficient and handles trailing newlines from command output.
    gint current = atoi(current_str);
    gint max = atoi(max_str);

    if (max > 0) {
        // Calculate percentage
        return (gint)(((gdouble)current * 100.0) / (gdouble)max);
    }

    g_warning("Could not calculate brightness percentage: max value from brightnessctl is invalid (<= 0).");
    return -1;
}

// --- Async Set Logic ---

typedef struct {
    gint percentage;
} BrightnessTaskData;

// Run this in thread to avoid blocking UI
static void set_brightness_thread_func(GTask *task, gpointer s, gpointer d, GCancellable *c) {
    (void)s;
    (void)d;
    (void)c;

    BrightnessTaskData *data = g_task_get_task_data(task);
    gchar *cmd = g_strdup_printf("brightnessctl set %d%%", data->percentage);

    // Execute the command
    g_spawn_command_line_sync(cmd, NULL, NULL, NULL, NULL);

    g_free(cmd);
    g_task_return_boolean(task, TRUE);
    g_free(data);
}

// Public function to set brightness asynchronously
void set_brightness_async(gint percentage) {
    BrightnessTaskData *task_data = g_new0(BrightnessTaskData, 1);
    task_data->percentage = percentage;

    GTask *task = g_task_new(NULL, NULL, NULL, NULL);
    g_task_set_task_data(task, task_data, NULL);
    g_task_run_in_thread(task, set_brightness_thread_func);
    g_object_unref(task);
}
======================================================================
### FILE: ././widgets/control-center/src/qr.c
======================================================================
#include "qr.h"
#include <qrencode.h>
#include <cairo.h>

// D-Bus constants
#define NM_DBUS_SERVICE "org.freedesktop.NetworkManager"
#define NM_SETTINGS_PATH "/org/freedesktop/NetworkManager/Settings"
#define NM_SETTINGS_INTERFACE "org.freedesktop.NetworkManager.Settings"
#define NM_SETTINGS_CONNECTION_INTERFACE "org.freedesktop.NetworkManager.Settings.Connection"

// Data for our background task
typedef struct {
    gchar *ssid;
    WifiQRCodeCallback user_callback;
    gpointer user_data;
} QRTaskData;

// Helper to find the D-Bus path of a saved connection by its SSID
static gchar* find_connection_path_for_ssid(GDBusConnection *bus, const gchar *ssid, GError **error) {
    g_autoptr(GVariant) connections_variant = g_dbus_connection_call_sync(bus,
        NM_DBUS_SERVICE, NM_SETTINGS_PATH, NM_SETTINGS_INTERFACE, "ListConnections",
        NULL, NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
    if (*error) return NULL;

    g_autoptr(GVariantIter) iter;
    g_variant_get(connections_variant, "(ao)", &iter);
    const gchar *conn_path;
    while (g_variant_iter_loop(iter, "o", &conn_path)) {
        g_autoptr(GVariant) settings_variant = g_dbus_connection_call_sync(bus,
            NM_DBUS_SERVICE, conn_path, NM_SETTINGS_CONNECTION_INTERFACE, "GetSettings",
            NULL, NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
        if (!settings_variant) continue;

        g_autoptr(GVariant) settings_dict = g_variant_get_child_value(settings_variant, 0);
        g_autoptr(GVariant) wifi_settings = g_variant_lookup_value(settings_dict, "802-11-wireless", G_VARIANT_TYPE("a{sv}"));
        if (!wifi_settings) continue;

        g_autoptr(GVariant) ssid_variant = g_variant_lookup_value(wifi_settings, "ssid", G_VARIANT_TYPE("ay"));
        if (ssid_variant) {
            gsize len;
            const gchar *ssid_bytes = g_variant_get_fixed_array(ssid_variant, &len, sizeof(guint8));
            if (len == strlen(ssid) && memcmp(ssid_bytes, ssid, len) == 0) {
                return g_strdup(conn_path);
            }
        }
    }
    return NULL;
}

// Helper to convert a qrencode object to a GdkPixbuf
static GdkPixbuf* qrcode_to_pixbuf(const QRcode *qrcode) {
    if (!qrcode) return NULL;
    const int scale = 8;
    const int margin = 2; // 2 modules of white space around the QR code
    int size = (qrcode->width + margin * 2) * scale;

    // Create a full-color ARGB surface directly. No more A8 mask.
    cairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, size, size);
    cairo_t *cr = cairo_create(surface);

    // 1. Fill the entire background with white.
    cairo_set_source_rgb(cr, 1.0, 1.0, 1.0);
    cairo_paint(cr);

    // 2. Set the drawing color to black for the QR code modules.
    cairo_set_source_rgb(cr, 0.0, 0.0, 0.0);

    // 3. Loop through the QR data and draw the black squares.
    unsigned char *p = qrcode->data;
    for (int y = 0; y < qrcode->width; y++) {
        for (int x = 0; x < qrcode->width; x++) {
            if (*p & 1) { // If the bit is 1, it's a black module
                // The coordinates are shifted by the margin to center the code.
                cairo_rectangle(cr, (x + margin) * scale, (y + margin) * scale, scale, scale);
            }
            p++;
        }
    }
    // Fill all the rectangles we defined in one go. This is more efficient.
    cairo_fill(cr);

    // Convert the final, correctly drawn surface to a pixbuf.
    GdkPixbuf *pixbuf = gdk_pixbuf_get_from_surface(surface, 0, 0, size, size);

    // Clean up Cairo resources.
    cairo_destroy(cr);
    cairo_surface_destroy(surface);

    return pixbuf;
}

// Main background thread logic (IMPROVED)
static void qr_code_thread_func(GTask *task, gpointer source_object, gpointer task_data, GCancellable *cancellable) {
    (void)source_object; (void)cancellable;
    QRTaskData *data = task_data;
    g_autoptr(GError) error = NULL;
    g_autofree gchar *password = NULL;
    g_autofree gchar *security_type = NULL;
    g_autoptr(GdkPixbuf) result_pixbuf = NULL;
    
    g_print("[QR BACKEND] 3. Background thread started for SSID: '%s'\n", data->ssid);
    
    g_autoptr(GDBusConnection) bus = g_bus_get_sync(G_BUS_TYPE_SYSTEM, NULL, &error);
    if (error) {
        g_warning("[QR BACKEND]    -> FAILURE: Could not connect to the system D-Bus. Error: %s\n", error->message);
        g_task_return_error(task, g_error_copy(error));
        return;
    }
    g_print("[QR BACKEND]    -> Successfully connected to D-Bus.\n");

    g_autofree gchar *connection_path = find_connection_path_for_ssid(bus, data->ssid, &error);
    if (error) {
        g_warning("[QR BACKEND]    -> FAILURE: Error while searching for connection profile. Error: %s\n", error->message);
        g_task_return_error(task, g_error_copy(error));
        return;
    }
    if (!connection_path) {
        g_warning("[QR BACKEND]    -> FAILURE: No saved connection profile found for SSID '%s'. Cannot get password.\n", data->ssid);
        g_task_return_error(task, g_error_new(G_IO_ERROR, G_IO_ERROR_NOT_FOUND, "No saved connection profile found for SSID '%s'", data->ssid));
        return;
    }
    g_print("[QR BACKEND]    -> Found connection profile at D-Bus path: %s\n", connection_path);

    g_print("[QR BACKEND] 4. Asking NetworkManager for secrets. This requires Polkit authentication!\n");
    g_autoptr(GVariant) secrets_variant = g_dbus_connection_call_sync(bus,
        NM_DBUS_SERVICE, connection_path, NM_SETTINGS_CONNECTION_INTERFACE, "GetSecrets",
        g_variant_new("(s)", "802-11-wireless-security"), NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);
    
    if (error) {
        g_warning("[QR BACKEND]    -> D-Bus call to 'GetSecrets' FAILED! This is the most common failure point.\n");
        g_warning("[QR BACKEND]    -> Reason: %s\n", error->message);
        g_warning("[QR BACKEND]    -> This usually means a Polkit agent is not running or permissions were denied.\n");
        g_task_return_error(task, g_error_copy(error));
        return;
    }

    g_print("[QR BACKEND]    -> Successfully received secrets from NetworkManager.\n");
    
    g_autoptr(GVariant) secrets_dict_outer = g_variant_get_child_value(secrets_variant, 0);
    g_autoptr(GVariant) secrets_dict = g_variant_lookup_value(secrets_dict_outer, "802-11-wireless-security", G_VARIANT_TYPE_VARDICT);
    if (secrets_dict) {
        g_print("[QR BACKEND]    -> Parsing secrets dictionary...\n");
        g_autoptr(GVariant) psk_variant = g_variant_lookup_value(secrets_dict, "psk", G_VARIANT_TYPE_STRING);
        if (psk_variant) {
            password = g_variant_dup_string(psk_variant, NULL);
            security_type = g_strdup("WPA");
            g_print("[QR BACKEND]    -> Success! Found WPA password (psk).\n");
        } else {
             g_warning("[QR BACKEND]    -> NOTE: Password (psk) not found in secrets. This might be an enterprise network (PEAP/EAP) or open network.\n");
        }
    } else {
         g_warning("[QR BACKEND]    -> NOTE: '802-11-wireless-security' dictionary not found. This is likely an open (unsecured) network.\n");
    }

    gchar *qr_string = NULL;
    if (password && security_type) {
        qr_string = g_strdup_printf("WIFI:S:%s;T:%s;P:%s;;", data->ssid, security_type, password);
    } else {
        qr_string = g_strdup_printf("WIFI:S:%s;T:nopass;;", data->ssid);
    }

    
    QRcode *qrcode = QRcode_encodeString(qr_string, 0, QR_ECLEVEL_L, QR_MODE_8, 1);
    result_pixbuf = qrcode_to_pixbuf(qrcode);
    QRcode_free(qrcode);
    g_free(qr_string);
    
    if (result_pixbuf) {
        g_print("[QR BACKEND]    -> QR Code generated and converted to pixbuf successfully.\n");
    } else {
        g_warning("[QR BACKEND]    -> FAILURE: QR code generation returned a NULL pixbuf.\n");
    }
    
    g_task_return_pointer(task, g_object_ref(result_pixbuf), g_object_unref);
}

// Main thread callback
static void on_qr_code_finished(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    (void)source_object;
    QRTaskData *data = user_data;
    g_autoptr(GError) error = NULL;
    
    GdkPixbuf *pixbuf = g_task_propagate_pointer(G_TASK(res), &error);
    
    if (error) {
        g_warning("Failed to generate QR code: %s", error->message);
        data->user_callback(NULL, data->user_data);
    } else {
        data->user_callback(pixbuf, data->user_data);
        if(pixbuf) g_object_unref(pixbuf);
    }
    
    g_free(data->ssid);
    g_free(data);
}

// Public API function
void generate_wifi_qr_code_async(const gchar *ssid, WifiQRCodeCallback callback, gpointer user_data) {
    QRTaskData *data = g_new0(QRTaskData, 1);
    data->ssid = g_strdup(ssid);
    data->user_callback = callback;
    data->user_data = user_data;
    
    GTask *task = g_task_new(NULL, NULL, on_qr_code_finished, data);
    g_task_set_task_data(task, data, NULL);
    g_task_run_in_thread(task, qr_code_thread_func);
    g_object_unref(task);
}
======================================================================
### FILE: ././widgets/control-center/src/utils.c
======================================================================
#include "utils.h"
#include <stdio.h>

gchar* run_command(const char *command_line) {
    gchar *stdout_buf = NULL;
    gint exit_status;
    GError *error = NULL;

    // g_spawn_command_line_sync is a robust way to run external commands.
    // It handles quoting and waits for the command to complete.
    g_spawn_command_line_sync(command_line, &stdout_buf, NULL, &exit_status, &error);

    if (error) {
        g_warning("Failed to run command '%s': %s", command_line, error->message);
        g_error_free(error);
        g_free(stdout_buf); // stdout_buf might be partially filled
        return NULL;
    }

    // You might want to check exit_status as well
    // if (exit_status != 0) { ... }
    
    // The buffer is null-terminated by GLib.
    return stdout_buf;
}
======================================================================
### FILE: ././widgets/control-center/src/brightness_manager.h
======================================================================
#ifndef BRIGHTNESS_MANAGER_H
#define BRIGHTNESS_MANAGER_H

#include <glib.h>

// Gets the current screen brightness as a percentage (0-100).
// Returns -1 on error.
gint get_current_brightness();

// Asynchronously sets the screen brightness.
void set_brightness_async(gint percentage);

#endif // BRIGHTNESS_MANAGER_H
======================================================================
### FILE: ././widgets/control-center/src/bluetooth_manager.c
======================================================================
// ===== widgets/control-center/src/bluetooth_manager.c (WITH DEBUG LOGGING) =====
#include "bluetooth_manager.h"
#include <gio/gio.h>
#include <string.h>

// D-Bus constants for BlueZ
#define BLUEZ_DBUS_SERVICE "org.bluez"
#define BLUEZ_DBUS_PATH "/"
#define BLUEZ_ADAPTER_INTERFACE "org.bluez.Adapter1"
#define BLUEZ_DEVICE_INTERFACE "org.bluez.Device1"

// --- Manager State ---
typedef struct {
    GDBusObjectManager *object_manager;
    BluetoothDeviceUpdateCallback update_callback;
    gpointer user_data;
    guint object_added_handler_id;
    guint object_removed_handler_id;
    guint properties_changed_handler_id;
} BluetoothManagerContext;

static BluetoothManagerContext *g_bt_context = NULL;

// --- Async Task Data ---
typedef struct { BluetoothOperationCallback cb; gpointer ud; } FinishData;
typedef struct { gchar *address; gboolean powered; } OperationData;

static void operation_data_free(gpointer data) {
    if (!data) return;
    OperationData *d = data;
    g_free(d->address);
    g_free(d);
}

// --- Forward Declarations ---
static void refresh_and_notify();

// --- Utility Functions ---
static gchar* find_adapter_path() {
    g_return_val_if_fail(g_bt_context && g_bt_context->object_manager, NULL);
    g_autoptr(GList) objects = g_dbus_object_manager_get_objects(g_bt_context->object_manager);
    for (GList *l = objects; l != NULL; l = l->next) {
        if (g_dbus_object_get_interface(l->data, BLUEZ_ADAPTER_INTERFACE)) {
            return g_strdup(g_dbus_object_get_object_path(l->data));
        }
    }
    return NULL;
}

static gchar* find_device_path_for_address(const gchar *address) {
    g_return_val_if_fail(g_bt_context && g_bt_context->object_manager, NULL);
    g_autoptr(GList) objects = g_dbus_object_manager_get_objects(g_bt_context->object_manager);
    for (GList *l = objects; l != NULL; l = l->next) {
        g_autoptr(GDBusInterface) iface = g_dbus_object_get_interface(l->data, BLUEZ_DEVICE_INTERFACE);
        if (iface) {
            g_autoptr(GVariant) addr_var = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(iface), "Address");
            if (addr_var && g_strcmp0(g_variant_get_string(addr_var, NULL), address) == 0) {
                return g_strdup(g_dbus_object_get_object_path(l->data));
            }
        }
    }
    return NULL;
}

// --- D-Bus Signal Handlers ---
static void on_object_added_or_removed(GDBusObjectManager *m, GDBusObject *o, gpointer d) { (void)m; (void)o; (void)d; refresh_and_notify(); }
static void on_properties_changed(GDBusObjectManagerClient *m, GDBusObjectProxy *o, GDBusProxy *i, GVariant *v, const gchar *const *iv, gpointer d) { (void)m; (void)o; (void)i; (void)v; (void)iv; (void)d; refresh_and_notify(); }
static void refresh_and_notify() { if (g_bt_context && g_bt_context->update_callback) { GList *devices = get_available_bluetooth_devices(); g_bt_context->update_callback(devices, g_bt_context->user_data); } }

// --- Lifecycle ---
gboolean bluetooth_manager_init(BluetoothDeviceUpdateCallback callback, gpointer user_data) {
    if (g_bt_context) return TRUE;
    g_bt_context = g_new0(BluetoothManagerContext, 1);
    g_bt_context->update_callback = callback; g_bt_context->user_data = user_data;
    g_autoptr(GError) error = NULL;
    g_bt_context->object_manager = g_dbus_object_manager_client_new_for_bus_sync( G_BUS_TYPE_SYSTEM, G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE, BLUEZ_DBUS_SERVICE, BLUEZ_DBUS_PATH, NULL, NULL, NULL, NULL, &error);
    if (error) { g_warning("Failed to create BlueZ D-Bus object manager: %s", error->message); bluetooth_manager_shutdown(); return FALSE; }
    g_bt_context->object_added_handler_id = g_signal_connect(g_bt_context->object_manager, "object-added", G_CALLBACK(on_object_added_or_removed), NULL);
    g_bt_context->object_removed_handler_id = g_signal_connect(g_bt_context->object_manager, "object-removed", G_CALLBACK(on_object_added_or_removed), NULL);
    g_bt_context->properties_changed_handler_id = g_signal_connect(g_bt_context->object_manager, "interface-proxy-properties-changed", G_CALLBACK(on_properties_changed), NULL);
    refresh_and_notify(); return TRUE;
}

void bluetooth_manager_shutdown() {
    if (!g_bt_context) return;
    if (g_bt_context->object_manager) {
        g_signal_handler_disconnect(g_bt_context->object_manager, g_bt_context->object_added_handler_id);
        g_signal_handler_disconnect(g_bt_context->object_manager, g_bt_context->object_removed_handler_id);
        g_signal_handler_disconnect(g_bt_context->object_manager, g_bt_context->properties_changed_handler_id);
        g_object_unref(g_bt_context->object_manager);
    }
    g_free(g_bt_context); g_bt_context = NULL;
}

// --- Discovery & Power ---
void bluetooth_manager_start_discovery() { g_autofree gchar *p = find_adapter_path(); if (!p) return; g_autoptr(GDBusProxy) proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, BLUEZ_DBUS_SERVICE, p, BLUEZ_ADAPTER_INTERFACE, NULL, NULL); if (proxy) g_dbus_proxy_call(proxy, "StartDiscovery", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL, NULL); }
void bluetooth_manager_stop_discovery() { g_autofree gchar *p = find_adapter_path(); if (!p) return; g_autoptr(GDBusProxy) proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, BLUEZ_DBUS_SERVICE, p, BLUEZ_ADAPTER_INTERFACE, NULL, NULL); if (proxy) g_dbus_proxy_call(proxy, "StopDiscovery", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL, NULL); }
gboolean is_bluetooth_powered() { g_autofree gchar *p = find_adapter_path(); if (!p) return FALSE; g_autoptr(GDBusProxy) proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, BLUEZ_DBUS_SERVICE, p, BLUEZ_ADAPTER_INTERFACE, NULL, NULL); if (!proxy) return FALSE; g_autoptr(GVariant) prop = g_dbus_proxy_get_cached_property(proxy, "Powered"); return prop ? g_variant_get_boolean(prop) : FALSE; }
static void on_async_op_finished(GObject *s, GAsyncResult *res, gpointer d) { (void)s; FinishData *fd = d; gboolean success = g_task_propagate_boolean(G_TASK(res), NULL); g_print("[BT DEBUG] on_async_op_finished called. Success: %s\n", success ? "TRUE" : "FALSE"); if (fd->cb) fd->cb(success, fd->ud); g_free(fd); }
static void set_powered_thread(GTask *t, gpointer s, gpointer d, GCancellable *c) { (void)s; (void)c; (void)d; OperationData *data = g_task_get_task_data(t); g_autofree gchar *p = find_adapter_path(); if (!p) { g_task_return_boolean(t, FALSE); return; } g_autoptr(GDBusProxy) proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, BLUEZ_DBUS_SERVICE, p, "org.freedesktop.DBus.Properties", NULL, NULL); if (!proxy) { g_task_return_boolean(t, FALSE); return; } g_autoptr(GError) error = NULL; g_dbus_proxy_call_sync(proxy, "Set", g_variant_new("(ssv)", BLUEZ_ADAPTER_INTERFACE, "Powered", g_variant_new_boolean(data->powered)), G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error); g_task_return_boolean(t, error == NULL); }
void set_bluetooth_powered_async(gboolean powered, BluetoothOperationCallback cb, gpointer ud) { OperationData *td = g_new0(OperationData, 1); td->powered = powered; FinishData *fd = g_new0(FinishData, 1); fd->cb = cb; fd->ud = ud; GTask *t = g_task_new(NULL, NULL, on_async_op_finished, fd); g_task_set_task_data(t, td, operation_data_free); g_task_run_in_thread(t, set_powered_thread); g_object_unref(t); }

// --- Get Devices (from cache) ---
static gint sort_devices(gconstpointer a, gconstpointer b) { const BluetoothDevice *da=a, *db=b; if (da->is_connected && !db->is_connected) return -1; if (!da->is_connected && db->is_connected) return 1; return g_strcmp0(da->name, db->name); }
GList* get_available_bluetooth_devices() { if (!g_bt_context || !g_bt_context->object_manager) return NULL; GList *devices = NULL; g_autoptr(GList) objects = g_dbus_object_manager_get_objects(g_bt_context->object_manager); for (GList *l = objects; l != NULL; l = l->next) { g_autoptr(GDBusInterface) iface = g_dbus_object_get_interface(l->data, BLUEZ_DEVICE_INTERFACE); if (iface) { BluetoothDevice *dev=g_new0(BluetoothDevice,1); dev->object_path=g_strdup(g_dbus_object_get_object_path(l->data)); g_autoptr(GVariant) name=g_dbus_proxy_get_cached_property(G_DBUS_PROXY(iface),"Name"), addr=g_dbus_proxy_get_cached_property(G_DBUS_PROXY(iface),"Address"), conn=g_dbus_proxy_get_cached_property(G_DBUS_PROXY(iface),"Connected"); dev->name = name ? g_variant_dup_string(name,NULL) : g_strdup("Unknown"); dev->address = addr ? g_variant_dup_string(addr,NULL) : g_strdup("??:"); dev->is_connected = conn ? g_variant_get_boolean(conn) : FALSE; devices = g_list_prepend(devices,dev); } } return g_list_sort(devices, sort_devices); }

// --- Connect/Disconnect ---
static void connect_thread(GTask *t, gpointer s, gpointer d, GCancellable *c) {
    (void)s; (void)c; (void)d;
    OperationData *data = g_task_get_task_data(t);
    g_print("[BT DEBUG] connect_thread started for address: %s\n", data->address);

    g_autofree gchar *device_path = find_device_path_for_address(data->address);
    if (!device_path) {
        g_warning("[BT WARNING] connect_thread: FAILED to find device path for address: %s\n", data->address);
        g_task_return_boolean(t, FALSE);
        return;
    }
    g_print("[BT DEBUG] connect_thread: Found device path: %s\n", device_path);

    g_autoptr(GDBusInterface) iface = g_dbus_object_manager_get_interface(g_bt_context->object_manager, device_path, BLUEZ_DEVICE_INTERFACE);
    if (!iface) {
        g_warning("[BT WARNING] connect_thread: FAILED to get D-Bus interface for path: %s\n", device_path);
        g_task_return_boolean(t, FALSE);
        return;
    }
    g_print("[BT DEBUG] connect_thread: Got D-Bus interface successfully.\n");

    g_autoptr(GError) error = NULL;
    g_dbus_proxy_call_sync(G_DBUS_PROXY(iface), "Connect", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);

    if (error) {
        g_warning("[BT WARNING] connect_thread: D-Bus Connect() call FAILED: %s\n", error->message);
        g_task_return_boolean(t, FALSE);
    } else {
        g_print("[BT DEBUG] connect_thread: D-Bus Connect() call SUCCEEDED.\n");
        g_task_return_boolean(t, TRUE);
    }
}

static void disconnect_thread(GTask *t, gpointer s, gpointer d, GCancellable *c) {
    (void)s; (void)c; (void)d;
    OperationData *data = g_task_get_task_data(t);
    g_print("[BT DEBUG] disconnect_thread started for address: %s\n", data->address);

    g_autofree gchar *device_path = find_device_path_for_address(data->address);
    if (!device_path) {
        g_warning("[BT WARNING] disconnect_thread: FAILED to find device path for address: %s\n", data->address);
        g_task_return_boolean(t, FALSE);
        return;
    }
    g_print("[BT DEBUG] disconnect_thread: Found device path: %s\n", device_path);

    g_autoptr(GDBusInterface) iface = g_dbus_object_manager_get_interface(g_bt_context->object_manager, device_path, BLUEZ_DEVICE_INTERFACE);
    if (!iface) {
        g_warning("[BT WARNING] disconnect_thread: FAILED to get D-Bus interface for path: %s\n", device_path);
        g_task_return_boolean(t, FALSE);
        return;
    }
    g_print("[BT DEBUG] disconnect_thread: Got D-Bus interface successfully.\n");

    g_autoptr(GError) error = NULL;
    g_dbus_proxy_call_sync(G_DBUS_PROXY(iface), "Disconnect", NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);
    
    if (error) {
        g_warning("[BT WARNING] disconnect_thread: D-Bus Disconnect() call FAILED: %s\n", error->message);
        g_task_return_boolean(t, FALSE);
    } else {
        g_print("[BT DEBUG] disconnect_thread: D-Bus Disconnect() call SUCCEEDED.\n");
        g_task_return_boolean(t, TRUE);
    }
}

void connect_to_bluetooth_device_async(const gchar *address, BluetoothOperationCallback cb, gpointer ud) {
    g_print("[BT DEBUG] connect_to_bluetooth_device_async called for %s\n", address);
    OperationData *td = g_new0(OperationData, 1); td->address = g_strdup(address);
    FinishData *fd = g_new0(FinishData, 1); fd->cb = cb; fd->ud = ud;
    GTask *t = g_task_new(NULL, NULL, on_async_op_finished, fd);
    g_task_set_task_data(t, td, operation_data_free);
    g_task_run_in_thread(t, connect_thread);
    g_object_unref(t);
}

void disconnect_bluetooth_device_async(const gchar *address, BluetoothOperationCallback cb, gpointer ud) {
    g_print("[BT DEBUG] disconnect_bluetooth_device_async called for %s\n", address);
    OperationData *td = g_new0(OperationData, 1); td->address = g_strdup(address);
    FinishData *fd = g_new0(FinishData, 1); fd->cb = cb; fd->ud = ud;
    GTask *t = g_task_new(NULL, NULL, on_async_op_finished, fd);
    g_task_set_task_data(t, td, operation_data_free);
    g_task_run_in_thread(t, disconnect_thread);
    g_object_unref(t);
}

// --- Memory Management ---
void bluetooth_device_free(gpointer data) { if (!data) return; BluetoothDevice *dev = (BluetoothDevice*)data; g_free(dev->address); g_free(dev->name); g_free(dev->object_path); g_free(dev); }
void free_bluetooth_device_list(GList *list) { g_list_free_full(list, bluetooth_device_free); }
======================================================================
### FILE: ././widgets/control-center/src/bluetooth_scanner.c
======================================================================
// ===== src/bluetooth_scanner.c =====
#include "bluetooth_scanner.h"
#include "bluetooth_manager.h"

struct _BluetoothScanner {
    // The scanner no longer manages timers, only the callback.
    BluetoothScanResultCallback callback;
    gpointer user_data;
};

BluetoothScanner* bluetooth_scanner_new(BluetoothScanResultCallback callback, gpointer user_data) {
    BluetoothScanner *scanner = g_new0(BluetoothScanner, 1);
    scanner->callback = callback;
    scanner->user_data = user_data;
    return scanner;
}

void bluetooth_scanner_start(BluetoothScanner *scanner) {
    g_print("Starting Bluetooth discovery...\n");
    bluetooth_manager_start_discovery();
    // Trigger one scan immediately to populate the UI from the cache
    bluetooth_scanner_trigger_scan(scanner);
}

void bluetooth_scanner_stop(BluetoothScanner *scanner) {
    (void)scanner;
    g_print("Stopping Bluetooth discovery...\n");
    bluetooth_manager_stop_discovery();
}

void bluetooth_scanner_trigger_scan(BluetoothScanner *scanner) {
    if (!scanner || !scanner->callback) {
        return;
    }
    // This no longer triggers a hardware scan. It just gets the latest
    // device list from the manager's cache and sends it to the UI.
    GList *devices = get_available_bluetooth_devices();
    scanner->callback(devices, scanner->user_data);
}

void bluetooth_scanner_free(BluetoothScanner *scanner) {
    if (!scanner) return;
    bluetooth_scanner_stop(scanner);
    g_free(scanner);
}
======================================================================
### FILE: ././widgets/control-center/src/system_monitor.c
======================================================================
// ===== src/system_monitor.c =====
#include "system_monitor.h"
#include "utils.h"
#include <gio/gio.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <dirent.h>

struct _SystemMonitor {
    SystemEventCallback callback;
    gpointer user_data;

    // Volume
    GPid       pactl_pid;
    GIOChannel *pactl_channel;
    guint      pactl_watch_id;

    // Brightness
    GFileMonitor *brightness_monitor;
    gchar        *brightness_device;
};

// --- FORWARD DECLARATION ---
// This tells the compiler that this function exists before it is used.
static void on_brightness_file_changed(GFileMonitor *monitor, GFile *file, GFile *other_file, GFileMonitorEvent event_type, gpointer user_data);

// --- pactl (Volume) Monitor Logic ---
static gboolean on_pactl_output(GIOChannel *source, GIOCondition condition, gpointer user_data) {
    (void)condition;
    SystemMonitor *sm = user_data;
    g_autofree gchar *line = NULL;
    gsize len;

    if (g_io_channel_read_line(source, &line, &len, NULL, NULL) == G_IO_STATUS_NORMAL) {
        if (strstr(line, "on sink #") || strstr(line, "on server")) {
            sm->callback(SYSTEM_EVENT_VOLUME_CHANGED, sm->user_data);
        }
    }
    return G_SOURCE_CONTINUE;
}

static void start_volume_monitor(SystemMonitor *sm) {
    const gchar *pactl_path = "/usr/bin/pactl";
    if (access(pactl_path, X_OK) != 0) {
        g_warning("'pactl' not found at %s", pactl_path);
        return;
    }
    gchar *argv[] = { (gchar *)pactl_path, "subscribe", NULL };
    gint stdout_fd;
    GError *error = NULL;

    if (!g_spawn_async_with_pipes(NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &sm->pactl_pid, NULL, &stdout_fd, NULL, &error)) {
        g_warning("Failed to spawn pactl: %s", error->message);
        g_error_free(error);
        return;
    }
    g_print("Started 'pactl subscribe' PID %d\n", sm->pactl_pid);
    sm->pactl_channel = g_io_channel_unix_new(stdout_fd);
    g_io_channel_set_encoding(sm->pactl_channel, NULL, NULL);
    g_io_channel_set_flags(sm->pactl_channel, G_IO_FLAG_NONBLOCK, NULL);
    sm->pactl_watch_id = g_io_add_watch(sm->pactl_channel, G_IO_IN | G_IO_HUP, on_pactl_output, sm);
}

// --- Asynchronous Brightness Monitor Logic ---

// This function is run in a background thread to avoid blocking the UI.
static void find_brightness_device_thread_func(GTask *task, gpointer source_object, gpointer task_data, GCancellable *cancellable) {
    (void)task; (void)source_object; (void)task_data; (void)cancellable;
    const char *cmd = "sh -c \"brightnessctl -l -m | head -n1 | cut -d, -f1\"";
    g_autofree gchar *device = run_command(cmd);

    if (device) {
        g_strstrip(device);
        gboolean all_digits = TRUE;
        for (gchar *p = device; *p; ++p) {
            if (!g_ascii_isdigit(*p)) { all_digits = FALSE; break; }
        }
        if (all_digits || strlen(device) == 0) {
            g_free(device);
            device = NULL; // Will trigger fallback in the finish function
        }
    }
    // Return the found device name (or NULL) as the result of the task.
    g_task_return_pointer(task, g_strdup(device), g_free);
}

// Helper to find a fallback device if brightnessctl fails.
static gchar* fallback_brightness_device(void) {
    DIR *d = opendir("/sys/class/backlight");
    if (!d) return NULL;
    struct dirent *ent;
    while ((ent = readdir(d))) {
        if (ent->d_name[0] == '.') continue;
        closedir(d);
        return g_strdup(ent->d_name);
    }
    closedir(d);
    return NULL;
}

// This function is called on the main thread when the background task is finished.
static void on_brightness_device_found(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    SystemMonitor *sm = user_data;
    g_autoptr(GError) error = NULL;
    g_autofree gchar *device_name = g_task_propagate_pointer(G_TASK(res), &error);

    if (error) {
        g_warning("Could not find brightness device: %s", error->message);
        return;
    }
    
    // If the command failed, try a fallback method.
    if (device_name == NULL) {
        device_name = fallback_brightness_device();
    }
    
    if (device_name == NULL) {
        g_warning("Could not determine brightness device name at all.");
        return;
    }

    sm->brightness_device = g_strdup(device_name);
    g_autofree gchar *path = g_strdup_printf("/sys/class/backlight/%s/actual_brightness", sm->brightness_device);
    g_print("Monitoring brightness at: %s\n", path);

    GFile *file = g_file_new_for_path(path);
    // Note: GFileMonitor must be created and used on the same thread, which is why we do it here.
    sm->brightness_monitor = g_file_monitor_file(file, G_FILE_MONITOR_NONE, NULL, NULL);
    g_object_unref(file);

    if (!sm->brightness_monitor) {
        g_warning("Failed to create file monitor for %s", path);
        return;
    }
    g_signal_connect(sm->brightness_monitor, "changed", G_CALLBACK(on_brightness_file_changed), sm);
}

// Brightness-change handler (the actual event callback)
static void on_brightness_file_changed(GFileMonitor *monitor, GFile *file, GFile *other_file, GFileMonitorEvent event_type, gpointer user_data) {
    (void)monitor; (void)file; (void)other_file;
    if (event_type == G_FILE_MONITOR_EVENT_CHANGED) {
        SystemMonitor *sm = user_data;
        sm->callback(SYSTEM_EVENT_BRIGHTNESS_CHANGED, sm->user_data);
    }
}

// This function now starts the *asynchronous* process. It returns instantly.
static void start_brightness_monitor_async(SystemMonitor *sm) {
    GTask *task = g_task_new(NULL, NULL, on_brightness_device_found, sm);
    g_task_run_in_thread(task, find_brightness_device_thread_func);
    g_object_unref(task); // The task will hold a ref to itself until it's done.
}

// --- Public API ---
SystemMonitor* system_monitor_new(SystemEventCallback callback, gpointer user_data) {
    SystemMonitor *sm = g_new0(SystemMonitor, 1);
    sm->callback = callback;
    sm->user_data = user_data;

    start_volume_monitor(sm);
    start_brightness_monitor_async(sm); // Use the new non-blocking function
    
    return sm;
}

void system_monitor_free(SystemMonitor *sm) {
    if (!sm) return;

    if (sm->pactl_watch_id > 0)
        g_source_remove(sm->pactl_watch_id);
    if (sm->pactl_channel)
        g_io_channel_unref(sm->pactl_channel);
    if (sm->pactl_pid > 0) {
        kill(sm->pactl_pid, SIGTERM);
        g_spawn_close_pid(sm->pactl_pid);
    }
    if (sm->brightness_monitor) {
        g_file_monitor_cancel(sm->brightness_monitor);
        g_object_unref(sm->brightness_monitor);
    }
    g_free(sm->brightness_device);
    g_free(sm);
}
======================================================================
### FILE: ././widgets/control-center/src/system_monitor.h
======================================================================
#ifndef SYSTEM_MONITOR_H
#define SYSTEM_MONITOR_H

#include <glib.h>

// Enum to identify the type of event that occurred.
typedef enum {
    SYSTEM_EVENT_VOLUME_CHANGED,
    SYSTEM_EVENT_BRIGHTNESS_CHANGED
} SystemEventType;

// The callback function that the UI will provide.
typedef void (*SystemEventCallback)(SystemEventType type, gpointer user_data);

typedef struct _SystemMonitor SystemMonitor;

// Creates a new monitor. It will immediately start listening for events.
SystemMonitor* system_monitor_new(SystemEventCallback callback, gpointer user_data);

// Stops listening and frees all resources.
void system_monitor_free(SystemMonitor *monitor);

#endif // SYSTEM_MONITOR_H
======================================================================
### FILE: ././widgets/control-center/src/network_manager.h
======================================================================
// ===== widgets/control-center/src/network_manager.h (COMPLETE) =====
#ifndef NETWORK_MANAGER_H
#define NETWORK_MANAGER_H

#include <glib.h>

// --- Init and Shutdown ---
gboolean network_manager_init();
void network_manager_shutdown();

// --- Type Definitions ---
typedef void (*NetworkOperationCallback)(gboolean success, gpointer user_data);

// --- ADD THIS NEW ENUM ---
typedef enum {
    WIFI_STATE_DISCONNECTED,      // Not connected, but might be known/saved
    WIFI_STATE_CONNECTING,        // In the process of connecting
    WIFI_STATE_LIMITED,           // Connected to router, but no internet access
    WIFI_STATE_CONNECTED          // Fully connected with internet access
} WifiConnectivityState;
// --- END NEW ENUM ---

typedef struct {
    gchar *ssid;
    gchar *object_path; // D-Bus object path of the Access Point
    guint8 strength;
    gboolean is_secure;
    gboolean is_active;
    gboolean is_known; // Is this a saved network profile?
    
    // --- ADD THIS NEW FIELD ---
    WifiConnectivityState connectivity;

} WifiNetwork;

typedef struct {
    gchar *ssid;
    gchar *security;
    guint8 strength;
    gchar *ip_address;
    gchar *mac_address;
} WifiNetworkDetails;

// NEW: Callback for the async details function
typedef void (*WifiDetailsCallback)(WifiNetworkDetails *details, gpointer user_data);

// --- Radio Control ---
gboolean is_wifi_enabled();
void set_wifi_enabled_async(gboolean enabled, NetworkOperationCallback callback, gpointer user_data);
gboolean is_airplane_mode_active();

// --- Network Operations ---
GList* get_available_wifi_networks();

void get_wifi_network_details_async(const gchar *ap_path, WifiDetailsCallback callback, gpointer user_data);

gchar* find_connection_for_ssid(const gchar *ssid);
gboolean is_connection_forgettable(const gchar *connection_path, gboolean is_network_secure);

void activate_wifi_connection_async(const gchar *connection_path,
                                    const gchar *ap_path,
                                    NetworkOperationCallback callback,
                                    gpointer user_data);

void add_and_activate_wifi_connection_async(const gchar *ssid,
                                            const gchar *ap_path,
                                            const gchar *password,
                                            gboolean is_secure,
                                            NetworkOperationCallback callback,
                                            gpointer user_data);
                                   
void forget_wifi_connection_async(const gchar *ssid,
                                  NetworkOperationCallback callback,
                                  gpointer user_data);

void disconnect_wifi_async(NetworkOperationCallback callback,
                           gpointer user_data);

// --- Memory Management ---
void wifi_network_free(gpointer data);
void free_wifi_network_list(GList *list);
void free_wifi_network_details(WifiNetworkDetails *details);

#endif // NETWORK_MANAGER_H
======================================================================
### FILE: ././widgets/control-center/meson.build
======================================================================
# widgets/control-center/meson.build

control_center_sources = [
  'src/main.c',
  'src/audio_manager.c',
  'src/bluetooth_manager.c',
  'src/bluetooth_scanner.c',
  'src/brightness_manager.c',
  'src/network_manager.c',
  'src/system_monitor.c',
  'src/utils.c',
  'src/wifi_scanner.c',
  'src/qr.c', 
]

control_center_deps = [
  dependency('gtk4'),
  dependency('libadwaita-1'),
  dependency('gio-2.0'),
  dependency('gio-unix-2.0'),
  dependency('libqrencode'),
]

# Note: Your config.json looks for 'control-center.so'.
# Building as shared_library with name_prefix is the most consistent way.
shared_library('control-center',
  control_center_sources,
  dependencies: control_center_deps,
  name_prefix: '',
  # THE FIX IS HERE:
  install: true,
  install_dir: get_option('libdir') / 'aurora-shell' / 'widgets'
)
======================================================================
### FILE: ././widgets/insight/insight.c
======================================================================
#include <gtk/gtk.h>
#include <cairo.h>
#include <sqlite3.h>
#include <time.h>
#include <glib.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

// --- Data Structures ---
typedef struct {
    GtkWidget *today_time_label, *top_apps_box, *chart_area, *selected_day_title_label;
    GtkWidget *week_title_label, *week_time_label;
    GtkWidget *next_week_button;
    double daily_hours[7];
    GDate *today_date;
    GDate *selected_date;
    GDate *reference_date; // A date within the week we want to display
    guint timer_id;
} AppData;

typedef struct { char app_class[256]; long seconds; } AppUsageInfo;
typedef struct { double fraction; } CustomBarData;


// --- Forward Declarations ---
static gboolean update_data_and_ui(gpointer user_data);
static void draw_chart(GtkDrawingArea *area, cairo_t *cr, int width, int height, gpointer user_data);
static void on_db_changed(GFileMonitor *monitor, GFile *file, GFile *other_file, GFileMonitorEvent event_type, gpointer user_data);


// --- Helper & Drawing Functions ---
static gboolean get_css_color(GtkWidget *widget, const char *color_name, GdkRGBA *out_color) {
    GtkStyleContext *context = gtk_widget_get_style_context(widget);
    return gtk_style_context_lookup_color(context, color_name, out_color);
}
static char* prettify_app_name(const char* original_name) {
    const char* last_dot = strrchr(original_name, '.');
    char* pretty_name = last_dot ? g_strdup(last_dot + 1) : g_strdup(original_name);
    if (pretty_name[0]) { pretty_name[0] = toupper(pretty_name[0]); }
    return pretty_name;
}
static void draw_rounded_bar(cairo_t *cr, double x, double y, double width, double height, double radius) {
    if (height < 1 || width < 1) return;
    if (radius > height / 2) radius = height / 2;
    if (radius > width / 2) radius = width / 2;
    cairo_new_sub_path(cr);
    cairo_arc(cr, x + radius, y + radius, radius, G_PI, 1.5 * G_PI);
    cairo_arc(cr, x + width - radius, y + radius, radius, 1.5 * G_PI, 2 * G_PI);
    cairo_arc(cr, x + width - radius, y + height - radius, radius, 0, 0.5 * G_PI);
    cairo_arc(cr, x + radius, y + height - radius, radius, 0.5 * G_PI, G_PI);
    cairo_close_path(cr);
}
static void draw_custom_app_bar(GtkDrawingArea *area, cairo_t *cr, int width, int height, gpointer user_data) {
    CustomBarData *bar_data = (CustomBarData *)user_data;
    GdkRGBA accent_color, trough_color;
    get_css_color(GTK_WIDGET(area), "accent", &accent_color);
    if (get_css_color(GTK_WIDGET(area), "foreground", &trough_color)) {
        trough_color.alpha = 0.05;
    }
    cairo_set_source_rgba(cr, trough_color.red, trough_color.green, trough_color.blue, trough_color.alpha);
    draw_rounded_bar(cr, 0, 0, width, height, height / 2.0);
    cairo_fill(cr);
    double bar_width = width * bar_data->fraction;
    if (bar_width > 0) {
        cairo_set_source_rgba(cr, accent_color.red, accent_color.green, accent_color.blue, accent_color.alpha);
        draw_rounded_bar(cr, 0, 0, bar_width, height, height / 2.0);
        cairo_fill(cr);
    }
}

// --- Main Data & UI Update Function ---
static gboolean update_data_and_ui(gpointer user_data) {
    AppData *data = (AppData *)user_data;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    for (int i=0; i<7; i++) data->daily_hours[i] = 0.0;
    long week_total_seconds = 0;
    
    // ==============================================================================
    // === FIX BLOCK 1: Establish a single, unambiguous definition of the week. ===
    // ==============================================================================
    
    // Calculate the start of the week (Sunday) based on the reference_date.
    GDate *week_start_date = g_date_copy(data->reference_date);
    // GLib weekday: Mon=1, Tue=2, ..., Sun=7. `g_date_get_weekday() % 7` maps Sun to 0.
    g_date_subtract_days(week_start_date, g_date_get_weekday(week_start_date) % 7);

    // Calculate the end of the week (Saturday).
    GDate *week_end_date = g_date_copy(week_start_date);
    g_date_add_days(week_end_date, 6);

    // Prepare date strings for the SQL query.
    char week_start_str[11];
    char week_end_str[11];
    g_date_strftime(week_start_str, sizeof(week_start_str), "%Y-%m-%d", week_start_date);
    g_date_strftime(week_end_str, sizeof(week_end_str), "%Y-%m-%d", week_end_date);
    
    // --- Now, use these exact dates for the query. ---
    g_autofree gchar *db_path = g_build_filename(g_get_home_dir(), ".local", "share", "aurora-insight.db", NULL);
    if (sqlite3_open_v2(db_path, &db, SQLITE_OPEN_READONLY, NULL) != SQLITE_OK) { 
        g_date_free(week_start_date);
        g_date_free(week_end_date);
        return G_SOURCE_CONTINUE; 
    }
    
    // The new, unambiguous SQL query. It no longer does its own date math.
    const char *sql_week = "SELECT CAST(strftime('%w', date) AS INTEGER), SUM(usage_seconds) FROM app_usage WHERE date BETWEEN ? AND ? GROUP BY date;";
    
    if (sqlite3_prepare_v2(db, sql_week, -1, &stmt, 0) == SQLITE_OK) {
        sqlite3_bind_text(stmt, 1, week_start_str, -1, SQLITE_STATIC); // Bind start date
        sqlite3_bind_text(stmt, 2, week_end_str, -1, SQLITE_STATIC);   // Bind end date
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            int day_of_week = sqlite3_column_int(stmt, 0); // Sunday=0, Monday=1, etc.
            long seconds = sqlite3_column_int(stmt, 1);
            if (day_of_week >= 0 && day_of_week <= 6) { 
                data->daily_hours[day_of_week] = (double)seconds / 3600.0; 
                week_total_seconds += seconds; 
            }
        }
    }
    sqlite3_finalize(stmt);
    
    // ==============================================================================
    // === END FIX BLOCK 1 ===
    // ==============================================================================

    char selected_date_str[11];
    g_date_strftime(selected_date_str, sizeof(selected_date_str), "%Y-%m-%d", data->selected_date);
    long selected_day_total_seconds = 0;
    const char *sql_day_total = "SELECT SUM(usage_seconds) FROM app_usage WHERE date = ?;";
    if (sqlite3_prepare_v2(db, sql_day_total, -1, &stmt, 0) == SQLITE_OK) {
        sqlite3_bind_text(stmt, 1, selected_date_str, -1, SQLITE_STATIC);
        if (sqlite3_step(stmt) == SQLITE_ROW) { selected_day_total_seconds = sqlite3_column_int(stmt, 0); }
    }
    sqlite3_finalize(stmt);
    char time_str[128];
    snprintf(time_str, sizeof(time_str), "<span size='x-large' weight='bold'>%ldh %ldm</span>", selected_day_total_seconds / 3600, (selected_day_total_seconds % 3600) / 60);
    gtk_label_set_markup(GTK_LABEL(data->today_time_label), time_str);
    snprintf(time_str, sizeof(time_str), "<span size='x-large' weight='bold'>%ldh %ldm</span>", week_total_seconds / 3600, (week_total_seconds % 3600) / 60);
    gtk_label_set_markup(GTK_LABEL(data->week_time_label), time_str);
    gboolean is_current_week = (g_date_compare(data->today_date, week_start_date) >= 0 && g_date_compare(data->today_date, week_end_date) <= 0);
    
    if (is_current_week) { 
        gtk_label_set_text(GTK_LABEL(data->week_title_label), "This Week");
    } else { 
        GDate *today_week_start = g_date_copy(data->today_date);
        g_date_subtract_days(today_week_start, g_date_get_weekday(today_week_start) % 7);
        g_date_subtract_days(today_week_start, 7); // Start of last week
        gboolean is_last_week = (g_date_compare(week_start_date, today_week_start) == 0);
        g_date_free(today_week_start);
        
        if (is_last_week) { 
            gtk_label_set_text(GTK_LABEL(data->week_title_label), "Last Week");
        } else { 
            char range_str[64]; 
            char start_str[32], end_str[32]; 
            g_date_strftime(start_str, sizeof(start_str), "%b %d", week_start_date); 
            g_date_strftime(end_str, sizeof(end_str), "%b %d", week_end_date); 
            snprintf(range_str, sizeof(range_str), "%s - %s", start_str, end_str); 
            gtk_label_set_text(GTK_LABEL(data->week_title_label), range_str); 
        }
    }
    
    // Cleanup GDate objects from the fix block
    g_date_free(week_start_date);
    g_date_free(week_end_date);
    
    gtk_widget_set_sensitive(data->next_week_button, !is_current_week);
    if (g_date_compare(data->selected_date, data->today_date) == 0) { gtk_label_set_text(GTK_LABEL(data->selected_day_title_label), "Today");
    } else { GDate *yesterday = g_date_copy(data->today_date); g_date_subtract_days(yesterday, 1);
        if (g_date_compare(data->selected_date, yesterday) == 0) { gtk_label_set_text(GTK_LABEL(data->selected_day_title_label), "Yesterday");
        } else { char day_name[32]; g_date_strftime(day_name, sizeof(day_name), "%A", data->selected_date); gtk_label_set_text(GTK_LABEL(data->selected_day_title_label), day_name); }
        g_date_free(yesterday);
    }
    GtkWidget *child; while ((child = gtk_widget_get_first_child(data->top_apps_box))) { gtk_box_remove(GTK_BOX(data->top_apps_box), child); }
    AppUsageInfo top_apps[5]; int app_count = 0;
    const char *sql_top_apps = "SELECT app_class, SUM(usage_seconds) FROM app_usage WHERE date = ? GROUP BY app_class ORDER BY SUM(usage_seconds) DESC LIMIT 5;";
    if (sqlite3_prepare_v2(db, sql_top_apps, -1, &stmt, 0) == SQLITE_OK) {
        sqlite3_bind_text(stmt, 1, selected_date_str, -1, SQLITE_STATIC);
        while (sqlite3_step(stmt) == SQLITE_ROW && app_count < 5) { strncpy(top_apps[app_count].app_class, (const char*)sqlite3_column_text(stmt, 0), 255); top_apps[app_count].seconds = sqlite3_column_int(stmt, 1); app_count++; }
    }
    sqlite3_finalize(stmt);
    long max_seconds = (app_count > 0) ? top_apps[0].seconds : 1; if (max_seconds == 0) max_seconds = 1;
    if (app_count == 0) { GtkWidget *placeholder = gtk_label_new("No activity recorded"); gtk_widget_add_css_class(placeholder, "dim-label"); gtk_widget_set_halign(placeholder, GTK_ALIGN_CENTER); gtk_widget_set_valign(placeholder, GTK_ALIGN_CENTER); gtk_widget_set_vexpand(placeholder, TRUE); gtk_box_append(GTK_BOX(data->top_apps_box), placeholder); }
    for (int i = 0; i < app_count; i++) {
        GtkWidget *row_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 3); GtkWidget *labels_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5); char* pretty_name = prettify_app_name(top_apps[i].app_class); GtkWidget *name_label = gtk_label_new(pretty_name); g_free(pretty_name); gtk_widget_set_hexpand(name_label, TRUE); gtk_widget_set_halign(name_label, GTK_ALIGN_START); char app_time_str[64]; long seconds = top_apps[i].seconds;
        if (seconds >= 3600) { snprintf(app_time_str, sizeof(app_time_str), "%ldh %ldm", seconds / 3600, (seconds % 3600) / 60); }
        else { snprintf(app_time_str, sizeof(app_time_str), "%ldm %lds", seconds / 60, seconds % 60); }
        GtkWidget *time_label = gtk_label_new(app_time_str); gtk_widget_add_css_class(time_label, "dim-label"); gtk_box_append(GTK_BOX(labels_hbox), name_label); gtk_box_append(GTK_BOX(labels_hbox), time_label); GtkWidget *bar = gtk_drawing_area_new(); gtk_widget_set_size_request(bar, -1, 8); CustomBarData *bar_data = g_new(CustomBarData, 1); bar_data->fraction = (double)top_apps[i].seconds / max_seconds; gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(bar), draw_custom_app_bar, bar_data, g_free); gtk_box_append(GTK_BOX(row_vbox), labels_hbox); gtk_box_append(GTK_BOX(row_vbox), bar); gtk_box_append(GTK_BOX(data->top_apps_box), row_vbox);
    }
    sqlite3_close(db);
    gtk_widget_queue_draw(data->chart_area);
    return G_SOURCE_CONTINUE;
}


// --- UI Callbacks ---
static void on_db_changed(GFileMonitor *monitor, GFile *file, GFile *other_file, GFileMonitorEvent event_type, gpointer user_data) {
    (void)monitor; (void)file; (void)other_file; (void)event_type;
    update_data_and_ui(user_data);
}
static void on_prev_week_clicked(GtkButton *button, gpointer user_data) { (void)button; AppData *data = (AppData *)user_data; g_date_subtract_days(data->reference_date, 7); g_date_free(data->selected_date); data->selected_date = g_date_copy(data->reference_date); update_data_and_ui(data); }
static void on_next_week_clicked(GtkButton *button, gpointer user_data) { (void)button; AppData *data = (AppData *)user_data; g_date_add_days(data->reference_date, 7); g_date_free(data->selected_date); data->selected_date = g_date_copy(data->reference_date); update_data_and_ui(data); }

static void on_chart_clicked(GtkGestureClick *gesture, int n_press, double x, double y, gpointer user_data) { 
    (void)gesture; (void)n_press; (void)y; 
    AppData *data = (AppData *)user_data; 
    int width = gtk_widget_get_width(data->chart_area); 
    double bar_width = (width - 6 * 10 - 40) / 7.0; 
    double bar_spacing = 10.0; 
    int clicked_index = -1; 
    for (int i = 0; i < 7; i++) { 
        double x_pos = 10 + i * (bar_width + bar_spacing); 
        if (x >= x_pos && x <= x_pos + bar_width) { 
            clicked_index = i; 
            break; 
        } 
    }
    if (clicked_index != -1) { 
        // ==============================================================================
        // === FIX BLOCK 2: Use the same consistent logic to find the clicked day. ===
        // ==============================================================================
        GDate *week_start = g_date_copy(data->reference_date); 
        g_date_subtract_days(week_start, g_date_get_weekday(week_start) % 7);
        g_date_add_days(week_start, clicked_index); 
        g_date_free(data->selected_date); 
        data->selected_date = week_start; 
        update_data_and_ui(data); 
    }
}

static GtkWidget* create_stat_box(const char* title, GtkWidget **title_label_ptr, GtkWidget **time_label_ptr) { GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5); *title_label_ptr = gtk_label_new(title); gtk_widget_set_halign(*title_label_ptr, GTK_ALIGN_START); gtk_box_append(GTK_BOX(vbox), *title_label_ptr); *time_label_ptr = gtk_label_new(NULL); gtk_label_set_markup(GTK_LABEL(*time_label_ptr), "<span size='x-large' weight='bold'>0h 0m</span>"); gtk_widget_set_halign(*time_label_ptr, GTK_ALIGN_START); gtk_box_append(GTK_BOX(vbox), *time_label_ptr); return vbox; }
static void on_widget_destroy(GtkWidget *widget, gpointer user_data) { (void)widget; AppData *data = (AppData *)user_data; if (data->timer_id > 0) { g_source_remove(data->timer_id); } g_date_free(data->today_date); g_date_free(data->selected_date); g_date_free(data->reference_date); }

// --- Plugin Entry Point ---
G_MODULE_EXPORT GtkWidget* create_widget(const char* config_string) {
    (void)config_string;
    AppData *app_data = g_new0(AppData, 1);
    app_data->today_date = g_date_new();
    g_date_set_time_t(app_data->today_date, time(NULL));
    app_data->selected_date = g_date_copy(app_data->today_date);
    app_data->reference_date = g_date_copy(app_data->today_date);
    GtkWidget *root_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 15);
    gtk_widget_set_name(root_vbox, "aurora-insight");
    gtk_widget_set_margin_start(root_vbox, 20);
    gtk_widget_set_margin_end(root_vbox, 20);
    gtk_widget_set_margin_top(root_vbox, 20);
    gtk_widget_set_margin_bottom(root_vbox, 15);
    g_signal_connect(root_vbox, "destroy", G_CALLBACK(on_widget_destroy), app_data);
    g_signal_connect_swapped(root_vbox, "destroy", G_CALLBACK(g_free), app_data);

    g_autofree gchar *trigger_path = g_build_filename(g_get_home_dir(), ".local", "share", "aurora-insight.trigger", NULL);
    GFile *trigger_file = g_file_new_for_path(trigger_path);
    GFileMonitor *monitor = g_file_monitor_file(trigger_file, G_FILE_MONITOR_NONE, NULL, NULL);
    if (monitor) {
        g_signal_connect(monitor, "changed", G_CALLBACK(on_db_changed), app_data);
        g_object_set_data_full(G_OBJECT(root_vbox), "db-monitor", monitor, g_object_unref);
    }
    g_object_unref(trigger_file);

    GtkWidget *main_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 25);
    gtk_widget_set_vexpand(main_hbox, TRUE);
    gtk_box_append(GTK_BOX(root_vbox), main_hbox);
    GtkWidget *chart_overlay = gtk_overlay_new();
    gtk_box_append(GTK_BOX(main_hbox), chart_overlay);
    app_data->chart_area = gtk_drawing_area_new();
    gtk_drawing_area_set_content_width(GTK_DRAWING_AREA(app_data->chart_area), 400);
    gtk_drawing_area_set_content_height(GTK_DRAWING_AREA(app_data->chart_area), 300);
    gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(app_data->chart_area), draw_chart, app_data, NULL);
    gtk_overlay_set_child(GTK_OVERLAY(chart_overlay), app_data->chart_area);
    GtkGesture *click = gtk_gesture_click_new();
    g_signal_connect(click, "pressed", G_CALLBACK(on_chart_clicked), app_data);
    gtk_widget_add_controller(app_data->chart_area, GTK_EVENT_CONTROLLER(click));
    GtkWidget *week_time_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_set_halign(week_time_box, GTK_ALIGN_START);
    gtk_widget_set_valign(week_time_box, GTK_ALIGN_START);
    gtk_widget_set_margin_start(week_time_box, 15);
    gtk_widget_set_margin_top(week_time_box, 10);
    gtk_overlay_add_overlay(GTK_OVERLAY(chart_overlay), week_time_box);
    app_data->week_time_label = gtk_label_new(NULL);
    gtk_label_set_markup(GTK_LABEL(app_data->week_time_label), "<span size='x-large' weight='bold'>0h 0m</span>");
    gtk_box_append(GTK_BOX(week_time_box), app_data->week_time_label);
    GtkWidget *right_frame = gtk_frame_new(NULL);
    gtk_box_append(GTK_BOX(main_hbox), right_frame);
    GtkWidget *right_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 15);
    gtk_widget_set_size_request(right_vbox, 280, -1);
    gtk_widget_set_margin_start(right_vbox, 5); gtk_widget_set_margin_end(right_vbox, 5);
    gtk_widget_set_margin_top(right_vbox, 5); gtk_widget_set_margin_bottom(right_vbox, 5);
    gtk_frame_set_child(GTK_FRAME(right_frame), right_vbox);
    GtkWidget *today_box = create_stat_box("Today", &app_data->selected_day_title_label, &app_data->today_time_label);
    gtk_box_append(GTK_BOX(right_vbox), today_box);
    gtk_box_append(GTK_BOX(right_vbox), gtk_separator_new(GTK_ORIENTATION_HORIZONTAL));
    GtkWidget *top_apps_title = gtk_label_new("Top Apps");
    gtk_widget_set_halign(top_apps_title, GTK_ALIGN_START); gtk_widget_add_css_class(top_apps_title, "dim-label");
    gtk_box_append(GTK_BOX(right_vbox), top_apps_title);
    GtkWidget *scrolled_window = gtk_scrolled_window_new();
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_window), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
    gtk_widget_set_vexpand(scrolled_window, TRUE);
    app_data->top_apps_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 12);
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_window), app_data->top_apps_box);
    gtk_box_append(GTK_BOX(right_vbox), scrolled_window);
    GtkWidget *bottom_nav_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 10);
    gtk_widget_add_css_class(bottom_nav_hbox, "bottom-nav");
    gtk_widget_set_halign(bottom_nav_hbox, GTK_ALIGN_CENTER);
    gtk_box_append(GTK_BOX(root_vbox), bottom_nav_hbox);
    GtkWidget *prev_week_button = gtk_button_new_from_icon_name("go-previous-symbolic");
    g_signal_connect(prev_week_button, "clicked", G_CALLBACK(on_prev_week_clicked), app_data);
    gtk_box_append(GTK_BOX(bottom_nav_hbox), prev_week_button);
    app_data->week_title_label = gtk_label_new("This Week");
    gtk_box_append(GTK_BOX(bottom_nav_hbox), app_data->week_title_label);
    app_data->next_week_button = gtk_button_new_from_icon_name("go-next-symbolic");
    g_signal_connect(app_data->next_week_button, "clicked", G_CALLBACK(on_next_week_clicked), app_data);
    gtk_box_append(GTK_BOX(bottom_nav_hbox), app_data->next_week_button);
    
    update_data_and_ui(app_data);
    app_data->timer_id = g_timeout_add_seconds(300, (GSourceFunc)update_data_and_ui, app_data); 
    
    return root_vbox;
}
static void draw_chart(GtkDrawingArea *area, cairo_t *cr, int width, int height, gpointer user_data) {
    AppData *data = (AppData *)user_data;
    GdkRGBA accent_color, foreground_color;
    get_css_color(GTK_WIDGET(area), "accent", &accent_color);
    get_css_color(GTK_WIDGET(area), "foreground", &foreground_color);
    const char *day_labels[7] = {"S", "M", "T", "W", "T", "F", "S"};
    int selected_wday = g_date_get_weekday(data->selected_date) % 7;
    double top_padding = 10.0, bottom_padding = 20.0, chart_height = height - top_padding - bottom_padding;
    double max_hours = 0; for (int i=0; i<7; i++) if (data->daily_hours[i] > max_hours) max_hours = data->daily_hours[i];
    max_hours = (max_hours < 4.0) ? 4.0 : (ceil(max_hours / 2.0) * 2.0);
    cairo_set_source_rgba(cr, foreground_color.red, foreground_color.green, foreground_color.blue, 0.5);
    cairo_set_font_size(cr, 12.0);
    for (int h = 0; h <= max_hours; h += 2) {
        if (max_hours <= 0) break;
        double y = top_padding + chart_height - (h / max_hours * chart_height);
        cairo_set_source_rgba(cr, foreground_color.red, foreground_color.green, foreground_color.blue, 0.1);
        cairo_set_line_width(cr, 1.0);
        char label_text[16]; snprintf(label_text, sizeof(label_text), "%dh", h);
        cairo_move_to(cr, width - 25, y + 4); cairo_show_text(cr, label_text);
        cairo_move_to(cr, 0, y); cairo_line_to(cr, width - 30, y); cairo_stroke(cr);
    }
    double bar_width = (width - 6 * 10 - 40) / 7.0; double bar_spacing = 10.0;

    // ==============================================================================
    // === FIX BLOCK 3: Use the same consistent logic to find the date for each bar. ===
    // ==============================================================================
    GDate *week_start_for_drawing = g_date_copy(data->reference_date);
    g_date_subtract_days(week_start_for_drawing, g_date_get_weekday(week_start_for_drawing) % 7);

    for (int i = 0; i < 7; i++) {
        double x_pos = 10 + i * (bar_width + bar_spacing);
        double bar_height_pixels = (max_hours > 0) ? (data->daily_hours[i] / max_hours) * chart_height : 0;
        
        GDate *bar_date = g_date_copy(week_start_for_drawing);
        g_date_add_days(bar_date, i);

        if (g_date_compare(bar_date, data->today_date) == 0) {
            cairo_set_source_rgba(cr, accent_color.red, accent_color.green, accent_color.blue, accent_color.alpha);
        } else {
            cairo_set_source_rgba(cr, accent_color.red, accent_color.green, accent_color.blue, 0.6);
        }
        g_date_free(bar_date);
        
        draw_rounded_bar(cr, x_pos, top_padding + chart_height - bar_height_pixels, bar_width, bar_height_pixels, 4.0);
        cairo_fill(cr);
        if (i == selected_wday) {
            cairo_set_source_rgba(cr, foreground_color.red, foreground_color.green, foreground_color.blue, 0.8);
            cairo_set_line_width(cr, 2.0);
            draw_rounded_bar(cr, x_pos, top_padding + chart_height - bar_height_pixels, bar_width, bar_height_pixels, 4.0);
            cairo_stroke(cr);
        }
        cairo_set_source_rgba(cr, foreground_color.red, foreground_color.green, foreground_color.blue, .7);
        cairo_move_to(cr, x_pos + (bar_width / 2) - 4, height - 5);
        cairo_show_text(cr, day_labels[i]);
    }
    g_date_free(week_start_for_drawing);
}
======================================================================
### FILE: ././widgets/insight/meson.build
======================================================================
# This file should start directly with the dependencies and target
gtk_dep = dependency('gtk4')
layershell_dep = dependency('gtk4-layer-shell-0')
sqlite_dep = dependency('sqlite3')
math_dep = cc.find_library('m', required : true)

shared_library('aurora-insight',
  'insight.c',
  dependencies : [
    gtk_dep,
    layershell_dep,
    sqlite_dep,
    math_dep
  ],
  name_prefix : '',
  install : true,
  install_dir : get_option('libdir') / 'aurora-shell/widgets'
)
======================================================================
### FILE: ././widgets/topbar/modules/bluetooth.c
======================================================================
#include <gtk/gtk.h>
#include <gio/gio.h>
#include "bluetooth.h"

typedef struct {
    GtkWidget *main_button;
    GtkWidget *content_box;
    GtkWidget *glyph_label;
    GtkWidget *text_label;
    GDBusObjectManager *bluez_manager;
} BluetoothModule;

// --- Forward Declarations ---
static void on_object_manager_created(GObject *source, GAsyncResult *res, gpointer user_data);
static void on_bluez_properties_changed(GDBusObjectManagerClient *manager, GDBusObjectProxy *object, GDBusProxy *interface, GVariant *changed_properties, const gchar *const *invalidated_properties, gpointer user_data);
static void update_bluetooth_status(BluetoothModule *module);
static void bluetooth_module_cleanup(gpointer data);


// =======================================================================
// THE UPGRADED UPDATE FUNCTION
// =======================================================================
static void update_bluetooth_status(BluetoothModule *module) {
    const char *HEADPHONE_ICON = "";
    gboolean is_powered = FALSE;
    g_autofree gchar *connected_device_name = NULL;
    gint battery_level = -1;

    if (!module->bluez_manager) { gtk_label_set_text(GTK_LABEL(module->text_label), "..."); return; }

    g_autoptr(GDBusInterface) adapter_interface = g_dbus_object_manager_get_interface(module->bluez_manager, "/org/bluez/hci0", "org.bluez.Adapter1");
    if (adapter_interface) {
        g_autoptr(GVariant) powered_var = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(adapter_interface), "Powered");
        if (powered_var) is_powered = g_variant_get_boolean(powered_var);
    }

    if (!is_powered) {
        gtk_label_set_text(GTK_LABEL(module->glyph_label), HEADPHONE_ICON);
        gtk_label_set_text(GTK_LABEL(module->text_label), " Disconnected");
        return;
    }

    g_autoptr(GList) devices = g_dbus_object_manager_get_objects(module->bluez_manager);
    for (GList *l = devices; l != NULL; l = l->next) {
        GDBusObject *obj = G_DBUS_OBJECT(l->data);
        g_autoptr(GDBusInterface) device_interface = g_dbus_object_get_interface(obj, "org.bluez.Device1");
        if (device_interface) {
            g_autoptr(GVariant) connected_var = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(device_interface), "Connected");
            if (connected_var && g_variant_get_boolean(connected_var)) {
                g_autoptr(GVariant) name_var = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(device_interface), "Name");
                if (name_var) connected_device_name = g_variant_dup_string(name_var, NULL);

                // --- THE FIX: Check for battery in two places ---
                // 1. First, try the "BatteryPercentage" property on the Device1 interface.
                g_autoptr(GVariant) battery_var_device = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(device_interface), "BatteryPercentage");
                if (battery_var_device) {
                    battery_level = g_variant_get_byte(battery_var_device);
                } else {
                    // 2. If that fails, check for a separate "Battery1" interface on the same object.
                    g_autoptr(GDBusInterface) battery_interface = g_dbus_object_get_interface(obj, "org.bluez.Battery1");
                    if (battery_interface) {
                        g_autoptr(GVariant) battery_var_battery = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(battery_interface), "Percentage");
                        if (battery_var_battery) {
                            battery_level = g_variant_get_byte(battery_var_battery);
                        }
                    }
                }
                break;
            }
        }
    }

    if (connected_device_name) {
        g_autofree gchar *final_text = NULL;
        if (battery_level != -1) final_text = g_strdup_printf(" %d%% %s", battery_level, connected_device_name);
        else final_text = g_strdup_printf(" %s", connected_device_name);
        gtk_label_set_text(GTK_LABEL(module->glyph_label), HEADPHONE_ICON);
        gtk_label_set_text(GTK_LABEL(module->text_label), final_text);
    } else {
        gtk_label_set_text(GTK_LABEL(module->glyph_label), HEADPHONE_ICON);
        gtk_label_set_text(GTK_LABEL(module->text_label), " Disconnected");
    }
}

// (The rest of the file is included below but is unchanged)
static void on_bluez_properties_changed(GDBusObjectManagerClient *manager, GDBusObjectProxy *object, GDBusProxy *interface, GVariant *changed_properties, const gchar *const *invalidated_properties, gpointer user_data) { (void)manager; (void)object; (void)interface; (void)changed_properties; (void)invalidated_properties; update_bluetooth_status((BluetoothModule *)user_data); }
static void on_object_manager_created(GObject *source, GAsyncResult *res, gpointer user_data) { (void)source; BluetoothModule *module = (BluetoothModule *)user_data; g_autoptr(GError) error = NULL; module->bluez_manager = g_dbus_object_manager_client_new_for_bus_finish(res, &error); if (error) { g_warning("Failed to create BlueZ D-Bus object manager: %s", error->message); gtk_label_set_text(GTK_LABEL(module->text_label), " Error"); return; } update_bluetooth_status(module); g_signal_connect(module->bluez_manager, "interface-proxy-properties-changed", G_CALLBACK(on_bluez_properties_changed), module); }
static void bluetooth_module_cleanup(gpointer data) { BluetoothModule *module = (BluetoothModule *)data; if (module->bluez_manager) g_object_unref(module->bluez_manager); g_free(module); }
GtkWidget* create_bluetooth_module() { BluetoothModule *module = g_new0(BluetoothModule, 1); module->main_button = gtk_button_new(); gtk_widget_add_css_class(module->main_button, "bluetooth-module"); gtk_widget_add_css_class(module->main_button, "module"); gtk_widget_add_css_class(module->main_button, "flat"); gtk_widget_add_css_class(module->main_button, "group-start"); module->content_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2); gtk_button_set_child(GTK_BUTTON(module->main_button), module->content_box); module->glyph_label = gtk_label_new(""); gtk_widget_add_css_class(module->glyph_label, "glyph-label"); module->text_label = gtk_label_new("..."); gtk_box_append(GTK_BOX(module->content_box), module->glyph_label); gtk_box_append(GTK_BOX(module->content_box), module->text_label); g_dbus_object_manager_client_new_for_bus( G_BUS_TYPE_SYSTEM, G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE, "org.bluez", "/", NULL, NULL, NULL, NULL, (GAsyncReadyCallback)on_object_manager_created, module ); g_object_set_data_full(G_OBJECT(module->main_button), "module-state", module, bluetooth_module_cleanup); return module->main_button; }
======================================================================
### FILE: ././widgets/topbar/modules/zen.c
======================================================================
#include <gtk/gtk.h>
#include <stdlib.h>
#include <stdio.h>
#include <gio/gio.h>
#include "zen.h"

typedef struct {
    GtkWidget *main_button;
    GtkWidget *content_box;
    GtkWidget *glyph_label;
    GtkWidget *text_label;
    gboolean current_ui_is_dnd;
} ZenModule;

// Struct to pass data from background thread to main thread
typedef struct {
    ZenModule *module;
    gboolean is_dnd;
} ZenUpdateData;

// --- Forward Declarations ---
static void update_zen_ui(ZenModule *module, gboolean is_dnd);
static void on_zen_clicked(GtkButton *button, gpointer user_data);
static gboolean on_zen_scroll(GtkEventControllerScroll* controller, double dx, double dy, gpointer user_data);
static void zen_module_cleanup(gpointer data);
static void check_zen_state(gpointer user_data);

static void update_zen_ui(ZenModule *module, gboolean is_dnd) {
    if (is_dnd) {
        gtk_label_set_text(GTK_LABEL(module->glyph_label), "");
        gtk_label_set_text(GTK_LABEL(module->text_label), " Zen");
        gtk_widget_add_css_class(module->main_button, "zen-active");
    } else {
        gtk_label_set_text(GTK_LABEL(module->glyph_label), "");
        gtk_label_set_text(GTK_LABEL(module->text_label), " Alert");
        gtk_widget_remove_css_class(module->main_button, "zen-active");
    }
    module->current_ui_is_dnd = is_dnd;
}

static void check_zen_state_thread(GTask *task, gpointer source_object, gpointer task_data, GCancellable *cancellable) {
    (void)task; (void)source_object; (void)cancellable; (void)task_data;
    FILE *fp = popen("swaync-client --get-dnd", "r");
    if (!fp) { g_task_return_pointer(task, GINT_TO_POINTER(-1), NULL); return; }
    char result[16]; gboolean is_dnd = FALSE;
    if (fgets(result, sizeof(result), fp) != NULL) { g_strstrip(result); is_dnd = (g_strcmp0(result, "true") == 0); }
    pclose(fp);
    g_task_return_pointer(task, GINT_TO_POINTER(is_dnd), NULL);
}

// THE FIX: This function runs on the main thread and safely updates the UI
static gboolean update_zen_ui_safe(gpointer user_data) {
    ZenUpdateData *data = (ZenUpdateData *)user_data;
    if (data->module->current_ui_is_dnd != data->is_dnd) {
        g_print("Zen module out of sync! Correcting UI.\n");
        update_zen_ui(data->module, data->is_dnd);
    }
    g_free(data); // Free the data packet
    return G_SOURCE_REMOVE;
}

static void on_check_state_finished(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    (void)source_object;
    ZenModule *module = (ZenModule*)user_data;
    gintptr actual_state_ptr = (gintptr)g_task_propagate_pointer(G_TASK(res), NULL);
    if (actual_state_ptr == -1) return;
    
    // THE FIX: Don't update UI directly. Schedule it on the main thread.
    ZenUpdateData *update_data = g_new(ZenUpdateData, 1);
    update_data->module = module;
    update_data->is_dnd = (gboolean)actual_state_ptr;
    g_idle_add(update_zen_ui_safe, update_data);
}

static void check_zen_state(gpointer user_data) {
    ZenModule *module = (ZenModule*)user_data;
    g_autoptr(GTask) task = g_task_new(module->main_button, NULL, on_check_state_finished, module);
    g_task_run_in_thread(task, check_zen_state_thread);
}

static void on_zen_clicked(GtkButton *button, gpointer user_data) {
    (void)button;
    ZenModule *module = (ZenModule*)user_data;
    update_zen_ui(module, !module->current_ui_is_dnd);
    system("swaync-client --toggle-dnd &");
    g_timeout_add_once(250, (GSourceOnceFunc)check_zen_state, module);
}

static gboolean on_zen_scroll(GtkEventControllerScroll* controller, double dx, double dy, gpointer user_data) {
    (void)controller; (void)dx;
    ZenModule *module = (ZenModule*)user_data;
    if (dy < 0) {
        update_zen_ui(module, !module->current_ui_is_dnd);
        system("swaync-client --toggle-dnd &");
        g_timeout_add_once(250, (GSourceOnceFunc)check_zen_state, module);
    } else if (dy > 0) {
        system("swaync-client --toggle-panel &");
    }
    return G_SOURCE_CONTINUE;
}

static void zen_module_cleanup(gpointer data) {
    g_free((ZenModule *)data);
}

GtkWidget* create_zen_module() {
    ZenModule *module = g_new0(ZenModule, 1);
    module->main_button = gtk_button_new();
    gtk_widget_add_css_class(module->main_button, "zen-module");
    gtk_widget_add_css_class(module->main_button, "module");
    gtk_widget_add_css_class(module->main_button, "flat");
    gtk_widget_add_css_class(module->main_button, "group-start");
    module->content_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
    gtk_button_set_child(GTK_BUTTON(module->main_button), module->content_box);
    module->glyph_label = gtk_label_new("?");
    gtk_widget_add_css_class(module->glyph_label, "glyph-label");
    module->text_label = gtk_label_new("...");
    gtk_box_append(GTK_BOX(module->content_box), module->glyph_label);
    gtk_box_append(GTK_BOX(module->content_box), module->text_label);
    g_signal_connect(module->main_button, "clicked", G_CALLBACK(on_zen_clicked), module);
    
    GtkEventController *scroll_controller = gtk_event_controller_scroll_new(GTK_EVENT_CONTROLLER_SCROLL_VERTICAL);
    g_signal_connect(scroll_controller, "scroll", G_CALLBACK(on_zen_scroll), module);
    gtk_widget_add_controller(module->main_button, scroll_controller);
    check_zen_state(module);
    g_object_set_data_full(G_OBJECT(module->main_button), "module-state", module, zen_module_cleanup);
    return module->main_button;
}
======================================================================
### FILE: ././widgets/topbar/modules/sysinfo.h
======================================================================
#ifndef SYSINFO_H
#define SYSINFO_H

#include <gtk/gtk.h>

GtkWidget* create_sysinfo_module();

#endif // SYSINFO_H
======================================================================
### FILE: ././widgets/topbar/modules/workspaces.c
======================================================================
#include <gtk/gtk.h>
#include <gio/gunixsocketaddress.h>
#include <json-glib/json-glib.h>
#include <stdlib.h>
#include "workspaces.h"

typedef struct {
    GtkWidget *box;
    GHashTable *workspace_buttons;
    gint current_active_id;
    GSocketConnection *event_connection;
    GDataInputStream *event_stream;
    GCancellable *cancellable; // THE FIX: Add a cancellable object.
} WorkspacesModule;

// --- Forward Declarations ---
static void add_workspace_button(WorkspacesModule *module, gint id);
static void remove_workspace_button(WorkspacesModule *module, gint id);
static void on_socket_connected(GObject *source, GAsyncResult *res, gpointer user_data);
static void on_hyprland_event(GObject *source, GAsyncResult *res, gpointer user_data);
static void workspaces_module_cleanup(gpointer data);

static void update_active_workspace_ui(WorkspacesModule *module, gint new_active_id) {
    if (module->current_active_id == new_active_id) return;
    GtkWidget *old_button = g_hash_table_lookup(module->workspace_buttons, GINT_TO_POINTER(module->current_active_id));
    if (old_button) gtk_widget_remove_css_class(old_button, "active-ws");
    GtkWidget *new_button = g_hash_table_lookup(module->workspace_buttons, GINT_TO_POINTER(new_active_id));
    if (new_button) gtk_widget_add_css_class(new_button, "active-ws");
    module->current_active_id = new_active_id;
}

static void on_workspace_button_clicked(GtkButton *button, gpointer data) {
    (void)button;
    gint id = GPOINTER_TO_INT(data);
    g_autofree gchar *command = g_strdup_printf("hyprctl dispatch workspace %d", id);
    system(command);
}

static void add_workspace_button(WorkspacesModule *module, gint id) {
    if (g_hash_table_lookup(module->workspace_buttons, GINT_TO_POINTER(id))) return;

    g_autofree gchar *label = g_strdup_printf("%d", id);
    GtkWidget *button = gtk_button_new_with_label(label);
    gtk_widget_add_css_class(button, "workspace-button");
    gtk_widget_add_css_class(button, "flat");
    
    g_object_set_data(G_OBJECT(button), "ws-id", GINT_TO_POINTER(id));
    g_signal_connect(button, "clicked", G_CALLBACK(on_workspace_button_clicked), GINT_TO_POINTER(id));
    
    gtk_box_append(GTK_BOX(module->box), button);
    g_hash_table_insert(module->workspace_buttons, GINT_TO_POINTER(id), button);

    GtkWidget *place_after = NULL;
    gint max_lower_id = -1;
    for (GtkWidget *child = gtk_widget_get_first_child(module->box); child != NULL; child = gtk_widget_get_next_sibling(child)) {
        if (child == button) continue;
        gint child_id = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(child), "ws-id"));
        if (child_id < id && child_id > max_lower_id) {
            max_lower_id = child_id;
            place_after = child;
        }
    }
    gtk_box_reorder_child_after(GTK_BOX(module->box), button, place_after);
}

static void remove_workspace_button(WorkspacesModule *module, gint id) {
    GtkWidget *button = g_hash_table_lookup(module->workspace_buttons, GINT_TO_POINTER(id));
    if (button) {
        g_hash_table_remove(module->workspace_buttons, GINT_TO_POINTER(id));
        gtk_widget_unparent(button);
    }
}

static void on_hyprland_event(GObject *source, GAsyncResult *res, gpointer user_data) {
    WorkspacesModule *module = (WorkspacesModule *)user_data;
    g_autoptr(GError) error = NULL;
    g_autofree gchar *line = g_data_input_stream_read_line_finish(module->event_stream, res, NULL, &error);
    
    // THE FIX: Handle cancellation and errors gracefully.
    if (g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
        g_info("Hyprland event listener cancelled. Exiting cleanly.");
        return; // Stop processing
    }
    if (error || !line) {
        g_warning("Error reading from Hyprland event socket: %s", error ? error->message : "No line received");
        return; // Stop trying to listen
    }
    
    if (g_str_has_prefix(line, "workspacev2>>")) {
        gchar **parts = g_strsplit(line, ">>", 2);
        if (parts[1]) {
            gchar **data_parts = g_strsplit(parts[1], ",", 2);
            if (data_parts[0]) update_active_workspace_ui(module, atoi(data_parts[0]));
            g_strfreev(data_parts);
        }
        g_strfreev(parts);
    } 
    else if (g_str_has_prefix(line, "createworkspacev2>>")) {
        gchar **parts = g_strsplit(line, ">>", 2);
        if (parts[1]) {
            gchar **data_parts = g_strsplit(parts[1], ",", 2);
            if (data_parts[0]) add_workspace_button(module, atoi(data_parts[0]));
            g_strfreev(data_parts);
        }
        g_strfreev(parts);
    }
    else if (g_str_has_prefix(line, "destroyworkspacev2>>")) {
        gchar **parts = g_strsplit(line, ">>", 2);
        if (parts[1]) {
            gchar **data_parts = g_strsplit(parts[1], ",", 2);
            if (data_parts[0]) remove_workspace_button(module, atoi(data_parts[0]));
            g_strfreev(data_parts);
        }
        g_strfreev(parts);
    }
    
    // THE FIX: Pass the cancellable to the next async read.
    g_data_input_stream_read_line_async(module->event_stream, G_PRIORITY_DEFAULT, module->cancellable, on_hyprland_event, module);
}

static void on_socket_connected(GObject *source, GAsyncResult *res, gpointer user_data) {
    WorkspacesModule *module = (WorkspacesModule *)user_data;
    g_autoptr(GError) error = NULL;
    module->event_connection = g_socket_client_connect_finish(G_SOCKET_CLIENT(source), res, &error);
    if (error) { g_warning("Failed to connect to event socket: %s", error->message); return; }
    g_print("Successfully connected to Hyprland event socket.\n");
    g_autoptr(GInputStream) istream = g_io_stream_get_input_stream(G_IO_STREAM(module->event_connection));
    module->event_stream = g_data_input_stream_new(istream);
    
    // THE FIX: Pass the cancellable to the first async read.
    g_data_input_stream_read_line_async(module->event_stream, G_PRIORITY_DEFAULT, module->cancellable, on_hyprland_event, module);
}

static void connect_to_event_socket(WorkspacesModule *module) {
    const gchar *instance_signature = getenv("HYPRLAND_INSTANCE_SIGNATURE");
    const gchar *xdg_runtime_dir = getenv("XDG_RUNTIME_DIR");
    if (!instance_signature || !xdg_runtime_dir) { g_warning("Hyprland environment variables not set."); return; }
    g_autofree gchar *socket_path = g_build_filename(xdg_runtime_dir, "hypr", instance_signature, ".socket2.sock", NULL);
    g_autoptr(GSocketClient) client = g_socket_client_new();
    g_autoptr(GSocketAddress) address = g_unix_socket_address_new(socket_path);
    // THE FIX: Pass the cancellable when connecting.
    g_socket_client_connect_async(client, G_SOCKET_CONNECTABLE(address), module->cancellable, on_socket_connected, module);
}

static gchar* run_command_and_get_output(const char* command) {
    FILE *fp = popen(command, "r");
    if (!fp) return NULL;
    gchar buffer[256]; GString *output_str = g_string_new("");
    while (fgets(buffer, sizeof(buffer), fp) != NULL) g_string_append(output_str, buffer);
    pclose(fp);
    return g_string_free(output_str, FALSE);
}

static void populate_initial_workspaces(WorkspacesModule *module) {
    g_autoptr(JsonParser) parser = json_parser_new();
    g_autofree gchar *workspaces_json = run_command_and_get_output("hyprctl -j workspaces");
    if (!workspaces_json || !json_parser_load_from_data(parser, workspaces_json, -1, NULL)) return;
    JsonArray *workspaces_array = json_node_get_array(json_parser_get_root(parser));
    for (guint i = 0; i < json_array_get_length(workspaces_array); i++) {
        JsonObject *ws = json_array_get_object_element(workspaces_array, i);
        gint id = json_object_get_int_member(ws, "id");
        if (id > 0) add_workspace_button(module, id);
    }
    g_autofree gchar *active_json = run_command_and_get_output("hyprctl -j activeworkspace");
    if (!active_json || !json_parser_load_from_data(parser, active_json, -1, NULL)) return;
    JsonObject *active_ws = json_node_get_object(json_parser_get_root(parser));
    gint active_id = json_object_get_int_member(active_ws, "id");
    if (active_id != -1) update_active_workspace_ui(module, active_id);
}

static void workspaces_module_cleanup(gpointer data) {
    WorkspacesModule *module = (WorkspacesModule *)data;
    
    // THE FIX: Cancel the background tasks BEFORE freeing anything.
    if (module->cancellable) {
        g_cancellable_cancel(module->cancellable);
    }

    g_hash_table_destroy(module->workspace_buttons);
    if (module->event_stream) g_object_unref(module->event_stream);
    if (module->event_connection) g_object_unref(module->event_connection);
    
    // THE FIX: Unref the cancellable itself.
    if (module->cancellable) {
        g_object_unref(module->cancellable);
    }
    
    g_free(module);
}

GtkWidget* create_workspaces_module() {
    WorkspacesModule *module = g_new0(WorkspacesModule, 1);
    // THE FIX: Create the cancellable object.
    module->cancellable = g_cancellable_new();
    
    module->box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_add_css_class(module->box, "workspace-module");
    gtk_widget_add_css_class(module->box, "module");
    module->workspace_buttons = g_hash_table_new(NULL, NULL);
    g_object_set_data_full(G_OBJECT(module->box), "module-state", module, workspaces_module_cleanup);
    populate_initial_workspaces(module);
    connect_to_event_socket(module);
    return module->box;
}
======================================================================
### FILE: ././widgets/topbar/modules/audio.c
======================================================================
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <stdlib.h> // For system()
#include "audio.h"

// Struct to hold info about a single audio sink
typedef struct {
    uint32_t id;
    gchar *description;
} AudioSink;

typedef struct {
    GtkWidget *main_button;
    GtkWidget *content_box;
    GtkWidget *glyph_label;
    GtkWidget *text_label;
    GDBusObjectManager *bluez_manager;
    GtkWidget *popover;
    GtkWidget *sink_list_box;
} AudioModule;

// --- Forward Declarations ---
static void on_module_clicked(GtkButton *button, gpointer user_data);
static void update_bluetooth_status(AudioModule *module);
static void on_object_manager_created(GObject *source, GAsyncResult *res, gpointer user_data);
static void audio_module_cleanup(gpointer data);

static void audio_sink_free(gpointer data) {
    AudioSink *sink = (AudioSink*)data;
    g_free(sink->description);
    g_free(sink);
}


// =======================================================================
// NEW: The Glyph Helper Function
// This function inspects the sink description and returns a glyph.
// =======================================================================
static const char* get_glyph_for_sink(const gchar* description) {
    if (!description) return ""; // audio-description-symbolic (fallback)

    // Case-insensitive search is more robust
    g_autofree gchar *lower_desc = g_ascii_strdown(description, -1);

    // Bluetooth Devices (Headphones, Headsets, Earbuds)
    if (strstr(lower_desc, "bluez") || strstr(lower_desc, "earphone") || 
        strstr(lower_desc, "headphone") || strstr(lower_desc, "headset") ||
        strstr(lower_desc, "soundcore") || strstr(lower_desc, "r50i")) {
        return ""; // headphones-symbolic
    }
    // Phone
    if (strstr(lower_desc, "phone")) {
        return ""; // cellphone-symbolic
    }
    // Speakers / Built-in Audio
    if (strstr(lower_desc, "speaker") || strstr(lower_desc, "built-in") || 
        strstr(lower_desc, "analog")) {
        return ""; // audio-volume-high-symbolic
    }
    // Loopback devices
    if (strstr(lower_desc, "loopback")) {
        return ""; // object-rotate-right-symbolic (sync/loop icon)
    }

    // Default fallback
    return "";
}


// --- UI Functions ---

static void on_sink_button_clicked(GtkButton *button, gpointer data) {
    AudioSink *sink = (AudioSink*)data;
    g_autofree gchar *command = g_strdup_printf("wpctl set-default %u", sink->id);
    system(command);
    
    GtkPopover* popover = GTK_POPOVER(gtk_widget_get_ancestor(GTK_WIDGET(button), GTK_TYPE_POPOVER));
    if (popover) gtk_popover_popdown(popover);
}

// UPGRADED: This function now builds the richer list item with a glyph
static void update_sink_list_ui(AudioModule *module) {
    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(module->sink_list_box))) {
        gtk_box_remove(GTK_BOX(module->sink_list_box), child);
    }

    FILE *fp = popen("wpctl status | awk '/Sinks:/, /Sources:/' | grep -E '[0-9]+\\.' | sed -e 's/[]//g' -e 's/ \\[[^]]*\\]//'", "r");
    if (!fp) return;

    gint current_sink_id = -1;
    FILE *fp_default = popen("wpctl status | awk '/Default Sink:/ {print $3}'", "r");
    if (fp_default) { char id_buf[16]; if (fgets(id_buf, sizeof(id_buf), fp_default)) current_sink_id = atoi(id_buf); pclose(fp_default); }

    char line[256];
    while (fgets(line, sizeof(line), fp)) {
        gboolean is_default = FALSE;
        char* current_pos = line;
        while (g_ascii_isspace(*current_pos)) current_pos++;
        if (*current_pos == '*') { is_default = TRUE; current_pos++; while (g_ascii_isspace(*current_pos)) current_pos++; }
        
        char *id_str = strtok(current_pos, ".");
        char *desc_str = strtok(NULL, "");

        if (id_str && desc_str) {
            g_strstrip(desc_str);
            
            AudioSink *sink = g_new0(AudioSink, 1);
            sink->id = atoi(id_str);
            sink->description = g_strdup(desc_str);
            
            // --- NEW: Create a richer button ---
            GtkWidget *button = gtk_button_new();
            gtk_widget_add_css_class(button, "sink-button");
            gtk_widget_add_css_class(button, "flat");

            GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
            gtk_button_set_child(GTK_BUTTON(button), box);

            const char* glyph = get_glyph_for_sink(sink->description);
            GtkWidget *glyph_label = gtk_label_new(glyph);
            gtk_widget_add_css_class(glyph_label, "glyph-label");
            
            GtkWidget *desc_label = gtk_label_new(sink->description);
            gtk_label_set_xalign(GTK_LABEL(desc_label), 0.0);
            gtk_widget_set_hexpand(desc_label, TRUE);

            gtk_box_append(GTK_BOX(box), glyph_label);
            gtk_box_append(GTK_BOX(box), desc_label);
            // --- End of new button creation ---

            if (is_default) gtk_widget_add_css_class(button, "active-sink");

            g_object_set_data_full(G_OBJECT(button), "sink-data", sink, audio_sink_free);
            g_signal_connect(button, "clicked", G_CALLBACK(on_sink_button_clicked), sink);
            gtk_box_append(GTK_BOX(module->sink_list_box), button);
        }
    }
    pclose(fp);
}

// (The rest of the file is unchanged)
static void on_module_clicked(GtkButton *button, gpointer user_data) { (void)button; AudioModule *module = (AudioModule *)user_data; update_sink_list_ui(module); gtk_popover_popup(GTK_POPOVER(module->popover)); }
static void on_bluez_properties_changed(GDBusObjectManagerClient *m, GDBusObjectProxy *o, GDBusProxy *i, GVariant *c, const gchar *const *iv, gpointer d) { (void)m; (void)o; (void)i; (void)c; (void)iv; update_bluetooth_status((AudioModule*)d); }
static void on_object_manager_created(GObject *s, GAsyncResult *r, gpointer d) { (void)s; AudioModule *m = (AudioModule*)d; g_autoptr(GError) e = NULL; m->bluez_manager = g_dbus_object_manager_client_new_for_bus_finish(r, &e); if (e) return; update_bluetooth_status(m); g_signal_connect(m->bluez_manager, "interface-proxy-properties-changed", G_CALLBACK(on_bluez_properties_changed), m); }
static void update_bluetooth_status(AudioModule *module) { const char *HEADPHONE_ICON = ""; gboolean is_powered = FALSE; g_autofree gchar *connected_device_name = NULL; gint battery_level = -1; if (!module->bluez_manager) { return; } g_autoptr(GDBusInterface) adapter_interface = g_dbus_object_manager_get_interface(module->bluez_manager, "/org/bluez/hci0", "org.bluez.Adapter1"); if (adapter_interface) { g_autoptr(GVariant) powered_var = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(adapter_interface), "Powered"); if (powered_var) is_powered = g_variant_get_boolean(powered_var); } if (!is_powered) { gtk_label_set_text(GTK_LABEL(module->glyph_label), HEADPHONE_ICON); gtk_label_set_text(GTK_LABEL(module->text_label), " Disconnected"); return; } g_autoptr(GList) devices = g_dbus_object_manager_get_objects(module->bluez_manager); for (GList *l = devices; l != NULL; l = l->next) { GDBusObject *obj = G_DBUS_OBJECT(l->data); g_autoptr(GDBusInterface) device_interface = g_dbus_object_get_interface(obj, "org.bluez.Device1"); if (device_interface) { g_autoptr(GVariant) connected_var = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(device_interface), "Connected"); if (connected_var && g_variant_get_boolean(connected_var)) { g_autoptr(GVariant) name_var = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(device_interface), "Name"); if (name_var) connected_device_name = g_variant_dup_string(name_var, NULL); g_autoptr(GVariant) battery_var_device = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(device_interface), "BatteryPercentage"); if (battery_var_device) { battery_level = g_variant_get_byte(battery_var_device); } else { g_autoptr(GDBusInterface) battery_interface = g_dbus_object_get_interface(obj, "org.bluez.Battery1"); if (battery_interface) { g_autoptr(GVariant) battery_var_battery = g_dbus_proxy_get_cached_property(G_DBUS_PROXY(battery_interface), "Percentage"); if (battery_var_battery) { battery_level = g_variant_get_byte(battery_var_battery); } } } break; } } } if (connected_device_name) { g_autofree gchar *final_text = NULL; if (battery_level != -1) final_text = g_strdup_printf(" %d%% %s", battery_level, connected_device_name); else final_text = g_strdup_printf(" %s", connected_device_name); gtk_label_set_text(GTK_LABEL(module->glyph_label), HEADPHONE_ICON); gtk_label_set_text(GTK_LABEL(module->text_label), final_text); } else { gtk_label_set_text(GTK_LABEL(module->glyph_label), HEADPHONE_ICON); gtk_label_set_text(GTK_LABEL(module->text_label), " Disconnected"); } }
static void audio_module_cleanup(gpointer data) { AudioModule *module = (AudioModule *)data; if (module->bluez_manager) g_object_unref(module->bluez_manager); g_free(module); }
GtkWidget* create_audio_module() { AudioModule *module = g_new0(AudioModule, 1); module->main_button = gtk_button_new(); gtk_widget_add_css_class(module->main_button, "audio-module"); gtk_widget_add_css_class(module->main_button, "module"); gtk_widget_add_css_class(module->main_button, "flat"); module->content_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2); gtk_button_set_child(GTK_BUTTON(module->main_button), module->content_box); module->glyph_label = gtk_label_new(""); gtk_widget_add_css_class(module->glyph_label, "glyph-label"); module->text_label = gtk_label_new("..."); gtk_box_append(GTK_BOX(module->content_box), module->glyph_label); gtk_box_append(GTK_BOX(module->content_box), module->text_label); module->popover = gtk_popover_new(); gtk_widget_set_parent(module->popover, module->main_button); module->sink_list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 4); gtk_widget_add_css_class(module->sink_list_box, "sink-list-popover"); gtk_popover_set_child(GTK_POPOVER(module->popover), module->sink_list_box); g_signal_connect(module->main_button, "clicked", G_CALLBACK(on_module_clicked), module); g_dbus_object_manager_client_new_for_bus( G_BUS_TYPE_SYSTEM, G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE, "org.bluez", "/", NULL, NULL, NULL, NULL, (GAsyncReadyCallback)on_object_manager_created, module ); g_object_set_data_full(G_OBJECT(module->main_button), "module-state", module, audio_module_cleanup); return module->main_button; }
======================================================================
### FILE: ././widgets/topbar/modules/workspaces.h
======================================================================
#ifndef WORKSPACES_H
#define WORKSPACES_H

#include <gtk/gtk.h>

GtkWidget* create_workspaces_module();

#endif // WORKSPACES_H
======================================================================
### FILE: ././widgets/topbar/modules/bluetooth.h
======================================================================
#ifndef BLUETOOTH_H
#define BLUETOOTH_H

#include <gtk/gtk.h>

GtkWidget* create_bluetooth_module();

#endif // BLUETOOTH_H
======================================================================
### FILE: ././widgets/topbar/modules/audio.h
======================================================================
#ifndef AUDIO_H
#define AUDIO_H

#include <gtk/gtk.h>

GtkWidget* create_audio_module();

#endif // AUDIO_H
======================================================================
### FILE: ././widgets/topbar/modules/sysinfo.c
======================================================================
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include "sysinfo.h"

typedef struct {
    GtkWidget *main_button;
    GtkWidget *content_box;
    GtkWidget *cpu_glyph_label, *cpu_label;
    GtkWidget *ram_glyph_label, *ram_label;
    GtkWidget *temp_glyph_label, *temp_label;
    GtkWidget *battery_glyph_label, *battery_label;
    gulong last_total, last_idle;
    guint poll_timer_id;
    GDBusProxy *battery_proxy;
    guint upower_watcher_id;
    gchar *temp_file_path;
} SysInfoModule;

// --- Forward Declarations ---
static void update_battery_widget(SysInfoModule *module, gdouble percentage, guint state);
static void on_battery_properties_changed(GDBusProxy *proxy, GVariant *changed_properties, const gchar *const *invalidated, gpointer user_data);
static void on_battery_proxy_created(GObject *source_object, GAsyncResult *res, gpointer user_data);
static void on_upower_appeared(GDBusConnection *c, const gchar *n, const gchar *o, gpointer d);
static void on_upower_vanished(GDBusConnection *c, const gchar *n, gpointer d);
static void update_cpu_usage(SysInfoModule *module);
static void update_ram_usage(SysInfoModule *module);
static void find_and_update_temp(SysInfoModule *module);
static gboolean on_poll_timeout(gpointer user_data);
static void sysinfo_module_cleanup(gpointer data);

// =======================================================================
// THE MISSING FUNCTION IS RESTORED HERE
// =======================================================================
static gboolean on_poll_timeout(gpointer user_data) {
    SysInfoModule *module = (SysInfoModule *)user_data;
    update_cpu_usage(module);
    update_ram_usage(module);
    find_and_update_temp(module);
    return G_SOURCE_CONTINUE; // Keep the timer running
}

// (The rest of the file is now correct)

static void update_battery_widget(SysInfoModule *module, gdouble percentage, guint state) { g_autofree gchar *label_text = g_strdup_printf("%.0f%%", percentage); gtk_label_set_text(GTK_LABEL(module->battery_label), label_text); const char *glyph; if (state == 1) { glyph = ""; } else { if (percentage > 95) glyph = ""; else if (percentage > 80) glyph = ""; else if (percentage > 60) glyph = ""; else if (percentage > 40) glyph = ""; else if (percentage > 20) glyph = ""; else glyph = ""; } gtk_label_set_text(GTK_LABEL(module->battery_glyph_label), glyph); }
static void on_battery_properties_changed(GDBusProxy *proxy, GVariant *changed_properties, const gchar *const *invalidated, gpointer user_data) { (void)changed_properties; (void)invalidated; SysInfoModule *module = (SysInfoModule *)user_data; gdouble percentage = 0.0; guint state = 0; g_autoptr(GVariant) percentage_var = g_dbus_proxy_get_cached_property(proxy, "Percentage"); if (percentage_var) percentage = g_variant_get_double(percentage_var); g_autoptr(GVariant) state_var = g_dbus_proxy_get_cached_property(proxy, "State"); if (state_var) state = g_variant_get_uint32(state_var); update_battery_widget(module, percentage, state); }
static void on_battery_proxy_created(GObject *source_object, GAsyncResult *res, gpointer user_data) { (void)source_object; SysInfoModule *module = (SysInfoModule *)user_data; g_autoptr(GError) error = NULL; module->battery_proxy = g_dbus_proxy_new_for_bus_finish(res, &error); if (module->battery_proxy) { g_signal_connect(module->battery_proxy, "g-properties-changed", G_CALLBACK(on_battery_properties_changed), module); on_battery_properties_changed(module->battery_proxy, NULL, NULL, module); } }
static void on_upower_appeared(GDBusConnection *c, const gchar *n, const gchar *o, gpointer d) { (void)c; (void)n; (void)o; g_dbus_proxy_new_for_bus(G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL, "org.freedesktop.UPower", "/org/freedesktop/UPower/devices/DisplayDevice", "org.freedesktop.UPower.Device", NULL, (GAsyncReadyCallback)on_battery_proxy_created, d); }
static void on_upower_vanished(GDBusConnection *c, const gchar *n, gpointer d) { (void)c; (void)n; SysInfoModule *module = (SysInfoModule *)d; g_clear_object(&module->battery_proxy); gtk_label_set_text(GTK_LABEL(module->battery_label), "N/A"); gtk_label_set_text(GTK_LABEL(module->battery_glyph_label), "?"); }
static void update_cpu_usage(SysInfoModule *module) { FILE* fp = fopen("/proc/stat", "r"); if (!fp) return; gulong user, nice, system, idle, iowait, irq, softirq, steal; if (fscanf(fp, "cpu %lu %lu %lu %lu %lu %lu %lu %lu", &user, &nice, &system, &idle, &iowait, &irq, &softirq, &steal) < 8) { fclose(fp); return; } fclose(fp); gulong current_idle = idle + iowait; gulong current_total = user + nice + system + current_idle + irq + softirq + steal; if (module->last_total > 0) { gulong total_diff = current_total - module->last_total; gulong idle_diff = current_idle - module->last_idle; double usage = 100.0 * (total_diff - idle_diff) / total_diff; g_autofree gchar *label = g_strdup_printf("%.0f%%", usage); gtk_label_set_text(GTK_LABEL(module->cpu_label), label); } module->last_total = current_total; module->last_idle = current_idle; }
static void update_ram_usage(SysInfoModule *module) { FILE* fp = fopen("/proc/meminfo", "r"); if (!fp) return; long mem_total = 0, mem_available = 0; char line[128]; while (fgets(line, sizeof(line), fp)) { if (sscanf(line, "MemTotal: %ld kB", &mem_total) == 1) {} if (sscanf(line, "MemAvailable: %ld kB", &mem_available) == 1) {} if (mem_total > 0 && mem_available > 0) break; } fclose(fp); if (mem_total > 0) { double usage = 100.0 * (mem_total - mem_available) / mem_total; g_autofree gchar *label = g_strdup_printf("%.0f%%", usage); gtk_label_set_text(GTK_LABEL(module->ram_label), label); } }
static void find_and_update_temp(SysInfoModule *module) { if (module->temp_file_path && g_file_test(module->temp_file_path, G_FILE_TEST_EXISTS)) { FILE* fp = fopen(module->temp_file_path, "r"); if (fp) { long temp_mc = 0; fscanf(fp, "%ld", &temp_mc); fclose(fp); g_autofree gchar *label = g_strdup_printf("%ldC", temp_mc / 1000); gtk_label_set_text(GTK_LABEL(module->temp_label), label); return; } } g_free(module->temp_file_path); module->temp_file_path = NULL; const char *hwmon_dir_path = "/sys/class/hwmon"; DIR *hwmon_dir = opendir(hwmon_dir_path); if (!hwmon_dir) { gtk_label_set_text(GTK_LABEL(module->temp_label), "N/A"); return; } struct dirent *hwmon_entry; while ((hwmon_entry = readdir(hwmon_dir)) != NULL) { if (g_str_has_prefix(hwmon_entry->d_name, "hwmon")) { g_autofree gchar *mon_path = g_build_filename(hwmon_dir_path, hwmon_entry->d_name, NULL); DIR *mon_dir = opendir(mon_path); if (!mon_dir) continue; struct dirent *sub_entry; while ((sub_entry = readdir(mon_dir)) != NULL) { if (g_str_has_prefix(sub_entry->d_name, "temp") && g_str_has_suffix(sub_entry->d_name, "_input")) { g_autofree gchar *input_path = g_build_filename(mon_path, sub_entry->d_name, NULL); g_autofree gchar *label_path_builder = g_strdup(input_path); gchar *suffix_pos = strstr(label_path_builder, "_input"); if (suffix_pos) { *suffix_pos = '\0'; } g_autofree gchar *label_path = g_strconcat(label_path_builder, "_label", NULL); if (g_file_test(label_path, G_FILE_TEST_EXISTS)) { g_autofree gchar *label_content = NULL; g_file_get_contents(label_path, &label_content, NULL, NULL); if (label_content) { label_content = g_strstrip(label_content); if (g_strcmp0(label_content, "Tdie") == 0 || g_strcmp0(label_content, "Tctl") == 0 || g_strcmp0(label_content, "Package id 0") == 0) { module->temp_file_path = g_strdup(input_path); closedir(mon_dir); closedir(hwmon_dir); find_and_update_temp(module); return; } } } else { module->temp_file_path = g_strdup(input_path); closedir(mon_dir); closedir(hwmon_dir); find_and_update_temp(module); return; } } } closedir(mon_dir); } } closedir(hwmon_dir); gtk_label_set_text(GTK_LABEL(module->temp_label), "N/A"); }
static void sysinfo_module_cleanup(gpointer data) { SysInfoModule *module = (SysInfoModule *)data; if (module->poll_timer_id > 0) g_source_remove(module->poll_timer_id); if (module->upower_watcher_id > 0) g_bus_unwatch_name(module->upower_watcher_id); g_clear_object(&module->battery_proxy); g_free(module->temp_file_path); g_free(module); }
static void create_info_item(GtkWidget *parent_box, const char *glyph_str, const char* placeholder, GtkWidget **glyph_widget, GtkWidget **label_widget) { *glyph_widget = gtk_label_new(glyph_str); gtk_widget_add_css_class(*glyph_widget, "glyph-label"); *label_widget = gtk_label_new(placeholder); gtk_box_append(GTK_BOX(parent_box), *glyph_widget); gtk_box_append(GTK_BOX(parent_box), *label_widget); }

GtkWidget* create_sysinfo_module() {
    SysInfoModule *module = g_new0(SysInfoModule, 1);
    module->main_button = gtk_button_new();
    gtk_widget_add_css_class(module->main_button, "sysinfo-module");
    gtk_widget_add_css_class(module->main_button, "module");
    gtk_widget_add_css_class(module->main_button, "flat");
    module->content_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4);
    gtk_widget_add_css_class(module->content_box, "content-box");
    gtk_button_set_child(GTK_BUTTON(module->main_button), module->content_box);
    create_info_item(module->content_box, "", "0%", &module->cpu_glyph_label, &module->cpu_label);
    create_info_item(module->content_box, "", "0%", &module->ram_glyph_label, &module->ram_label);
    create_info_item(module->content_box, "", "0C", &module->temp_glyph_label, &module->temp_label);
    create_info_item(module->content_box, "", "0%", &module->battery_glyph_label, &module->battery_label);
    module->upower_watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM, "org.freedesktop.UPower", G_BUS_NAME_WATCHER_FLAGS_NONE, on_upower_appeared, on_upower_vanished, module, NULL);
    on_poll_timeout(module);
    module->poll_timer_id = g_timeout_add_seconds(2, on_poll_timeout, module);
    g_object_set_data_full(G_OBJECT(module->main_button), "module-state", module, sysinfo_module_cleanup);
    return module->main_button;
}
======================================================================
### FILE: ././widgets/topbar/modules/zen.h
======================================================================
#ifndef ZEN_H
#define ZEN_H

#include <gtk/gtk.h>

GtkWidget* create_zen_module();

#endif // ZEN_H
======================================================================
### FILE: ././widgets/topbar/topbar.c
======================================================================
#include <gtk/gtk.h>
#include <json-glib/json-glib.h>
#include <stdlib.h>
#include <time.h>
#include "topbar.h"
#include "modules/sysinfo.h"
#include "modules/workspaces.h"
#include "modules/audio.h"
#include "modules/zen.h"

typedef struct {
    GtkWidget *clock_label;
    guint clock_timer_id;
} TopbarState;

static void load_module(JsonObject *module_config, TopbarState *state, GtkBox *target_box);
static gboolean update_clock(gpointer user_data);
static void topbar_cleanup(gpointer user_data);
static void on_generic_module_clicked(GtkButton *button, gpointer user_data);
static GtkWidget* create_popover_module(JsonObject *config);
static void free_string_data(gpointer data, GClosure *closure);
static void on_popover_button_clicked(GtkButton *button, gpointer user_data);

static void free_string_data(gpointer data, GClosure *closure) {
    (void)closure;
    g_free(data);
}

static void on_generic_module_clicked(GtkButton *button, gpointer user_data) {
    (void)button;
    const char *command = (const char *)user_data;
    if (command && *command) {
        g_info("Executing on-click command: [%s]", command);
        g_spawn_command_line_async(command, NULL);
    }
}

static void on_popover_button_clicked(GtkButton *button, gpointer user_data) {
    (void)button;
    GtkWidget *popover = GTK_WIDGET(user_data);
    gtk_popover_popup(GTK_POPOVER(popover));
}

static gboolean update_clock(gpointer user_data) {
    TopbarState *state = (TopbarState *)user_data;
    time_t raw_time;
    struct tm *time_info;
    char buffer[64];
    time(&raw_time);
    time_info = localtime(&raw_time);
    strftime(buffer, sizeof(buffer), "%d/%m/%Y %I:%M %p", time_info);
    gtk_label_set_text(GTK_LABEL(state->clock_label), buffer);
    return G_SOURCE_CONTINUE;
}

static void topbar_cleanup(gpointer data) {
    TopbarState *state = (TopbarState *)data;
    if (state->clock_timer_id > 0) {
        g_source_remove(state->clock_timer_id);
    }
    g_free(state);
}

static GtkWidget* create_popover_module(JsonObject *config) {
    const char *symbol = json_object_get_string_member_with_default(config, "symbol", "?");
    
    GtkWidget *button = gtk_button_new_with_label(symbol);
    gtk_widget_add_css_class(button, "popover-module");

    const char *name = json_object_get_string_member(config, "name");
    if (name) {
        gtk_widget_add_css_class(button, name);
    }

    GtkWidget *popover = gtk_popover_new();
    gtk_widget_set_parent(popover, button);

    GtkWidget *list_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_popover_set_child(GTK_POPOVER(popover), list_box);

    if (json_object_has_member(config, "items")) {
        JsonArray *items_array = json_object_get_array_member(config, "items");
        for (guint i = 0; i < json_array_get_length(items_array); i++) {
            JsonObject *item_obj = json_array_get_object_element(items_array, i);
            if (!item_obj) continue;

            const char *label = json_object_get_string_member_with_default(item_obj, "label", "No Label");
            const char *command = json_object_get_string_member(item_obj, "on-click");
            const char* glyph = json_object_get_string_member(item_obj, "glyph");

            GtkWidget *item_button = gtk_button_new();
            gtk_widget_add_css_class(item_button, "popover-item");
            gtk_widget_add_css_class(item_button, "flat");

            GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
            gtk_button_set_child(GTK_BUTTON(item_button), box);

            if (glyph) {
                GtkWidget *glyph_label = gtk_label_new(glyph);
                gtk_widget_add_css_class(glyph_label, "glyph-label");
                gtk_box_append(GTK_BOX(box), glyph_label);
            }

            GtkWidget *desc_label = gtk_label_new(label);
            gtk_label_set_xalign(GTK_LABEL(desc_label), 0.0);
            gtk_widget_set_hexpand(desc_label, TRUE);
            gtk_box_append(GTK_BOX(box), desc_label);

            if (command) {
                g_signal_connect_data(item_button, "clicked", G_CALLBACK(on_generic_module_clicked), 
                                      g_strdup(command), free_string_data, 0);
            }
            gtk_box_append(GTK_BOX(list_box), item_button);
        }
    }
    
    g_signal_connect(button, "clicked", G_CALLBACK(on_popover_button_clicked), popover);
    g_object_set_data_full(G_OBJECT(button), "popover", popover, g_object_unref);

    return button;
}

static void load_module(JsonObject *module_config, TopbarState *state, GtkBox *target_box) {
    GtkWidget *module_widget = NULL;

    // THE FIX: Add a check here to prevent the Json-CRITICAL error
    if (!module_config) {
        return;
    }
    
    const char *module_type = json_object_get_string_member(module_config, "type");
    
    if (module_type && g_strcmp0(module_type, "popover") == 0) {
        module_widget = create_popover_module(module_config);
    } else {
        const char *module_name = json_object_get_string_member(module_config, "name");
        if (!module_name) return;

        if (g_strcmp0(module_name, "clock") == 0) {
            GtkWidget *button = gtk_button_new(); gtk_widget_add_css_class(button, "clock-module");
            state->clock_label = gtk_label_new(""); gtk_button_set_child(GTK_BUTTON(button), state->clock_label);
            update_clock(state); state->clock_timer_id = g_timeout_add_seconds(1, update_clock, state);
            module_widget = button;
        } else if (g_strcmp0(module_name, "workspaces") == 0) {
            module_widget = create_workspaces_module();
        } else if (g_strcmp0(module_name, "sysinfo") == 0) {
            module_widget = create_sysinfo_module();
        } else if (g_strcmp0(module_name, "audio") == 0) {
            module_widget = create_audio_module();
        } else if (g_strcmp0(module_name, "zen") == 0) {
            module_widget = create_zen_module();
        }
    }
    
    if (module_widget) {
        if (json_object_has_member(module_config, "on-click")) {
            if (GTK_IS_BUTTON(module_widget)) {
                const char *cmd = json_object_get_string_member(module_config, "on-click");
                g_signal_connect_data(module_widget, "clicked", G_CALLBACK(on_generic_module_clicked), 
                                      g_strdup(cmd), free_string_data, 0);
            } else { g_warning("Module has 'on-click' but is not a clickable widget."); }
        }
        
        gtk_widget_add_css_class(module_widget, "module");
        if (GTK_IS_BUTTON(module_widget) || GTK_IS_MENU_BUTTON(module_widget)) {
            gtk_widget_add_css_class(module_widget, "flat");
        }
        gtk_box_append(target_box, module_widget);
    }
}

G_MODULE_EXPORT GtkWidget* create_widget(const char *config_string) {
    TopbarState *state = g_new0(TopbarState, 1);
    
    GtkWidget *root_container = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_set_name(root_container, "aurora-topbar");
    gtk_widget_add_css_class(root_container, "aurora-topbar-widget");
    g_object_set_data_full(G_OBJECT(root_container), "topbar-state", state, topbar_cleanup);

    GtkWidget *left_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 8);
    gtk_widget_add_css_class(left_box, "left-modules");
    GtkWidget *center_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 8);
    gtk_widget_add_css_class(center_box, "center-modules");
    GtkWidget *right_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 8);
    gtk_widget_add_css_class(right_box, "right-modules");

    gtk_box_append(GTK_BOX(root_container), left_box);
    GtkWidget *center_spacer = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_set_hexpand(center_spacer, TRUE);
    gtk_box_append(GTK_BOX(root_container), center_spacer);
    gtk_box_append(GTK_BOX(root_container), center_box);
    GtkWidget *right_spacer = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_set_hexpand(right_spacer, TRUE);
    gtk_box_append(GTK_BOX(root_container), right_spacer);
    gtk_box_append(GTK_BOX(root_container), right_box);
    
    g_autoptr(JsonParser) parser = json_parser_new();
    if (config_string && *config_string) {
        if (json_parser_load_from_data(parser, config_string, -1, NULL)) {
            JsonObject *root_obj = json_node_get_object(json_parser_get_root(parser));
            if (json_object_has_member(root_obj, "config")) {
                JsonObject *config_obj = json_object_get_object_member(root_obj, "config");
                if (json_object_has_member(config_obj, "modules")) {
                    JsonObject *modules_obj = json_object_get_object_member(config_obj, "modules");
                    
                    GHashTable *section_map = g_hash_table_new(g_str_hash, g_str_equal);
                    g_hash_table_insert(section_map, "left", left_box);
                    g_hash_table_insert(section_map, "center", center_box);
                    g_hash_table_insert(section_map, "right", right_box);
                    
                    GList *members = json_object_get_members(modules_obj);
                    for (GList *l = members; l != NULL; l = l->next) {
                        const char *section_name = (const char *)l->data;
                        GtkBox *target_box = g_hash_table_lookup(section_map, section_name);
                        if (target_box) {
                            JsonArray *section_array = json_object_get_array_member(modules_obj, section_name);
                            for (guint i = 0; i < json_array_get_length(section_array); i++) {
                                JsonObject *module_config = json_array_get_object_element(section_array, i);
                                load_module(module_config, state, target_box);
                            }
                        }
                    }
                    g_list_free(members);
                    g_hash_table_destroy(section_map);
                }
            }
        }
    }
    
    return root_container;
}
======================================================================
### FILE: ././widgets/topbar/topbar.h
======================================================================
#ifndef TOPBAR_H
#define TOPBAR_H

#include <gtk/gtk.h>

// =======================================================================
// THE FIX: The function now correctly accepts a const char*
GtkWidget* create_topbar_widget(const char *config_string);
// =======================================================================

#endif // TOPBAR_H
======================================================================
### FILE: ././widgets/topbar/meson.build
======================================================================
# widgets/topbar/meson.build

# List of sources for the topbar library.
sources = [
  'topbar.c',
  'modules/workspaces.c',
  'modules/sysinfo.c',
  'modules/audio.c',
  'modules/zen.c',
]

dependencies = [
  dependency('gtk4'),
  dependency('gtk4-layer-shell-0'),
  dependency('json-glib-1.0')
]

# Build a 'shared_library' for the topbar plugin.
shared_library('topbar',
  sources,
  dependencies: dependencies,
  name_prefix: '',
  # This ensures the plugin gets installed correctly.
  install: true,
  install_dir: get_option('libdir') / 'aurora-shell' / 'widgets'
)
======================================================================
### FILE: ././widgets/cheatsheet/cheatsheet.c
======================================================================
#define _GNU_SOURCE
#include <gtk/gtk.h>
#include <glib.h>
#include <glib/gi18n.h>
#include <stdio.h>
#include <gdk/gdkkeysyms.h>
#include <json-glib/json-glib.h> // Keep includes, good practice

#define NUM_COLUMNS 3

// The state struct is now extremely simple.
typedef struct {
    GtkWidget *main_container;
} CheatsheetWidget;

// Helper functions for memory cleanup, unchanged.
static void free_category_list(gpointer data) { g_list_free_full((GList *)data, g_free); }
static void free_categories(GList *categories) { g_list_free_full(categories, free_category_list); }

// The file parsing logic is core to this plugin and remains unchanged.
static GList* parse_categories_from_file(void) {
    // NOTE: This hardcoded path could be made configurable in config.json in the future!
    const char *keys_file_path = "./widgets/cheatsheet/keys.conf";
    GList *categories = NULL, *current_category = NULL;
    FILE *file = fopen(keys_file_path, "r");
    if (!file) return NULL;

    char *line = NULL;
    size_t len = 0;
    while (getline(&line, &len, file) != -1) {
        gchar *stripped_line = g_strstrip(line);
        if (strlen(stripped_line) == 0 || g_str_has_prefix(stripped_line, "#")) continue;

        if (!strstr(stripped_line, "=")) { // This line is a header
            if (current_category) {
                categories = g_list_append(categories, current_category);
            }
            current_category = NULL;
            current_category = g_list_append(current_category, g_strdup(stripped_line));
        } else { // This line is a key-value pair
            if (current_category) {
                current_category = g_list_append(current_category, g_strdup(stripped_line));
            }
        }
    }

    if (current_category) {
        categories = g_list_append(categories, current_category);
    }
    
    fclose(file);
    if (line) free(line);
    
    return g_list_reverse(categories);
}

// UI creation for a single category. Now simpler without the CSS provider argument.
static GtkWidget* create_category_widget(GList *category_data) {
    gchar *header_text = (gchar*)category_data->data;
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_add_css_class(box, "category-box");

    GtkWidget *header_label = gtk_label_new(header_text);
    gtk_widget_set_halign(header_label, GTK_ALIGN_START);
    gtk_widget_add_css_class(header_label, "category-header");
    gtk_box_append(GTK_BOX(box), header_label);

    GtkWidget *grid = gtk_grid_new();
    gtk_grid_set_column_spacing(GTK_GRID(grid), 20);
    gtk_grid_set_row_spacing(GTK_GRID(grid), 8);

    int row = 0;
    for (GList *l = g_list_next(category_data); l; l = g_list_next(l)) {
        gchar **parts = g_strsplit((gchar*)l->data, "=", 2);
        if (parts[0] && parts[1]) {
            GtkWidget *key = gtk_label_new(g_strstrip(parts[0]));
            gtk_widget_set_halign(key, GTK_ALIGN_END);
            gtk_widget_add_css_class(key, "key-label");

            GtkWidget *desc = gtk_label_new(g_strstrip(parts[1]));
            gtk_widget_set_halign(desc, GTK_ALIGN_START);
            gtk_widget_add_css_class(desc, "desc-label");

            gtk_grid_attach(GTK_GRID(grid), key, 0, row, 1, 1);
            gtk_grid_attach(GTK_GRID(grid), desc, 1, row, 1, 1);
            row++;
        }
        g_strfreev(parts);
    }
    gtk_box_append(GTK_BOX(box), grid);
    return box;
}

// ===================================================================
//  Plugin Entry Point (Simplified and Unified Version)
// ===================================================================
G_MODULE_EXPORT GtkWidget* create_widget(const char *config_string) {
    (void)config_string; // This plugin doesn't need any config from the orchestrator yet.
    
    CheatsheetWidget *widget_data = g_new0(CheatsheetWidget, 1);
    
    // Create the main container.
    widget_data->main_container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    // CRITICAL: Keep the original CSS class name so the external stylesheet works!
    gtk_widget_add_css_class(widget_data->main_container, "main-container");
    
    // --- All internal CSS loading has been REMOVED ---
    
    GtkWidget *content_grid = gtk_grid_new();
    gtk_grid_set_column_spacing(GTK_GRID(content_grid), 30);
    gtk_widget_set_margin_top(content_grid, 20);
    gtk_widget_set_margin_bottom(content_grid, 20);
    gtk_widget_set_margin_start(content_grid, 25);
    gtk_widget_set_margin_end(content_grid, 25);
    gtk_widget_set_hexpand(content_grid, TRUE);
    gtk_box_append(GTK_BOX(widget_data->main_container), content_grid);

    // The Escape key is already handled by the orchestrator for interactive widgets,
    // so the internal key controller is redundant, but we can leave it for now.
    
    GList *categories = parse_categories_from_file();
    if (categories) {
        GtkWidget *columns[NUM_COLUMNS];
        for (int i = 0; i < NUM_COLUMNS; i++) {
            columns[i] = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
            gtk_grid_attach(GTK_GRID(content_grid), columns[i], i, 0, 1, 1);
        }
        int i = 0;
        for (GList *l = categories; l; l = g_list_next(l)) {
            // Call the simplified create_category_widget function
            gtk_box_append(GTK_BOX(columns[i++ % NUM_COLUMNS]), create_category_widget((GList*)l->data));
        }
        free_categories(categories);
    } else {
        gtk_grid_attach(GTK_GRID(content_grid), gtk_label_new("Could not load keys.conf"), 0, 0, 1, 1);
    }
    
    // Setup cleanup signals
    g_signal_connect_swapped(widget_data->main_container, "destroy", G_CALLBACK(g_free), widget_data);
    
    return widget_data->main_container;
}
======================================================================
### FILE: ././widgets/cheatsheet/meson.build
======================================================================
# widgets/cheatsheet/meson.build

# Define where the compiled .so file should be installed
# This will be /usr/local/lib/aurora-shell/widgets/
widget_install_dir = get_option('libdir') / 'aurora-shell' / 'widgets'

# Define where the data file (keys.conf) should be installed
# This will be /usr/local/share/aurora-shell/
data_install_dir = get_option('datadir') / 'aurora-shell'

# The dependencies needed to compile cheatsheet.c
dependencies = [
  dependency('gtk4'),
    dependency('json-glib-1.0')
]

# 1. Compile cheatsheet.c into a shared library plugin
shared_library('cheatsheet', 'cheatsheet.c',
  dependencies: dependencies,
  install: true,
  install_dir: widget_install_dir,
  name_prefix: '', # Creates cheatsheet.so instead of libcheatsheet.so
)

# 2. Install the configuration file for this widget
install_data('keys.conf',
  install_dir: data_install_dir,
  install_mode: 'rw-r--r--'
)
======================================================================
### FILE: ././widgets/launcher/launcher.h
======================================================================
#ifndef LAUNCHER_H
#define LAUNCHER_H

#include <gtk/gtk.h>

// Forward declarations
G_DECLARE_FINAL_TYPE(AppInfo, app_info, APP, INFO, GObject)
G_DECLARE_FINAL_TYPE(AuroraResultObject, aurora_result_object, AURORA, RESULT_OBJECT, GObject)

typedef enum {
    AURORA_RESULT_APP,
    AURORA_RESULT_CALCULATOR,
    AURORA_RESULT_COMMAND,
    AURORA_RESULT_SYSTEM_ACTION,
    AURORA_RESULT_FILE
} AuroraResultType;

// --- PUBLIC FUNCTION DECLARATIONS ---

// The function in your plugin's main .c file that creates the widget
GtkWidget* create_widget(const char *config_string);

// The constructor for the result objects, used by your modules (apps.c, etc.)
AuroraResultObject* aurora_result_object_new(
    AuroraResultType type,
    const gchar *name,
    const gchar *description,
    const gchar *icon_name,
    gpointer data,
    GDestroyNotify data_free_func,
    gint score // <<< FIX IS HERE: Add the new score parameter
);

#endif // LAUNCHER_H
======================================================================
### FILE: ././widgets/launcher/modules/calculator.c
======================================================================
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "calculator.h"
// This include is necessary to find the definition for AuroraResultObject
// and its constructor, aurora_result_object_new.
#include "../launcher.h"

// A simple check to see if a string looks like a math expression.
// This prevents us from running the `bc` command on every single keypress.
static gboolean is_potential_math(const gchar *str) {
    if (!str || strlen(str) < 2) return FALSE;

    gboolean has_digit = FALSE;
    gboolean has_operator = FALSE;
    for (int i = 0; str[i] != '\0'; i++) {
        if (isdigit(str[i])) {
            has_digit = TRUE;
        }
        if (strchr("+-*/()^.", str[i])) { // Added '.' for decimals
            has_operator = TRUE;
        }
    }
    return has_digit && has_operator;
}

// The public function that the main launcher calls.
GList* get_calculator_results(const gchar *query) {
    if (!is_potential_math(query)) {
        return NULL;
    }

    // Use `bc -l`. The `-l` flag loads the standard math library,
    // which gives us access to functions like sqrt(), sin(), cos(), etc.
    // 'scale=4' sets the number of decimal places in the result.
    g_autofree gchar *command = g_strdup_printf("echo 'scale=4; %s' | bc -l", query);
    
    // popen is a standard C library function that runs a command
    // and lets us read its standard output like a file.
    FILE *pipe = popen(command, "r");
    if (!pipe) {
        return NULL;
    }

    char buffer[128];
    char *result_str = fgets(buffer, sizeof(buffer), pipe);
    pclose(pipe);

    // If fgets returns NULL or an empty string, there was no valid output.
    if (!result_str || strlen(result_str) <= 1) { // Check for empty or newline-only result
        return NULL;
    }

    // `bc`'s output includes a newline character (\n) at the end.
    // This line finds that newline and replaces it with a null terminator (\0).
    result_str[strcspn(result_str, "\n")] = 0;
    
    // Sometimes `bc` will just echo our input back if the expression isn't
    // complete yet (e.g., for "5*"). We don't want to show that as a result.
    if (g_strcmp0(result_str, query) == 0) {
        return NULL;
    }

    GList *results_list = NULL;
    g_autofree gchar *description = g_strdup_printf("Copy '%s' to clipboard", result_str);

    results_list = g_list_prepend(results_list, aurora_result_object_new(
        AURORA_RESULT_CALCULATOR,
        result_str,
        description,
        "accessories-calculator-symbolic", // A more standard icon name
        g_strdup(result_str),              // The data is the result string itself
        g_free,                            // Provide the function to free the data
        120                                // <<< FIX IS HERE: Added the score parameter
    ));

    return results_list;
}
======================================================================
### FILE: ././widgets/launcher/modules/calculator.h
======================================================================
#ifndef MODULES_CALCULATOR_H
#define MODULES_CALCULATOR_H

#include <glib.h>

// This function will be called to get calculator results.
GList* get_calculator_results(const gchar *query);

#endif // MODULES_CALCULATOR_H
======================================================================
### FILE: ././widgets/launcher/modules/commands.h
======================================================================
#ifndef MODULES_COMMANDS_H
#define MODULES_COMMANDS_H

#include <glib.h>

GList* get_command_results(const gchar *search_text);

#endif // MODULES_COMMANDS_H
======================================================================
### FILE: ././widgets/launcher/modules/apps.c
======================================================================
// ===================================================================
//  Aurora Launcher - Apps Module (Corrected & Simplified)
// ===================================================================
// Fetches applications using the standard GIO/GAppInfo API, ensuring
// correct application discovery and process launching.

#include <gio/gio.h>
#include <string.h>
#include "apps.h"
#include "../launcher.h"

// A robust fuzzy search algorithm to match user input against app names.
static gboolean fuzzy_match(const gchar *str, const gchar *search) {
    if (!str || !search) return FALSE;

    g_autofree gchar *name_lower = g_ascii_strdown(str, -1);
    g_autofree gchar *search_lower = g_ascii_strdown(search, -1);

    // Create a version of the search string with spaces removed for better matching.
    char search_no_spaces[strlen(search_lower) + 1];
    int k = 0;
    for (int i = 0; search_lower[i] != '\0'; i++) {
        if (search_lower[i] != ' ') {
            search_no_spaces[k++] = search_lower[i];
        }
    }
    search_no_spaces[k] = '\0';

    // Perform the sequential character match.
    int search_idx = 0;
    int name_idx = 0;
    while (search_no_spaces[search_idx] != '\0' && name_lower[name_idx] != '\0') {
        if (search_no_spaces[search_idx] == name_lower[name_idx]) {
            search_idx++;
        }
        name_idx++;
    }

    return search_no_spaces[search_idx] == '\0';
}

// Public function to get application results based on a search term.
GList* get_app_results(const gchar *search_text) {
    GList *results = NULL;
    if (!search_text || *search_text == '\0') {
        return NULL;
    }

    g_autofree gchar *search_lower = g_ascii_strdown(search_text, -1);
    GList *all_apps = g_app_info_get_all();

    for (GList *l = all_apps; l != NULL; l = l->next) {
        GAppInfo *app_info = G_APP_INFO(l->data);
        if (!g_app_info_should_show(app_info)) {
            continue;
        }

        const gchar *app_name = g_app_info_get_name(app_info);
        g_autofree gchar *app_name_lower = g_ascii_strdown(app_name, -1);
        
        gint score = 0;

        if (g_strcmp0(app_name_lower, search_lower) == 0) {
            score = 100; // Perfect match
        } else if (g_str_has_prefix(app_name_lower, search_lower)) {
            score = 80;  // Starts-with match
        } else if (fuzzy_match(app_name, search_text)) {
            score = 60;  // Generic fuzzy match
        }
        
        // Only create a result if there was a match (score > 0)
        if (score > 0) {
            g_autofree gchar *icon_str = NULL;
            GIcon *icon = g_app_info_get_icon(app_info);
            if (icon) {
                icon_str = g_icon_to_string(icon);
            }

            results = g_list_prepend(results, aurora_result_object_new(
                AURORA_RESULT_APP,
                app_name,
                g_app_info_get_description(app_info),
                icon_str ? icon_str : "application-x-executable",
                g_object_ref(app_info),
                g_object_unref,
                score 
            ));
        }
    }
    
    g_list_free(all_apps);
    // Don't g_list_reverse() anymore, sorting will handle the order.
    return results;
}
======================================================================
### FILE: ././widgets/launcher/modules/apps.h
======================================================================
#ifndef MODULES_APPS_H
#define MODULES_APPS_H

#include <glib.h>
#include "../launcher.h" // Needed for the AppInfo type

// Public function to get app results
GList* get_app_results(const gchar *search_text);

// ========================================================================
// <<< THE FIX: Add a public getter function for the exec command.
// ========================================================================
const gchar* app_info_get_exec_cmd(AppInfo *app);

#endif // MODULES_APPS_H
======================================================================
### FILE: ././widgets/launcher/modules/commands.c
======================================================================
#include <glib.h>
#include "commands.h"
#include "../launcher.h"

// Define your preferred terminal here
#define TERMINAL_COMMAND "kitty"

GList* get_command_results(const gchar *search_text) {
    if (!g_str_has_prefix(search_text, "> ")) {
        return NULL;
    }

    const gchar *command = search_text + 2; // Skip the "> "
    if (*command == '\0') {
        return NULL; // Don't show a result for an empty command
    }

    g_autofree gchar *description = g_strdup_printf("Run '%s' in terminal", command);
    GList *results = NULL;

    // The 'data' for this result is the command itself.
    results = g_list_prepend(results, aurora_result_object_new(
        AURORA_RESULT_COMMAND,
        command,
        description,
        "utilities-terminal-symbolic",
        g_strdup(command),
        g_free,
        70 // <<< FIX IS HERE: Added the score parameter
    ));

    return results;
}
======================================================================
### FILE: ././widgets/launcher/launcher.c
======================================================================
// ===================================================================
//  Aurora Launcher Widget
// ===================================================================
// A searchable, keyboard-driven application launcher and command runner,
// integrated as a dynamic plugin for the Aurora Shell.

#include <gtk/gtk.h>
#include <string.h>
#include "launcher.h"
#include "modules/apps.h"
#include "modules/calculator.h"
#include "modules/commands.h"

// ===================================================================
//  GObject Definition: AuroraResultObject
// ===================================================================

#define AURORA_RESULT_OBJECT_TYPE (aurora_result_object_get_type())
struct _AuroraResultObject {
    GObject parent_instance;
    AuroraResultType type;
    gchar *name;
    gchar *description;
    gchar *icon_name;
    gpointer data;
    GDestroyNotify data_free_func;
    gint score;
};
G_DEFINE_TYPE(AuroraResultObject, aurora_result_object, G_TYPE_OBJECT)

static void aurora_result_object_finalize(GObject *object) {
    AuroraResultObject *self = AURORA_RESULT_OBJECT(object);
    g_free(self->name);
    g_free(self->description);
    g_free(self->icon_name);
    if (self->data_free_func && self->data) {
        self->data_free_func(self->data);
    }
    G_OBJECT_CLASS(aurora_result_object_parent_class)->finalize(object);
}

static void aurora_result_object_init(AuroraResultObject *self) {
    (void)self;
}

static void aurora_result_object_class_init(AuroraResultObjectClass *klass) {
    GObjectClass *object_class = G_OBJECT_CLASS(klass);
    object_class->finalize = aurora_result_object_finalize;
}

AuroraResultObject* aurora_result_object_new(AuroraResultType type, const gchar *name, const gchar *description, const gchar *icon_name, gpointer data, GDestroyNotify data_free_func, gint score) {
    AuroraResultObject *self = g_object_new(AURORA_RESULT_OBJECT_TYPE, NULL);
    self->type = type;
    self->name = g_strdup(name);
    self->description = g_strdup(description);
    self->icon_name = g_strdup(icon_name);
    self->data = data;
    self->data_free_func = data_free_func;
    self->score = score;
    return self;
}

// ===================================================================
//  Launcher State & Cleanup
// ===================================================================

typedef struct {
    GtkWidget *main_box;
    GtkWidget *entry;
    GtkWidget *listbox;
    GtkWidget *results_revealer;
    GListStore *results_store;
} LauncherState;

static void free_launcher_state(gpointer data) {
    LauncherState *state = (LauncherState *)data;
    g_object_unref(state->results_store);
    g_free(state);
}

// ===================================================================
//  Core Logic & Data Handling
// ===================================================================

static gint compare_results_by_score(gconstpointer a, gconstpointer b) {
    const AuroraResultObject *result_a = a;
    const AuroraResultObject *result_b = b;
    return result_b->score - result_a->score;
}

static void update_search_results(LauncherState *state, const gchar *search_text) {
    g_list_store_remove_all(state->results_store);

    GList *command_results = get_command_results(search_text);
    GList *app_results = get_app_results(search_text);
    GList *calc_results = get_calculator_results(search_text);
    
    GList *all_results = g_list_concat(command_results, g_list_concat(calc_results, app_results));
    all_results = g_list_sort(all_results, compare_results_by_score);

    for (GList *l = all_results; l != NULL; l = l->next) {
        g_list_store_append(state->results_store, l->data);
        g_object_unref(l->data);
    }
    g_list_free(all_results);

    guint n_items = g_list_model_get_n_items(G_LIST_MODEL(state->results_store));
    gtk_revealer_set_reveal_child(GTK_REVEALER(state->results_revealer), n_items > 0);
    if (n_items > 0) {
        GtkListBoxRow *first_row = gtk_list_box_get_row_at_index(GTK_LIST_BOX(state->listbox), 0);
        gtk_list_box_select_row(GTK_LIST_BOX(state->listbox), first_row);
    }
}

// ===================================================================
//  Signal Handlers / Callbacks
// ===================================================================

static void on_widget_mapped(GtkWidget *widget, gpointer user_data) {
    (void)widget;
    LauncherState *state = (LauncherState *)user_data;
    gtk_editable_set_text(GTK_EDITABLE(state->entry), "");
    gtk_widget_grab_focus(state->entry);
}

// <<< THIS FUNCTION IS NOW FIXED >>>
static void on_entry_changed(GtkEditable *entry, gpointer user_data) {
    // The variable passed to the function is named `user_data`.
    LauncherState *state = (LauncherState *)user_data;
    const gchar *search_text = gtk_editable_get_text(entry);
    update_search_results(state, search_text);
}

static void on_result_activated(GtkListBox *box, GtkListBoxRow *row, gpointer user_data) {
    (void)user_data;
    guint index = gtk_list_box_row_get_index(row);
    LauncherState *state = (LauncherState*)g_object_get_data(G_OBJECT(gtk_widget_get_ancestor(GTK_WIDGET(box), GTK_TYPE_BOX)), "launcher-state");
    AuroraResultObject *result = g_list_model_get_item(G_LIST_MODEL(state->results_store), index);
    if (!result) return;

    switch (result->type) {
        case AURORA_RESULT_APP: {
            GAppInfo *app_info = G_APP_INFO(result->data);
            g_autoptr(GError) error = NULL;
            if (!g_app_info_launch(app_info, NULL, NULL, &error)) {
                g_warning("Failed to launch application: %s", error->message);
            }
            break;
        }
        case AURORA_RESULT_CALCULATOR: {
            gchar *calc_result = (gchar*)result->data;
            GdkClipboard *clipboard = gtk_widget_get_clipboard(GTK_WIDGET(box));
            gdk_clipboard_set_text(clipboard, calc_result);
            break;
        }
        case AURORA_RESULT_COMMAND: {
            gchar *command = (gchar*)result->data;
            g_spawn_async(NULL, (gchar*[]){"foot", "-e", command, NULL}, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, NULL, NULL);
            break;
        }
        default:
            break;
    }

    g_object_unref(result);
    
    GtkWidget *toplevel = gtk_widget_get_ancestor(GTK_WIDGET(row), GTK_TYPE_WINDOW);
    if (toplevel) {
        gtk_widget_set_visible(toplevel, FALSE);
    }
}

static void on_entry_activated(GtkEntry *entry, gpointer user_data) {
    (void)entry;
    LauncherState *state = (LauncherState *)user_data;
    GtkListBoxRow *selected_row = gtk_list_box_get_selected_row(GTK_LIST_BOX(state->listbox));
    if (selected_row) {
        gtk_widget_activate(GTK_WIDGET(selected_row));
    }
}

static gboolean on_key_pressed_nav(GtkEventControllerKey *controller, guint keyval, guint keycode, GdkModifierType state, gpointer user_data) {
    (void)controller; (void)keycode; (void)state;
    LauncherState *launcher_state = (LauncherState *)user_data;
    GtkListBox *listbox = GTK_LIST_BOX(launcher_state->listbox);

    if (keyval == GDK_KEY_Up || keyval == GDK_KEY_Down) {
        guint n_items = g_list_model_get_n_items(G_LIST_MODEL(launcher_state->results_store));
        if (n_items == 0) {
            return GDK_EVENT_PROPAGATE;
        }

        GtkListBoxRow *selected_row = gtk_list_box_get_selected_row(listbox);
        gint current_index = selected_row ? gtk_list_box_row_get_index(selected_row) : -1;
        gint new_index;

        if (keyval == GDK_KEY_Down) {
            new_index = (current_index + 1) % n_items;
        } else { // GDK_KEY_Up
            new_index = (current_index - 1 + n_items) % n_items;
        }

        GtkListBoxRow *row_to_select = gtk_list_box_get_row_at_index(listbox, new_index);
        gtk_list_box_select_row(listbox, row_to_select);
        
        if (row_to_select) {
            gtk_widget_grab_focus(GTK_WIDGET(row_to_select));
        }

        return GDK_EVENT_STOP;
    }
    return GDK_EVENT_PROPAGATE;
}

// ===================================================================
//  UI Construction
// ===================================================================

static GtkWidget* create_result_row_ui(AuroraResultObject *result) {
    GtkWidget *main_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 12);
    gtk_widget_set_margin_start(main_box, 10);
    gtk_widget_set_margin_end(main_box, 10);
    gtk_widget_set_margin_top(main_box, 5);
    gtk_widget_set_margin_bottom(main_box, 5);

    GtkWidget *icon = NULL;
    if (result->icon_name && g_path_is_absolute(result->icon_name)) {
        icon = gtk_image_new_from_file(result->icon_name);
    } else {
        icon = gtk_image_new_from_icon_name(result->icon_name);
    }
    
    gtk_image_set_pixel_size(GTK_IMAGE(icon), 32);
    gtk_box_append(GTK_BOX(main_box), icon);

    GtkWidget *name_label = gtk_label_new(result->name);
    gtk_label_set_xalign(GTK_LABEL(name_label), 0.0);
    gtk_widget_add_css_class(name_label, "result-name");
    gtk_box_append(GTK_BOX(main_box), name_label);
    
    return main_box;
}

static GtkWidget* bind_model_create_widget_func(gpointer item, gpointer user_data) {
    (void)user_data;
    GtkListBoxRow *row = GTK_LIST_BOX_ROW(gtk_list_box_row_new());
    GtkWidget *content = create_result_row_ui(AURORA_RESULT_OBJECT(item));
    gtk_list_box_row_set_child(row, content);
    return GTK_WIDGET(row);
}

// ===================================================================
//  Plugin Entry Point
// ===================================================================

GtkWidget* create_widget(const char *config_string) {
    (void)config_string;

    LauncherState *state = g_new0(LauncherState, 1);
    state->results_store = g_list_store_new(AURORA_RESULT_OBJECT_TYPE);
    
    state->main_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 12);
    gtk_widget_add_css_class(state->main_box, "launcher-box");
    g_object_set_data_full(G_OBJECT(state->main_box), "launcher-state", state, free_launcher_state);

    // --- The Correct Layout Fix ---
    // The main_box is the child of the window. By setting its vertical alignment,
    // we stop IT from stretching to fill the window. This forces the window
    // to shrink-to-fit the box's natural, compact size. Using CENTER looks best.
    gtk_widget_set_valign(state->main_box, GTK_ALIGN_CENTER);
    
    g_signal_connect(state->main_box, "map", G_CALLBACK(on_widget_mapped), state);

    state->entry = gtk_entry_new();
    gtk_widget_add_css_class(state->entry, "launcher-entry");
    gtk_entry_set_placeholder_text(GTK_ENTRY(state->entry), "Search Apps, Calculate, or > Run Command");
    
    state->listbox = gtk_list_box_new();
    gtk_widget_add_css_class(state->listbox, "results-listbox");
    gtk_list_box_set_selection_mode(GTK_LIST_BOX(state->listbox), GTK_SELECTION_SINGLE);
    gtk_list_box_bind_model(GTK_LIST_BOX(state->listbox), G_LIST_MODEL(state->results_store), bind_model_create_widget_func, NULL, NULL);

    GtkWidget *scrolled_win = gtk_scrolled_window_new();
    gtk_widget_add_css_class(scrolled_win, "results-scroller");
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled_win), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
    
    gtk_scrolled_window_set_propagate_natural_height(GTK_SCROLLED_WINDOW(scrolled_win), TRUE);
    gtk_scrolled_window_set_max_content_height(GTK_SCROLLED_WINDOW(scrolled_win), 350);
    
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_win), state->listbox);

    state->results_revealer = gtk_revealer_new();
    gtk_revealer_set_transition_type(GTK_REVEALER(state->results_revealer), GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN);
    gtk_revealer_set_transition_duration(GTK_REVEALER(state->results_revealer), 200);
    gtk_revealer_set_child(GTK_REVEALER(state->results_revealer), scrolled_win);

    gtk_box_append(GTK_BOX(state->main_box), state->entry);
    gtk_box_append(GTK_BOX(state->main_box), state->results_revealer);

    g_signal_connect(state->entry, "changed", G_CALLBACK(on_entry_changed), state);
    g_signal_connect(state->entry, "activate", G_CALLBACK(on_entry_activated), state);
    g_signal_connect(state->listbox, "row-activated", G_CALLBACK(on_result_activated), state);

    GtkEventController *nav_controller = gtk_event_controller_key_new();
    g_signal_connect(nav_controller, "key-pressed", G_CALLBACK(on_key_pressed_nav), state);
    gtk_widget_add_controller(state->main_box, nav_controller);

    gtk_widget_set_focusable(state->entry, TRUE);

    return state->main_box;
}
======================================================================
### FILE: ././widgets/launcher/meson.build
======================================================================
# widgets/launcher/meson.build

launcher_sources = [
  'launcher.c',
  'modules/apps.c',
  'modules/calculator.c',
  'modules/commands.c',
]

launcher_deps = [
  dependency('gtk4'),
  dependency('gtk4-layer-shell-0'),
]

shared_library('launcher',
  launcher_sources,
  dependencies: launcher_deps,
  name_prefix: '',
  # THE FIX IS HERE:
  install: true,
  install_dir: get_option('libdir') / 'aurora-shell' / 'widgets'
)
======================================================================
### FILE: ././widgets/uptime/meson.build
======================================================================
# widgets/uptime/meson.build

# This will install to /usr/local/lib/aurora-shell/widgets/
widget_install_dir = get_option('libdir') / 'aurora-shell' / 'widgets'

dependencies = [
  dependency('gtk4'),
  dependency('json-glib-1.0')
]

shared_library('uptime', 'uptime.c',
  dependencies: dependencies,
  install: true,
  install_dir: widget_install_dir,
  name_prefix: '', 
)
======================================================================
### FILE: ././widgets/uptime/uptime.c
======================================================================
#include <gtk/gtk.h>
#include <glib.h>
#include <glib/gi18n.h>
#include <stdio.h>
#include <string.h>
#include <json-glib/json-glib.h>

typedef struct {
    GtkWidget *info_label;
    GtkWidget *main_container;
    gchar *format_string;
} UptimeWidget;

// (All helper functions are unchanged and correct)
static void unquote_string(gchar *str) {
    if (str == NULL) return;
    size_t len = strlen(str);
    if (len >= 2 && str[0] == '"' && str[len - 1] == '"') {
        memmove(str, str + 1, len - 2);
        str[len - 2] = '\0';
    }
}

static gboolean update_info(gpointer user_data) {
    UptimeWidget *widget = (UptimeWidget *)user_data;
    if (!widget->format_string) return G_SOURCE_CONTINUE;

    gchar *distro_name = NULL, *uptime_str_raw = NULL;
    
    gchar *os_release_contents;
    if (g_file_get_contents("/etc/os-release", &os_release_contents, NULL, NULL)) {
        const gchar* keys_to_try[] = { "PRETTY_NAME=", "NAME=", NULL };
        for (int k = 0; keys_to_try[k] != NULL && distro_name == NULL; k++) {
            gchar **lines = g_strsplit(os_release_contents, "\n", -1);
            for (int i = 0; lines[i] != NULL; i++) {
                if (g_str_has_prefix(lines[i], keys_to_try[k])) {
                    gchar **parts = g_strsplit(lines[i], "=", 2);
                    if (parts[1]) {
                        distro_name = g_strdup(parts[1]);
                        distro_name = g_strstrip(distro_name);
                        unquote_string(distro_name);
                    }
                    g_strfreev(parts);
                    break;
                }
            }
            g_strfreev(lines);
        }
        g_free(os_release_contents);
    }
    
    if (distro_name == NULL) distro_name = g_strdup("Unknown OS");

    g_spawn_command_line_sync("uptime -p", &uptime_str_raw, NULL, NULL, NULL);
    gchar *uptime_str = g_strstrip(uptime_str_raw);
    const char *prefix = "up ";
    gchar *uptime_clean = uptime_str;
    if (g_str_has_prefix(uptime_str, prefix)) uptime_clean += strlen(prefix);

    GString *final_text_gstring = g_string_new(widget->format_string);
    g_string_replace(final_text_gstring, "{distro}", distro_name, 0);
    g_string_replace(final_text_gstring, "{uptime}", uptime_clean, 0);
    
    gtk_label_set_text(GTK_LABEL(widget->info_label), final_text_gstring->str);

    g_string_free(final_text_gstring, TRUE);
    g_free(distro_name);
    g_free(uptime_str_raw);
    return G_SOURCE_CONTINUE;
}

// ===================================================================
//  Plugin Entry Point (Final Version)
// ===================================================================
//  Plugin Entry Point (Final, Corrected Version using GtkFrame)
// ===================================================================
G_MODULE_EXPORT GtkWidget* create_widget(const char *config_string) {
    // This part is for managing our widget's data. It stays the same.
    UptimeWidget *widget_data = g_new0(UptimeWidget, 1);
    widget_data->format_string = g_strdup("Uptime: {uptime}"); 

    // This part reads the "text" property from your config.json. It also stays the same.
    if (config_string && *config_string) {
        g_autoptr(JsonParser) parser = json_parser_new();
        if (json_parser_load_from_data(parser, config_string, -1, NULL)) {
            JsonObject *root_obj = json_node_get_object(json_parser_get_root(parser));
            if (json_object_has_member(root_obj, "text")) {
                g_free(widget_data->format_string);
                widget_data->format_string = g_strdup(
                    json_object_get_string_member(root_obj, "text")
                );
            }
        }
    }

    // --- START OF CHANGES ---

    // 1. Create a GtkFrame. This will be our new top-level widget.
    //    A GtkFrame is designed to be styled with borders, backgrounds, etc.
    GtkWidget *frame = gtk_frame_new(NULL);

    // 2. Apply your ID to the FRAME. This is the widget your CSS will style.
    gtk_widget_set_name(frame, "uptime-widget");
    
    // 3. Create the GtkBox like before. Its only job is now to arrange the label.
    //    It no longer needs any styling information.
    widget_data->main_container = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    
    // 4. Place the box inside the frame.
    gtk_frame_set_child(GTK_FRAME(frame), widget_data->main_container);
    
    // 5. Create the label and add its CSS class, just like before.
    widget_data->info_label = gtk_label_new("");
    gtk_widget_add_css_class(widget_data->info_label, "info-label");
    gtk_widget_set_margin_top(widget_data->info_label, 2);
    gtk_widget_set_margin_bottom(widget_data->info_label, 2);
    
    // 6. Add the label to the box.
    gtk_box_append(GTK_BOX(widget_data->main_container), widget_data->info_label);
    
    // This logic to update the text stays the same.
    update_info(widget_data);
    g_timeout_add_seconds(60, (GSourceFunc)update_info, widget_data);
    
    // 7. IMPORTANT: Connect the memory cleanup signals to the new top-level widget (the frame).
    //    This ensures that when the frame is destroyed, our data is freed.
    g_signal_connect_swapped(frame, "destroy", G_CALLBACK(g_free), widget_data->format_string);
    g_signal_connect_swapped(frame, "destroy", G_CALLBACK(g_free), widget_data);
    
    // 8. Return the FRAME, which is now the complete, styleable widget.
    return frame;

    // --- END OF CHANGES ---
}
======================================================================
### FILE: ././widgets/qscreen/utils.h
======================================================================
#ifndef QSCREEN_UTILS_H
#define QSCREEN_UTILS_H

#include "qscreen.h"

gboolean check_dependencies(void);
void run_command_with_stdin_sync(const gchar *command, const gchar *input);

void process_final_screenshot(const char *source_path, GdkRectangle *geometry, gboolean save_to_disk, QScreenState *state);
void process_fullscreen_screenshot(QScreenState *state);
GList* get_hyprland_windows_geometry(QScreenState *state);
void capture_fullscreen_for_overlay(GChildWatchFunc on_captured, gpointer user_data);

#endif // QSCREEN_UTILS_H
======================================================================
### FILE: ././widgets/qscreen/qscreen.h
======================================================================
#ifndef QSCREEN_H
#define QSCREEN_H

#include <gtk/gtk.h>
#include <gdk/gdk.h>

// Enum for modes passed via config.json
typedef enum {
    QSCREEN_MODE_INTERACTIVE,
    QSCREEN_MODE_REGION,
    QSCREEN_MODE_WINDOW,
    QSCREEN_MODE_FULLSCREEN,
    QSCREEN_MODE_TEXT
} QScreenMode;

// Struct to hold parsed config values
typedef struct {
    // This GtkApplication pointer is no longer needed in the plugin model,
    // but we keep the struct for consistency with utils.c
    GtkApplication *app;
    gchar *temp_path_for_cleanup; // Path for the main background screenshot
    QScreenMode initial_mode;
    gboolean save_on_launch;
} QScreenState;

// This is the one and only public function for our plugin,
// called by the aurora-shell orchestrator.
GtkWidget* create_widget(const char *config_string);

#endif // QSCREEN_H
======================================================================
### FILE: ././widgets/qscreen/features/ocr.h
======================================================================
#ifndef QSCREEN_OCR_H
#define QSCREEN_OCR_H

#include <gdk/gdk.h>
#include <glib.h>

// A struct to hold a single word found by OCR and its location
typedef struct {
    GdkRectangle geometry;
    char *text;
} QScreenTextBox;

// Define a callback function type that will receive the results
typedef void (*OcrResultFunc)(GList *text_boxes, gpointer user_data);

// The main function that runs Tesseract and returns a list of text boxes
GList* run_ocr_on_screenshot(const char *image_path);

// The new asynchronous version of the function
void run_ocr_on_screenshot_async(const char *image_path, OcrResultFunc callback, gpointer user_data);

// A helper to free the memory used by our text box list
void free_ocr_results(GList *text_boxes);

#endif // QSCREEN_OCR_H
======================================================================
### FILE: ././widgets/qscreen/features/ocr.c
======================================================================
#include "ocr.h"
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h> // For GTask

GList* run_ocr_on_screenshot(const char *image_path) {
    // Use Page Segmentation Mode 11: "Find as much text as possible in no particular order."
    g_autofree char *command = g_strdup_printf("tesseract \"%s\" stdout -l eng --psm 11 tsv", image_path);
    g_autofree gchar *tsv_output = NULL;
    g_autoptr(GError) error = NULL;

    g_spawn_command_line_sync(command, &tsv_output, NULL, NULL, &error);

    if (error) {
        g_warning("Failed to run Tesseract: %s", error->message);
        g_warning("Please ensure 'tesseract' and 'tesseract-data-eng' are installed.");
        return NULL;
    }

    GList *text_boxes = NULL;
    char **lines = g_strsplit(tsv_output, "\n", -1);
    
    for (int i = 1; lines[i] != NULL; i++) {
        char **fields = g_strsplit(lines[i], "\t", -1);
        
        if (g_strv_length(fields) == 12 && atoi(fields[0]) == 5 && g_strcmp0(g_strstrip(fields[11]), "") != 0) {
            int conf = atoi(fields[10]);
            if (conf > 50) {
                QScreenTextBox *box = g_new(QScreenTextBox, 1);
                box->geometry.x = atoi(fields[6]);
                box->geometry.y = atoi(fields[7]);
                box->geometry.width = atoi(fields[8]);
                box->geometry.height = atoi(fields[9]);
                box->text = g_strdup(fields[11]);
                text_boxes = g_list_prepend(text_boxes, box);
            }
        }
        g_strfreev(fields);
    }
    g_strfreev(lines);

    return g_list_reverse(text_boxes);
}

// Helper function to free a QScreenTextBox struct and its contents
static void qscreen_text_box_free(gpointer data) {
    QScreenTextBox *box = data;
    if (!box) return;
    g_free(box->text);
    g_free(box);
}

// Correctly frees all memory associated with the OCR results
void free_ocr_results(GList *text_boxes) {
    if (!text_boxes) return;
    g_list_free_full(text_boxes, qscreen_text_box_free);
}


// --- START: NEW ASYNCHRONOUS IMPLEMENTATION ---

// This is the data we'll pass to our background thread.
typedef struct {
    char *path;
    OcrResultFunc callback;
    gpointer user_data;
} OcrTaskData;

// This function runs in the background thread.
static void ocr_thread_func(GTask *task, gpointer source_object, gpointer task_data, GCancellable *cancellable) {
    (void)source_object; (void)cancellable;
    OcrTaskData *data = task_data;

    // We simply call our original, blocking function here.
    // The GTask runs this in a separate thread, so the UI doesn't freeze.
    GList *result = run_ocr_on_screenshot(data->path);

    // This sends the result back to the main thread.
    g_task_return_pointer(task, result, (GDestroyNotify)free_ocr_results);
}

// This function is called in the main thread after the background thread is finished.
static void on_ocr_task_complete(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    (void)source_object;
    OcrTaskData *data = user_data;
    
    GList *text_boxes = g_task_propagate_pointer(G_TASK(res), NULL);

    // Call the user's original callback with the result.
    data->callback(text_boxes, data->user_data);

    // Clean up.
    g_free(data->path);
    g_free(data);
}

// This is the public function that starts the whole process.
void run_ocr_on_screenshot_async(const char *image_path, OcrResultFunc callback, gpointer user_data) {
    OcrTaskData *data = g_new0(OcrTaskData, 1);
    data->path = g_strdup(image_path);
    data->callback = callback;
    data->user_data = user_data;

    GTask *task = g_task_new(NULL, NULL, on_ocr_task_complete, data);
    g_task_set_task_data(task, data, NULL);
    g_task_run_in_thread(task, ocr_thread_func);
    g_object_unref(task);
}
// --- END: NEW ASYNCHRONOUS IMPLEMENTATION ---
======================================================================
### FILE: ././widgets/qscreen/qscreen.c
======================================================================
#include "qscreen.h"
#include "utils.h"
#include "features/ocr.h"
#include <gdk/gdkcairo.h>
#include <glib/gstdio.h>
#include <json-glib/json-glib.h>
#include <math.h>

typedef enum {
    MODE_REGION,
    MODE_WINDOW,
    MODE_TEXT
} SelectionMode;

typedef struct {
    QScreenState *app_state;
    GtkWindow *window;
    GtkWidget *drawing_area;
    GdkPixbuf *screenshot_pixbuf; // We need the pixbuf for the drawing function
    gchar *temp_screenshot_path;
    SelectionMode current_mode;
    GtkWidget *region_button, *window_button, *text_button, *screen_button, *save_button;
    guint animation_timer_id;
    gboolean is_animating;
    double current_x, current_y, current_w, current_h;
    double target_x, target_y, target_w, target_h;
    GtkGesture *drag_gesture;
    GtkEventController *motion_controller;
    GtkGesture *click_gesture;
    double drag_start_x, drag_start_y;
    GList *window_geometries, *text_boxes, *selected_text_boxes;
    GtkWidget *ocr_notification_revealer, *ocr_notification_stack;
    gboolean ocr_has_run;
} UIState;


// --- Forward Declarations ---
static void on_widget_realize(GtkWidget *widget, gpointer user_data);
static void on_window_destroy(GtkWidget *widget, gpointer user_data);
static void set_selection_target(UIState *state, double x, double y, double w, double h);
static void draw_selection_overlay(GtkDrawingArea *area, cairo_t *cr, int width, int height, gpointer data);
static void on_selection_finalized(UIState *state);
static void on_drag_begin(GtkGestureDrag *gesture, double x, double y, gpointer data);
static void on_drag_update(GtkGestureDrag *gesture, double offset_x, double offset_y, gpointer data);
static void on_drag_end(GtkGestureDrag *gesture, double offset_x, double offset_y, gpointer data);
static void on_mouse_motion(GtkEventControllerMotion *controller, double x, double y, gpointer data);
static void on_window_click(GtkGestureClick *gesture, int n_press, double x, double y, gpointer data);
static void set_mode(UIState *state, SelectionMode mode);
static void on_region_button_toggled(GtkToggleButton *button, gpointer user_data);
static void on_window_button_toggled(GtkToggleButton *button, gpointer user_data);
static void on_text_button_toggled(GtkToggleButton *button, gpointer user_data);
static void on_screen_button_clicked(GtkButton *button, gpointer user_data);
static void ui_state_free(gpointer data);
static void on_ocr_finished(GList *text_boxes, gpointer user_data);
static gboolean hide_notification_and_redraw(gpointer user_data);
static gboolean animation_tick(gpointer data);
static void create_rounded_rect_path(cairo_t *cr, double x, double y, double w, double h, double r);
static void on_key_pressed(GtkEventControllerKey* controller, guint keyval, guint keycode, GdkModifierType state, gpointer user_data);


// ===================================================================
//  Plugin Lifecycle Functions
// ===================================================================

static void on_widget_realize(GtkWidget *widget, gpointer user_data) {
    UIState *state = (UIState*)user_data;
    state->window = GTK_WINDOW(gtk_widget_get_root(widget));
}

static void on_window_destroy(GtkWidget *widget, gpointer user_data) {
    (void)widget; (void)user_data;
    g_print("qscreen: Window destroyed, cleaning up.\n");
}

static void ui_state_free(gpointer data) {
    UIState *state = data;
    if (!state) return;
    if (state->animation_timer_id > 0) g_source_remove(state->animation_timer_id);
    g_clear_object(&state->screenshot_pixbuf);
    if (state->temp_screenshot_path) {
        g_remove(state->temp_screenshot_path);
        g_free(state->temp_screenshot_path);
    }
    if (state->window_geometries) g_list_free_full(state->window_geometries, g_free);
    if (state->text_boxes) free_ocr_results(state->text_boxes);
    g_list_free(state->selected_text_boxes);
    g_free(state->app_state);
    g_free(state);
}


// ===================================================================
//  Internal UI Logic and Callbacks
// ===================================================================

static gboolean animation_tick(gpointer data) {
    UIState *state = data;
    state->current_x += (state->target_x - state->current_x) * 0.3;
    state->current_y += (state->target_y - state->current_y) * 0.3;
    state->current_w += (state->target_w - state->current_w) * 0.3;
    state->current_h += (state->target_h - state->current_h) * 0.3;
    if (fabs(state->current_x - state->target_x) < 0.5 && fabs(state->current_y - state->target_y) < 0.5 && fabs(state->current_w - state->target_w) < 0.5 && fabs(state->current_h - state->target_h) < 0.5) {
        state->current_x = state->target_x; state->current_y = state->target_y; state->current_w = state->target_w; state->current_h = state->target_h;
        state->is_animating = FALSE; state->animation_timer_id = 0;
        gtk_widget_queue_draw(state->drawing_area);
        return G_SOURCE_REMOVE;
    }
    gtk_widget_queue_draw(state->drawing_area);
    return G_SOURCE_CONTINUE;
}

static void set_selection_target(UIState *state, double x, double y, double w, double h) {
    state->target_x = x; state->target_y = y; state->target_w = w; state->target_h = h;
    if (!state->is_animating) {
        state->is_animating = TRUE;
        state->animation_timer_id = g_timeout_add(16, animation_tick, state);
    }
}

static void create_rounded_rect_path(cairo_t *cr, double x, double y, double w, double h, double r) {
    cairo_move_to(cr, x + r, y);
    cairo_arc(cr, x + w - r, y + r, r, -G_PI_2, 0); cairo_arc(cr, x + w - r, y + h - r, r, 0, G_PI_2);
    cairo_arc(cr, x + r, y + h - r, r, G_PI_2, G_PI); cairo_arc(cr, x + r, y + r, r, G_PI, G_PI * 1.5);
    cairo_close_path(cr);
}

// *** RESTORED to use gdk_cairo_set_source_pixbuf ***
static void draw_selection_overlay(GtkDrawingArea *area, cairo_t *cr, int width, int height, gpointer data) {
    (void)area; (void)width; (void)height;
    UIState *state = data;
    if (!state->screenshot_pixbuf) { cairo_set_source_rgba(cr, 0,0,0,0.01); cairo_paint(cr); return; }

    gdk_cairo_set_source_pixbuf(cr, state->screenshot_pixbuf, 0, 0);
    cairo_paint(cr);

    cairo_set_source_rgba(cr, 0.0, 0.0, 0.0, 0.5);
    if (state->current_mode != MODE_TEXT) cairo_paint(cr);
    if (state->current_w > 1 && state->current_h > 1 && state->current_mode != MODE_TEXT) {
        cairo_save(cr);
        create_rounded_rect_path(cr, state->current_x, state->current_y, state->current_w, state->current_h, 10.0);
        cairo_clip(cr);
        gdk_cairo_set_source_pixbuf(cr, state->screenshot_pixbuf, 0, 0);
        cairo_paint(cr);
        cairo_restore(cr);
        cairo_set_source_rgb(cr, 1.0, 1.0, 1.0); cairo_set_line_width(cr, 2.0);
        create_rounded_rect_path(cr, state->current_x, state->current_y, state->current_w, state->current_h, 10.0);
        cairo_stroke(cr);
    }
    if (state->current_mode == MODE_TEXT && state->text_boxes) {
        cairo_set_source_rgba(cr, 0.2, 0.5, 1.0, 0.3);
        for (GList *l = state->text_boxes; l != NULL; l = l->next) { if (!g_list_find(state->selected_text_boxes, l->data)) { QScreenTextBox *box = l->data; cairo_rectangle(cr, box->geometry.x, box->geometry.y, box->geometry.width, box->geometry.height); } }
        cairo_fill(cr); cairo_set_source_rgba(cr, 0.8, 0.5, 0.1, 0.5);
        for (GList *l = state->selected_text_boxes; l != NULL; l = l->next) { QScreenTextBox *box = l->data; cairo_rectangle(cr, box->geometry.x, box->geometry.y, box->geometry.width, box->geometry.height); }
        cairo_fill(cr); if (state->current_w > 1 && state->current_h > 1) {
            cairo_set_source_rgba(cr, 0.5, 0.5, 0.5, 0.2); cairo_rectangle(cr, state->current_x, state->current_y, state->current_w, state->current_h); cairo_fill(cr);
            cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 0.8); cairo_set_line_width(cr, 1.0); cairo_rectangle(cr, state->current_x, state->current_y, state->current_w, state->current_h); cairo_stroke(cr);
        }
    }
}

static void on_selection_finalized(UIState *state) {
    if (!state->window || !gtk_widget_get_visible(GTK_WIDGET(state->window))) return;
    if (state->current_w < 5 || state->current_h < 5) { gtk_window_destroy(state->window); return; }
    GdkRectangle geometry = { (int)round(state->current_x), (int)round(state->current_y), (int)round(state->current_w), (int)round(state->current_h) };
    gboolean save_to_disk = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(state->save_button));
    process_final_screenshot(state->temp_screenshot_path, &geometry, save_to_disk, state->app_state);
    gtk_window_destroy(state->window);
}

static void on_drag_begin(GtkGestureDrag *gesture, double x, double y, gpointer data) {
    (void)gesture; UIState *state = data; state->drag_start_x = x; state->drag_start_y = y; state->current_x = x; state->current_y = y; state->current_w = 0; state->current_h = 0;
    if (state->current_mode == MODE_TEXT) { g_list_free(state->selected_text_boxes); state->selected_text_boxes = NULL; }
}

static void on_drag_update(GtkGestureDrag *gesture, double offset_x, double offset_y, gpointer data) {
    (void)gesture; UIState *state = data; double end_x = state->drag_start_x + offset_x, end_y = state->drag_start_y + offset_y;
    state->current_x = MIN(state->drag_start_x, end_x); state->current_y = MIN(state->drag_start_y, end_y);
    state->current_w = fabs(end_x - state->drag_start_x); state->current_h = fabs(end_y - state->drag_start_y);
    if (state->current_mode == MODE_TEXT) {
        g_list_free(state->selected_text_boxes); state->selected_text_boxes = NULL; GdkRectangle selection_rect = { state->current_x, state->current_y, state->current_w, state->current_h };
        for (GList *l = state->text_boxes; l != NULL; l = l->next) { QScreenTextBox *box = l->data; if (gdk_rectangle_intersect(&box->geometry, &selection_rect, NULL)) state->selected_text_boxes = g_list_prepend(state->selected_text_boxes, box); }
    } gtk_widget_queue_draw(state->drawing_area);
}

static void on_drag_end(GtkGestureDrag *gesture, double offset_x, double offset_y, gpointer data) {
    (void)gesture; (void)offset_x; (void)offset_y; UIState *state = data;
    if (state->current_mode == MODE_TEXT) {
        if (state->selected_text_boxes) {
            GString *final_text = g_string_new(""); state->selected_text_boxes = g_list_reverse(state->selected_text_boxes);
            for (GList *l = state->selected_text_boxes; l != NULL; l = l->next) { QScreenTextBox *box = l->data; g_string_append(final_text, box->text); g_string_append_c(final_text, ' '); }
            run_command_with_stdin_sync("wl-copy", final_text->str); run_command_with_stdin_sync("notify-send 'Text Copied' 'Selected text is on your clipboard.'", NULL);
            g_string_free(final_text, TRUE);
        } gtk_window_destroy(state->window);
    } else on_selection_finalized(state);
}

static void on_mouse_motion(GtkEventControllerMotion *controller, double x, double y, gpointer data) {
    (void)controller; UIState *state = data; if (state->current_mode != MODE_WINDOW) return; gboolean found_window = FALSE;
    for (GList *l = state->window_geometries; l != NULL; l = l->next) { GdkRectangle *rect = l->data; if (x >= rect->x && x <= (rect->x + rect->width) && y >= rect->y && y <= (rect->y + rect->height)) { set_selection_target(state, rect->x, rect->y, rect->width, rect->height); found_window = TRUE; break; } }
    if (!found_window) set_selection_target(state, x, y, 0, 0);
}

static void on_window_click(GtkGestureClick *gesture, int n_press, double x, double y, gpointer data) {
    (void)gesture; (void)n_press; (void)x; (void)y; UIState *state = data;
    if (state->current_mode == MODE_WINDOW && state->current_w > 0 && state->current_h > 0) on_selection_finalized(state);
}

static void on_key_pressed(GtkEventControllerKey* controller, guint keyval, guint keycode, GdkModifierType state, gpointer user_data) {
    (void)controller; (void)keycode; (void)state;
    UIState *ui_state = user_data;
    if (keyval == GDK_KEY_Escape) {
        if (ui_state && ui_state->window) { gtk_window_destroy(ui_state->window); }
    }
}

static void set_mode(UIState *state, SelectionMode mode) {
    state->current_mode = mode;
    gtk_event_controller_set_propagation_phase(GTK_EVENT_CONTROLLER(state->motion_controller), (mode == MODE_WINDOW) ? GTK_PHASE_CAPTURE : GTK_PHASE_NONE);
    gtk_event_controller_set_propagation_phase(GTK_EVENT_CONTROLLER(state->click_gesture), (mode == MODE_WINDOW) ? GTK_PHASE_CAPTURE : GTK_PHASE_NONE);
    gtk_event_controller_set_propagation_phase(GTK_EVENT_CONTROLLER(state->drag_gesture), (mode != MODE_WINDOW) ? GTK_PHASE_CAPTURE : GTK_PHASE_NONE);
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(state->region_button), mode == MODE_REGION);
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(state->window_button), mode == MODE_WINDOW);
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(state->text_button), mode == MODE_TEXT);
    if(mode == MODE_TEXT && !state->ocr_has_run){
        state->ocr_has_run = TRUE;
        gtk_stack_set_visible_child_name(GTK_STACK(state->ocr_notification_stack),"scanning");
        gtk_revealer_set_reveal_child(GTK_REVEALER(state->ocr_notification_revealer),TRUE);
        run_ocr_on_screenshot_async(state->temp_screenshot_path, on_ocr_finished, state);
    } else {
        gtk_widget_queue_draw(state->drawing_area);
    }
}

static void on_region_button_toggled(GtkToggleButton *b, gpointer d) { if(gtk_toggle_button_get_active(b)){ UIState *s=d; set_selection_target(s, s->current_x+s->current_w/2, s->current_y+s->current_h/2,0,0); set_mode(s,MODE_REGION); }}
static void on_window_button_toggled(GtkToggleButton *b, gpointer d) { if(gtk_toggle_button_get_active(b)){ UIState *s=d; set_selection_target(s, s->current_x+s->current_w/2, s->current_y+s->current_h/2,0,0); set_mode(s,MODE_WINDOW); }}
static void on_text_button_toggled(GtkToggleButton *b, gpointer d) { if(gtk_toggle_button_get_active(b)){ UIState *s=d; set_selection_target(s, s->current_x+s->current_w/2, s->current_y+s->current_h/2,0,0); set_mode(s,MODE_TEXT); }}
static void on_screen_button_clicked(GtkButton *b, gpointer d) { (void)b; UIState *s=d; GdkRectangle g={0,0,gdk_pixbuf_get_width(s->screenshot_pixbuf),gdk_pixbuf_get_height(s->screenshot_pixbuf)}; gboolean save=gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(s->save_button)); process_final_screenshot(s->temp_screenshot_path,&g,save,s->app_state); gtk_window_destroy(s->window); }
static gboolean hide_notification_and_redraw(gpointer d) { UIState *s=d; gtk_revealer_set_reveal_child(GTK_REVEALER(s->ocr_notification_revealer),FALSE); gtk_widget_queue_draw(s->drawing_area); return G_SOURCE_REMOVE; }
static void on_ocr_finished(GList *text_boxes, gpointer data) {
    UIState *state = data; if (!state || !GTK_IS_WIDGET(state->window) || !gtk_widget_get_visible(GTK_WIDGET(state->window))) { if (text_boxes) free_ocr_results(text_boxes); return; }
    state->text_boxes = text_boxes; gtk_stack_set_visible_child_name(GTK_STACK(state->ocr_notification_stack), "done"); g_timeout_add(750, hide_notification_and_redraw, state);
}


// ===================================================================
//  Plugin Entry Point
// ===================================================================

G_MODULE_EXPORT GtkWidget* create_widget(const char *config_string) {
    g_autoptr(JsonParser) parser = json_parser_new();
    if (!config_string || !json_parser_load_from_data(parser, config_string, -1, NULL)) {
        g_warning("qscreen: Failed to parse config string.");
        return NULL;
    }
    JsonObject *root_obj = json_node_get_object(json_parser_get_root(parser));

    const char *temp_path = json_object_get_string_member(root_obj, "temp_screenshot_path");
    if (!temp_path) {
        g_warning("qscreen: 'temp_screenshot_path' not provided in config. Cannot proceed.");
        return NULL;
    }

    UIState *state = g_new0(UIState, 1);
    state->app_state = g_new0(QScreenState, 1);
    state->temp_screenshot_path = g_strdup(temp_path);

    if (json_object_has_member(root_obj, "config")) {
        JsonObject *config = json_object_get_object_member(root_obj, "config");
        const char *mode_str = json_object_get_string_member_with_default(config, "mode", "region");
        if (g_strcmp0(mode_str, "text") == 0) state->app_state->initial_mode = QSCREEN_MODE_TEXT;
        else if (g_strcmp0(mode_str, "window") == 0) state->app_state->initial_mode = QSCREEN_MODE_WINDOW;
        else state->app_state->initial_mode = QSCREEN_MODE_REGION;
        state->app_state->save_on_launch = json_object_get_boolean_member_with_default(config, "save", FALSE);
    }
    
    g_autoptr(GError) error = NULL;
    state->screenshot_pixbuf = gdk_pixbuf_new_from_file(state->temp_screenshot_path, &error);
    if (error) {
        g_warning("qscreen: Failed to load pre-captured screenshot '%s': %s", state->temp_screenshot_path, error->message);
        ui_state_free(state);
        return NULL;
    }

    GtkWidget *overlay_widget = gtk_overlay_new();
    gtk_widget_set_name(overlay_widget, "qscreen-widget");
    g_object_set_data_full(G_OBJECT(overlay_widget), "ui-state", state, ui_state_free);
    
    g_signal_connect(overlay_widget, "unrealize", G_CALLBACK(on_window_destroy), NULL);
    
    GtkEventController *key_controller = gtk_event_controller_key_new();
    g_signal_connect(key_controller, "key-pressed", G_CALLBACK(on_key_pressed), state);
    gtk_widget_add_controller(overlay_widget, key_controller);
    
    state->drawing_area = gtk_drawing_area_new();
    gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(state->drawing_area), draw_selection_overlay, state, NULL);
    gtk_overlay_set_child(GTK_OVERLAY(overlay_widget), state->drawing_area);

    state->ocr_notification_revealer = gtk_revealer_new();
    gtk_revealer_set_transition_type(GTK_REVEALER(state->ocr_notification_revealer), GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN);
    gtk_revealer_set_transition_duration(GTK_REVEALER(state->ocr_notification_revealer), 250);
    GtkWidget *notification_container = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_add_css_class(notification_container, "ocr-notification");
    state->ocr_notification_stack = gtk_stack_new();
    gtk_stack_set_transition_type(GTK_STACK(state->ocr_notification_stack), GTK_STACK_TRANSITION_TYPE_SLIDE_UP);
    gtk_stack_set_transition_duration(GTK_STACK(state->ocr_notification_stack), 300);
    GtkWidget *scanning_content = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
    GtkWidget *spinner = gtk_spinner_new(); gtk_spinner_start(GTK_SPINNER(spinner));
    gtk_box_append(GTK_BOX(scanning_content), spinner); gtk_box_append(GTK_BOX(scanning_content), gtk_label_new("Scanning for text..."));
    GtkWidget *done_content = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
    gtk_box_append(GTK_BOX(done_content), gtk_label_new(" Done!"));
    gtk_stack_add_named(GTK_STACK(state->ocr_notification_stack), scanning_content, "scanning");
    gtk_stack_add_named(GTK_STACK(state->ocr_notification_stack), done_content, "done");
    gtk_box_append(GTK_BOX(notification_container), state->ocr_notification_stack);
    gtk_revealer_set_child(GTK_REVEALER(state->ocr_notification_revealer), notification_container);
    gtk_overlay_add_overlay(GTK_OVERLAY(overlay_widget), state->ocr_notification_revealer);
    gtk_widget_set_valign(state->ocr_notification_revealer, GTK_ALIGN_START);
    gtk_widget_set_halign(state->ocr_notification_revealer, GTK_ALIGN_CENTER);
    
    GtkWidget *panel_frame = gtk_frame_new(NULL); gtk_widget_add_css_class(panel_frame, "panel");
    GtkWidget *main_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_set_margin_start(main_box, 15); gtk_widget_set_margin_end(main_box, 15); gtk_widget_set_margin_top(main_box, 15); gtk_widget_set_margin_bottom(main_box, 15);
    gtk_frame_set_child(GTK_FRAME(panel_frame), main_box);
    GtkWidget *button_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 12);
    
    state->region_button = gtk_toggle_button_new(); gtk_button_set_child(GTK_BUTTON(state->region_button), gtk_image_new_from_icon_name("image-x-generic-symbolic"));
    state->window_button = gtk_toggle_button_new(); gtk_button_set_child(GTK_BUTTON(state->window_button), gtk_image_new_from_icon_name("window-new-symbolic"));
    state->text_button = gtk_toggle_button_new(); gtk_button_set_child(GTK_BUTTON(state->text_button), gtk_image_new_from_icon_name("edit-find-symbolic"));
    gtk_widget_set_tooltip_text(state->text_button, "Select Text (OCR)");
    gtk_toggle_button_set_group(GTK_TOGGLE_BUTTON(state->window_button), GTK_TOGGLE_BUTTON(state->region_button));
    gtk_toggle_button_set_group(GTK_TOGGLE_BUTTON(state->text_button), GTK_TOGGLE_BUTTON(state->region_button));
    state->screen_button = gtk_button_new_from_icon_name("video-display-symbolic");
    state->save_button = gtk_toggle_button_new(); gtk_button_set_child(GTK_BUTTON(state->save_button), gtk_image_new_from_icon_name("document-save-symbolic"));
    gtk_widget_set_tooltip_text(state->save_button, "Save to disk"); gtk_widget_add_css_class(state->save_button, "save-button");
    gtk_box_append(GTK_BOX(button_box), state->region_button);
    gtk_box_append(GTK_BOX(button_box), state->window_button);
    gtk_box_append(GTK_BOX(button_box), state->text_button);
    gtk_box_append(GTK_BOX(button_box), state->screen_button);
    GtkWidget *separator = gtk_separator_new(GTK_ORIENTATION_VERTICAL); gtk_widget_add_css_class(separator, "vertical-separator");
    gtk_box_append(GTK_BOX(button_box), separator);
    gtk_box_append(GTK_BOX(button_box), state->save_button);
    gtk_box_append(GTK_BOX(main_box), button_box);
    
    gtk_overlay_add_overlay(GTK_OVERLAY(overlay_widget), panel_frame);
    gtk_widget_set_valign(panel_frame, GTK_ALIGN_END); gtk_widget_set_halign(panel_frame, GTK_ALIGN_CENTER);
    gtk_widget_set_margin_bottom(panel_frame, 40);

    g_signal_connect(state->region_button, "toggled", G_CALLBACK(on_region_button_toggled), state);
    g_signal_connect(state->window_button, "toggled", G_CALLBACK(on_window_button_toggled), state);
    g_signal_connect(state->text_button, "toggled", G_CALLBACK(on_text_button_toggled), state);
    g_signal_connect(state->screen_button, "clicked", G_CALLBACK(on_screen_button_clicked), state);
    
    state->motion_controller = gtk_event_controller_motion_new();
    g_signal_connect(state->motion_controller, "motion", G_CALLBACK(on_mouse_motion), state);
    gtk_widget_add_controller(state->drawing_area, state->motion_controller);
    state->click_gesture = gtk_gesture_click_new();
    g_signal_connect(state->click_gesture, "pressed", G_CALLBACK(on_window_click), state);
    gtk_widget_add_controller(state->drawing_area, GTK_EVENT_CONTROLLER(state->click_gesture));
    state->drag_gesture = gtk_gesture_drag_new();
    g_signal_connect(state->drag_gesture, "drag-begin", G_CALLBACK(on_drag_begin), state);
    g_signal_connect(state->drag_gesture, "drag-update", G_CALLBACK(on_drag_update), state);
    g_signal_connect(state->drag_gesture, "drag-end", G_CALLBACK(on_drag_end), state);
    gtk_widget_add_controller(state->drawing_area, GTK_EVENT_CONTROLLER(state->drag_gesture));

    state->window_geometries = get_hyprland_windows_geometry(state->app_state);
    
    set_mode(state, (SelectionMode)state->app_state->initial_mode);
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(state->save_button), state->app_state->save_on_launch);
    
    g_signal_connect(overlay_widget, "realize", G_CALLBACK(on_widget_realize), state);
    
    return overlay_widget;
}
======================================================================
### FILE: ././widgets/qscreen/utils.c
======================================================================
#include "utils.h"
#include <gio/gio.h>
#include <json-glib/json-glib.h>
#include <glib/gstdio.h>
#include <gtk/gtk.h>
#include <string.h>

// --- THE FIX: PART 1 ---
// Helper struct to pass multiple pieces of data to our async callback.
// This allows us to send both the new path AND the original UI state.
typedef struct {
    gchar *temp_path;
    gpointer original_user_data;
} CaptureData;
// --- END FIX ---

static void run_command_async(const gchar *command, GChildWatchFunc exit_callback, gpointer user_data) {
    g_autoptr(GError) error = NULL;
    GPid child_pid;

    g_spawn_async(
        NULL, (gchar*[]){ "sh", "-c", (gchar*)command, NULL }, NULL,
        G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH,
        NULL, NULL, &child_pid, &error
    );

    if (error) {
        g_warning("Failed to start async command '%s': %s", command, error->message);
        return;
    }
    
    if (exit_callback) {
        g_child_watch_add(child_pid, exit_callback, user_data);
    } else {
        g_spawn_close_pid(child_pid);
    }
}

void run_command_with_stdin_sync(const gchar *command, const gchar *input) {
    if (!command) return;

    g_autoptr(GError) error = NULL;
    g_autoptr(GSubprocess) subprocess = g_subprocess_new(
        G_SUBPROCESS_FLAGS_STDIN_PIPE,
        &error,
        "sh", "-c", command, NULL);

    if (error) {
        g_warning("Failed to create subprocess for command '%s': %s", command, error->message);
        return;
    }

    g_subprocess_communicate_utf8(subprocess, input, NULL, NULL, NULL, &error);
    
    if (error) {
        g_warning("Failed to communicate with subprocess for command '%s': %s", command, error->message);
    }
}

void process_fullscreen_screenshot(QScreenState *state) {
    g_autofree char* command = NULL;
    if (state->save_on_launch) {
        g_autofree char *pictures_dir = g_strdup(g_get_user_special_dir(G_USER_DIRECTORY_PICTURES));
        g_autoptr(GDateTime) now = g_date_time_new_now_local();
        g_autofree char *timestamp = g_date_time_format(now, "%Y-%m-%d_%H-%M-%S");
        g_autofree char *filename = g_strdup_printf("screenshot-%s.png", timestamp);
        g_autofree char *output_path = g_build_filename(pictures_dir, filename, NULL);
        command = g_strdup_printf("grim \"%s\" && wl-copy < \"%s\"", output_path, output_path);
    } else {
        command = g_strdup("grim - | wl-copy");
    }

    g_print("Running direct command (sync): %s\n", command);
    
    g_autoptr(GError) error = NULL;
    gint exit_status = 0;
    gboolean success = g_spawn_sync(NULL, (gchar*[]){ "sh", "-c", command, NULL }, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, NULL, NULL, &exit_status, &error);

    if (success && exit_status == 0 && !error) {
        const char* msg = state->save_on_launch 
            ? "Screenshot saved and copied." 
            : "Image is on your clipboard.";
        g_autofree char* notify_cmd = g_strdup_printf("notify-send 'Screenshot Captured' '%s'", msg);
        run_command_async(notify_cmd, NULL, NULL);
    } else {
        g_warning("Fullscreen screenshot command failed: %s", error ? error->message : "Unknown error");
        run_command_async("notify-send -u critical 'Screenshot Failed' 'Could not capture the screen.'", NULL, NULL);
    }
}

void process_final_screenshot(const char *source_path, GdkRectangle *geometry, gboolean save_to_disk, QScreenState *state) {
    g_autofree char *output_path = NULL;

    if (save_to_disk) {
        g_autofree char *pictures_dir = g_strdup(g_get_user_special_dir(G_USER_DIRECTORY_PICTURES));
        g_autoptr(GDateTime) now = g_date_time_new_now_local();
        g_autofree char *timestamp = g_date_time_format(now, "%Y-%m-%d_%H-%M-%S");
        g_autofree char *filename = g_strdup_printf("screenshot-%s.png", timestamp);
        output_path = g_build_filename(pictures_dir, filename, NULL);
    } else {
        output_path = g_build_filename(g_get_tmp_dir(), "qscreen_final.png", NULL);
    }
    
    g_autofree char* crop_geom = g_strdup_printf("%dx%d+%d+%d", geometry->width, geometry->height, geometry->x, geometry->y);

    GString *command_str = g_string_new("");
    
    g_string_printf(command_str, "magick \"%s\" -crop %s \"%s\" && wl-copy < \"%s\"",
                    source_path, crop_geom, output_path, output_path);

    if (!save_to_disk) {
        g_string_append_printf(command_str, " && rm \"%s\"", output_path);
    }

    g_autofree char *command = g_string_free(command_str, FALSE);
    g_print("Running final command (sync): %s\n", command);

    g_autoptr(GError) error = NULL;
    gint exit_status = 0;
    gboolean success = g_spawn_sync(NULL, (gchar*[]){ "sh", "-c", command, NULL }, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, NULL, NULL, &exit_status, &error);
    
    if (success && exit_status == 0 && !error) {
        const char* msg = save_to_disk 
            ? "Screenshot saved and copied." 
            : "Image is on your clipboard.";
        g_autofree char* notify_cmd = g_strdup_printf("notify-send 'Screenshot Captured' '%s'", msg);
        run_command_async(notify_cmd, NULL, NULL);
    } else {
        g_warning("Final screenshot command failed: %s", error ? error->message : "Unknown error");
        run_command_async("notify-send -u critical 'Screenshot Failed' 'Could not process the image.'", NULL, NULL);
    }

    // In the plugin version, the cleanup of the temp file is handled
    // by the UIState struct's destructor.
}

// --- THE FIX: PART 2 ---
// The corrected function now uses the CaptureData struct.
void capture_fullscreen_for_overlay(GChildWatchFunc on_captured, gpointer user_data) {
    // 1. Create a bundle to hold both the path and your UIState*
    CaptureData *capture_data = g_new(CaptureData, 1);
    capture_data->temp_path = g_build_filename(g_get_tmp_dir(), "qscreen_overlay.png", NULL);
    capture_data->original_user_data = user_data; // Keep track of the original state

    g_autofree char *grim_command = g_strdup_printf("grim \"%s\"", capture_data->temp_path);
    g_print("Capturing background: %s\n", grim_command);

    GPid pid;
    g_autoptr(GError) error = NULL;
    g_spawn_async(NULL, (gchar*[]){ "sh", "-c", grim_command, NULL }, NULL,
                  G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH,
                  NULL, NULL, &pid, &error);

    if (error) {
        g_warning("Failed to spawn grim: %s", error->message);
        g_free(capture_data->temp_path);
        g_free(capture_data);
        return;
    }

    // 2. Pass the BUNDLE to the callback, not just the path.
    g_child_watch_add(pid, on_captured, capture_data);
}
// --- END FIX ---


static gchar* hyprland_ipc_get_reply(const char *command) {
    g_autofree char *signature = g_strdup(g_getenv("HYPRLAND_INSTANCE_SIGNATURE"));
    if (!signature) { g_warning("HYPRLAND_INSTANCE_SIGNATURE not set."); return NULL; }
    g_autofree char *socket_path = g_build_filename(g_get_user_runtime_dir(), "hypr", signature, ".socket.sock", NULL);

    g_autoptr(GError) error = NULL;
    g_autoptr(GSocketClient) client = g_socket_client_new();
    g_autoptr(GSocketAddress) address = g_unix_socket_address_new(socket_path);
    g_autoptr(GSocketConnection) conn = g_socket_client_connect(client, G_SOCKET_CONNECTABLE(address), NULL, &error);
    if (error) { g_warning("Failed to connect to Hyprland socket: %s", error->message); return NULL; }

    GInputStream *istream = g_io_stream_get_input_stream(G_IO_STREAM(conn));
    g_output_stream_write_all(g_io_stream_get_output_stream(G_IO_STREAM(conn)), command, strlen(command), NULL, NULL, NULL);

    GByteArray *bytes = g_byte_array_new();
    char buffer[4096]; gssize read;
    while ((read = g_input_stream_read(istream, buffer, sizeof(buffer), NULL, &error)) > 0) {
        g_byte_array_append(bytes, (const guint8*)buffer, read);
    }
    if (error) { g_warning("Failed to read from Hyprland socket: %s", error->message); g_byte_array_free(bytes, TRUE); return NULL; }

    g_byte_array_append(bytes, (const guint8*)"\0", 1);
    return (gchar*)g_byte_array_free(bytes, FALSE);
}

GList* get_hyprland_windows_geometry(QScreenState *state) {
    (void)state;
    g_autofree gchar *monitors_reply = hyprland_ipc_get_reply("j/monitors");
    if (!monitors_reply) return NULL;

    g_autoptr(JsonParser) monitor_parser = json_parser_new();
    json_parser_load_from_data(monitor_parser, monitors_reply, -1, NULL);
    JsonNode *root_node = json_parser_get_root(monitor_parser);
    if (!root_node) { g_warning("Failed to parse monitors JSON."); return NULL; }
    JsonArray *monitors = json_node_get_array(root_node);
    
    gint64 monitor_x = 0, monitor_y = 0;
    gint64 active_workspace_id = -1;
    for (guint i = 0; i < json_array_get_length(monitors); i++) {
        JsonObject *mon_obj = json_array_get_object_element(monitors, i);
        if (json_object_get_boolean_member(mon_obj, "focused")) {
            monitor_x = json_object_get_int_member(mon_obj, "x");
            monitor_y = json_object_get_int_member(mon_obj, "y");
            active_workspace_id = json_object_get_int_member(json_object_get_object_member(mon_obj, "activeWorkspace"), "id");
            break;
        }
    }
    
    g_autofree gchar *clients_reply = hyprland_ipc_get_reply("j/clients");
    if (!clients_reply) return NULL;

    g_autoptr(JsonParser) client_parser = json_parser_new();
    json_parser_load_from_data(client_parser, clients_reply, -1, NULL);
    root_node = json_parser_get_root(client_parser);
    if (!root_node) { g_warning("Failed to parse clients JSON."); return NULL; }
    JsonArray *clients = json_node_get_array(root_node);
    
    GList *result = NULL;
    for (guint i = 0; i < json_array_get_length(clients); i++) {
        JsonObject *obj = json_array_get_object_element(clients, i);
        if (json_object_has_member(obj, "workspace")) {
            JsonObject *workspace_obj = json_object_get_object_member(obj, "workspace");
            if (json_object_get_int_member(workspace_obj, "id") == active_workspace_id) {
                JsonArray *at = json_object_get_array_member(obj, "at");
                JsonArray *size = json_object_get_array_member(obj, "size");
                
                GdkRectangle *rect = g_new(GdkRectangle, 1);
                rect->x = json_array_get_int_element(at, 0) - monitor_x;
                rect->y = json_array_get_int_element(at, 1) - monitor_y;
                rect->width = json_array_get_int_element(size, 0);
                rect->height = json_array_get_int_element(size, 1);
                result = g_list_prepend(result, rect);
            }
        }
    }
    return g_list_reverse(result);
}

gboolean check_dependencies(void) {
    // This function is not used in the plugin version, as dependencies
    // are assumed to be handled by the user's system setup.
    // It can be removed or left here for completeness.
    return TRUE;
}
======================================================================
### FILE: ././widgets/qscreen/meson.build
======================================================================
# aurora-shell/widgets/qscreen/meson.build

# Define the directory where the final .so plugin will be installed.
widget_install_dir = get_option('libdir') / 'aurora-shell' / 'widgets'

# Get the C compiler so we can find the math library.
c_compiler = meson.get_compiler('c')
m_dep = c_compiler.find_library('m', required: true) 

# List the libraries our plugin needs to link against.
dependencies = [
  dependency('gtk4'),
  dependency('json-glib-1.0'),
  m_dep  
]

# List all the .c source files that make up this plugin.
sources = [
  'qscreen.c',
  'utils.c',
  'features/ocr.c'
]

# The command to build the shared library (the .so plugin).
shared_library('qscreen', sources,
  dependencies: dependencies,
  # This tells the compiler where to look for headers like "qscreen.h".
  include_directories: '.',
  # Install the final .so file.
  install: true,
  install_dir: widget_install_dir,
  # This is crucial: it creates "qscreen.so" instead of "libqscreen.so".
  name_prefix: '',
)
======================================================================
### FILE: ././widgets/calendar/calendar.c
======================================================================
#define _GNU_SOURCE
#include <gtk/gtk.h>
#include <time.h>
#include <json-glib/json-glib.h>
#include <math.h>
#include <glib/gstdio.h>

#define WIDGET_WIDTH 550

// --- DATA STRUCTURES (Unchanged) ---
typedef struct { GtkWidget *main_container; GtkLabel *month_label; GtkGrid *calendar_grid; GtkListBox *upcoming_list_box; GtkPopover *add_event_popover; GtkEntry *add_event_title_entry; GtkCheckButton *add_event_allday_check; GtkDropDown *add_event_hour_dropdown; GtkDropDown *add_event_minute_dropdown; GtkDropDown *add_event_ampm_dropdown; GtkWidget *add_event_time_box; GDateTime *current_date; GHashTable *events; GHashTable *permanent_events; guint grid_population_timer_id; } CalendarWidget;
typedef struct { gchar *time; gchar *title; } Event;
typedef struct { GDateTime *datetime; Event *event; } UpcomingEvent;
typedef struct { int day_to_add; int days_in_month; int grid_x; int grid_y; int current_y; int current_m; int today_y; int today_m; int today_d; } GridPopulationState;
typedef struct { GHashTable *events; GHashTable *permanent_events; } LoadedData;
typedef struct { CalendarWidget *widget; gchar *date_key; Event *event_to_delete; GtkPopover *popover; } DeleteEventData;

// Forward declarations of your original functions
static void start_grid_population(CalendarWidget *widget);
static void populate_upcoming_events_list(CalendarWidget *widget);

// --- MEMORY & HELPERS (Unchanged) ---
static void free_event(gpointer data) { Event *e = (Event *)data; g_free(e->time); g_free(e->title); g_free(e); }
static void free_event_list(gpointer data) { g_list_free_full((GList *)data, free_event); }
static void free_upcoming_event(gpointer data) { UpcomingEvent *ue = (UpcomingEvent *)data; g_date_time_unref(ue->datetime); g_free(ue); }
static void free_delete_event_data(gpointer data) { DeleteEventData *d = (DeleteEventData *)data; g_free(d->date_key); g_free(d); }
static gchar* format_time_to_12h(const gchar *time_24h) { if (g_strcmp0(time_24h, "all-day") == 0) return g_strdup("All-day"); int h, m; if (sscanf(time_24h, "%d:%d", &h, &m) == 2) { const char *ap = (h < 12) ? "AM" : "PM"; if (h == 0) h = 12; else if (h > 12) h -= 12; return g_strdup_printf("%d:%02d %s", h, m, ap); } return g_strdup(time_24h); }
static void destroy_popover_on_close(GtkPopover *popover, gpointer user_data) { (void)user_data; gtk_widget_unparent(GTK_WIDGET(popover)); }

// --- DATA HANDLING (Unchanged) ---
static GHashTable* load_event_file(const char *rel_path) { gchar *path = g_build_filename(g_get_home_dir(), "VS Code Projects/C-projects/aurora-shell/widgets/calendar/", rel_path, NULL); GHashTable *et = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, free_event_list); JsonParser *p = json_parser_new(); if (!json_parser_load_from_file(p, path, NULL)) { g_object_unref(p); g_free(path); return et; } JsonObject *ro = json_node_get_object(json_parser_get_root(p)); JsonObjectIter i; const gchar *dk; JsonNode *mn; for (json_object_iter_init(&i, ro); json_object_iter_next(&i, &dk, &mn);) { GList *el = NULL; JsonArray *ea = json_node_get_array(mn); for (guint j = 0; j < json_array_get_length(ea); j++) { JsonObject *eo = json_array_get_object_element(ea, j); Event *e = g_new(Event, 1); e->time = g_strdup(json_object_get_string_member(eo, "time")); e->title = g_strdup(json_object_get_string_member(eo, "title")); el = g_list_prepend(el, e); } g_hash_table_insert(et, g_strdup(dk), g_list_reverse(el)); } g_object_unref(p); g_free(path); return et; }
static void load_data_in_thread(GTask *task, gpointer s, gpointer t, GCancellable *c) { (void)s;(void)t;(void)c; LoadedData *ld = g_new(LoadedData, 1); ld->events = load_event_file("data/events.json"); ld->permanent_events = load_event_file("data/permanent_events.json"); g_task_return_pointer(task, ld, g_free); }
static void save_events(CalendarWidget *widget) { gchar *path = g_build_filename(g_get_home_dir(), "VS Code Projects/C-projects/aurora-shell/widgets/calendar/data/events.json", NULL); JsonObject *ro = json_object_new(); GHashTableIter i; gpointer k, v; g_hash_table_iter_init(&i, widget->events); while (g_hash_table_iter_next(&i, &k, &v)) { JsonArray *ja = json_array_new(); for (GList *l = (GList *)v; l; l = l->next) { Event *e = (Event *)l->data; JsonObject *jo = json_object_new(); json_object_set_string_member(jo, "time", e->time); json_object_set_string_member(jo, "title", e->title); json_array_add_object_element(ja, jo); } json_object_set_array_member(ro, (gchar *)k, ja); } JsonGenerator *g = json_generator_new(); json_generator_set_root(g, json_node_init_object(json_node_alloc(), ro)); json_generator_set_pretty(g, TRUE); json_generator_to_file(g, path, NULL); g_object_unref(g); g_free(path); }
static void on_data_loaded(GObject *s, GAsyncResult *res, gpointer user_data) { (void)s; CalendarWidget *w = (CalendarWidget *)user_data; GError *err = NULL; LoadedData *ld = g_task_propagate_pointer(G_TASK(res), &err); if (err) { g_warning("Failed: %s", err->message); g_error_free(err); return; } if (w->events) g_hash_table_unref(w->events); if (w->permanent_events) g_hash_table_unref(w->permanent_events); w->events = ld->events; w->permanent_events = ld->permanent_events; g_free(ld); start_grid_population(w); populate_upcoming_events_list(w); }

// --- UI CALLBACKS (Your original, correct functions) ---
static void on_delete_event_clicked(GtkButton *b, gpointer user_data) { (void)b; DeleteEventData *d = (DeleteEventData*)user_data; CalendarWidget *w = d->widget; gpointer k=NULL, v=NULL; if (!g_hash_table_steal_extended(w->events, d->date_key, &k, &v)) return; GList *l = (GList*)v, *link = g_list_find(l, d->event_to_delete); if (link) { GList *nl = g_list_delete_link(l, link); free_event(d->event_to_delete); if (nl) g_hash_table_insert(w->events, k, nl); else g_free(k); } else g_hash_table_insert(w->events, k, l); save_events(w); start_grid_population(w); populate_upcoming_events_list(w); gtk_popover_popdown(d->popover); }
static void on_add_event_save(GtkButton *b, gpointer user_data) { (void)b; CalendarWidget *w = (CalendarWidget *)user_data; const gchar *dk = g_object_get_data(G_OBJECT(w->add_event_popover), "date-key"); const char *t = gtk_editable_get_text(GTK_EDITABLE(w->add_event_title_entry)); if (!dk || strlen(t) == 0) return; gchar *ts; if (gtk_check_button_get_active(w->add_event_allday_check)) ts = g_strdup("all-day"); else { guint h = gtk_drop_down_get_selected(w->add_event_hour_dropdown)+1, m = gtk_drop_down_get_selected(w->add_event_minute_dropdown)*5, is_pm = gtk_drop_down_get_selected(w->add_event_ampm_dropdown), h24 = h; if (is_pm && h!=12) h24+=12; else if (!is_pm && h==12) h24=0; ts = g_strdup_printf("%02d:%02d", h24, m); } Event *e = g_new(Event,1); e->time = ts; e->title = g_strdup(t); GList *l = g_hash_table_lookup(w->events, dk); if (!l) { l = g_list_append(NULL, e); g_hash_table_insert(w->events, g_strdup(dk), l); } else { l = g_list_append(l, e); } save_events(w); start_grid_population(w); populate_upcoming_events_list(w); gtk_popover_popdown(w->add_event_popover); }
static void on_allday_toggled(GtkCheckButton *cb, GParamSpec *p, gpointer user_data) { (void)p; gtk_widget_set_sensitive(((CalendarWidget*)user_data)->add_event_time_box, !gtk_check_button_get_active(cb)); }
static void on_day_left_clicked(GtkButton *button, gpointer user_data) { CalendarWidget *w = (CalendarWidget*)user_data; const gchar *dkf = g_object_get_data(G_OBJECT(button), "date-key"); gchar *dkp = g_strdup_printf("%d-%d", g_date_time_get_month(w->current_date), atoi(gtk_button_get_label(GTK_BUTTON(button)))); GList *re = g_hash_table_lookup(w->events, dkf), *pe = g_hash_table_lookup(w->permanent_events, dkp); g_free(dkp); if (!re && !pe) return; GtkWidget *pop = gtk_popover_new(); gtk_widget_add_css_class(pop, "event-popover"); GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5); gtk_popover_set_child(GTK_POPOVER(pop), vbox); for (GList *l=pe;l;l=l->next) { Event *e=(Event*)l->data; GtkWidget *hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0); gtk_widget_add_css_class(hbox,"event-entry"); GtkWidget *icon=gtk_image_new_from_icon_name("starred-symbolic"); gtk_widget_add_css_class(icon,"permanent-event-icon"); gchar *t12=format_time_to_12h(e->time); GtkWidget *tl=gtk_label_new(t12); g_free(t12); gtk_widget_add_css_class(tl,"event-time"); GtkWidget *title=gtk_label_new(e->title); gtk_label_set_xalign(GTK_LABEL(title),0.0); gtk_widget_add_css_class(title,"event-title"); gtk_box_append(GTK_BOX(hbox),icon); gtk_box_append(GTK_BOX(hbox),tl); gtk_box_append(GTK_BOX(hbox),title); gtk_box_append(GTK_BOX(vbox),hbox); } for (GList *l=re;l;l=l->next) { Event *e=(Event*)l->data; GtkWidget *hbox=gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0); gtk_widget_add_css_class(hbox,"event-entry"); gchar *t12=format_time_to_12h(e->time); GtkWidget *tl=gtk_label_new(t12); g_free(t12); gtk_widget_add_css_class(tl,"event-time"); GtkWidget *title=gtk_label_new(e->title); gtk_label_set_xalign(GTK_LABEL(title),0.0); gtk_widget_add_css_class(title,"event-title"); gtk_widget_set_hexpand(title,TRUE); GtkWidget *db=gtk_button_new_from_icon_name("edit-delete-symbolic"); gtk_widget_add_css_class(db,"delete-button"); DeleteEventData *ded=g_new(DeleteEventData,1); ded->widget=w; ded->date_key=g_strdup(dkf); ded->event_to_delete=e; ded->popover=GTK_POPOVER(pop); g_signal_connect(db,"clicked",G_CALLBACK(on_delete_event_clicked),ded); g_object_set_data_full(G_OBJECT(db),"delete-data",ded,free_delete_event_data); gtk_box_append(GTK_BOX(hbox),tl); gtk_box_append(GTK_BOX(hbox),title); gtk_box_append(GTK_BOX(hbox),db); gtk_box_append(GTK_BOX(vbox),hbox); } gtk_widget_set_parent(pop, GTK_WIDGET(button)); g_signal_connect(pop, "closed", G_CALLBACK(destroy_popover_on_close), NULL); gtk_popover_popup(GTK_POPOVER(pop)); }
static void on_day_right_clicked(GtkGestureClick *g, int n, double x, double y, gpointer user_data) { (void)n;(void)x;(void)y; CalendarWidget *w = (CalendarWidget *)user_data; GtkWidget *b = gtk_event_controller_get_widget(GTK_EVENT_CONTROLLER(g)); const gchar *dk = g_object_get_data(G_OBJECT(b),"date-key"); g_object_set_data(G_OBJECT(w->add_event_popover),"date-key",(gpointer)dk); gtk_editable_set_text(GTK_EDITABLE(w->add_event_title_entry),""); gtk_check_button_set_active(w->add_event_allday_check,FALSE); gtk_drop_down_set_selected(w->add_event_hour_dropdown,8); gtk_drop_down_set_selected(w->add_event_minute_dropdown,0); gtk_drop_down_set_selected(w->add_event_ampm_dropdown,0); gtk_widget_set_parent(GTK_WIDGET(w->add_event_popover), b); gtk_popover_popup(GTK_POPOVER(w->add_event_popover)); }
static void on_prev_month_clicked(GtkButton *b, gpointer user_data) { (void)b; CalendarWidget *w = (CalendarWidget *)user_data; w->current_date = g_date_time_add_months(w->current_date, -1); start_grid_population(w); }
static void on_next_month_clicked(GtkButton *b, gpointer user_data) { (void)b; CalendarWidget *w = (CalendarWidget *)user_data; w->current_date = g_date_time_add_months(w->current_date, 1); start_grid_population(w); }
static void on_add_event_popover_closed(GtkPopover *p, gpointer user_data) { (void)user_data; if (gtk_widget_get_parent(GTK_WIDGET(p))) gtk_widget_unparent(GTK_WIDGET(p)); }

// --- CORE UI LOGIC (Unchanged) ---
static gboolean populate_one_day(gpointer user_data) { CalendarWidget *w = (CalendarWidget*)user_data; GridPopulationState *s = g_object_get_data(G_OBJECT(w->calendar_grid),"population-state"); if (!s || s->day_to_add > s->days_in_month) { if(s) g_free(s); g_object_set_data(G_OBJECT(w->calendar_grid),"population-state",NULL); w->grid_population_timer_id = 0; return G_SOURCE_REMOVE; } gchar l[4]; snprintf(l,4,"%d",s->day_to_add); GtkWidget *b = gtk_button_new_with_label(l); gtk_widget_add_css_class(b,"day-button"); gchar *dk=g_strdup_printf("%d-%d-%d",s->current_y,s->current_m,s->day_to_add), *pk=g_strdup_printf("%d-%d",s->current_m,s->day_to_add); g_object_set_data_full(G_OBJECT(b),"date-key",dk,(GDestroyNotify)g_free); if (s->day_to_add==s->today_d && s->current_m==s->today_m && s->current_y==s->today_y) gtk_widget_add_css_class(b,"today"); if ((w->events && g_hash_table_contains(w->events,dk)) || (w->permanent_events && g_hash_table_contains(w->permanent_events,pk))) gtk_widget_add_css_class(b,"has-event"); g_free(pk); g_signal_connect(b,"clicked",G_CALLBACK(on_day_left_clicked),w); GtkGesture *rg=gtk_gesture_click_new(); gtk_gesture_single_set_button(GTK_GESTURE_SINGLE(rg),GDK_BUTTON_SECONDARY); g_signal_connect(rg,"pressed",G_CALLBACK(on_day_right_clicked),w); gtk_widget_add_controller(b,GTK_EVENT_CONTROLLER(rg)); gtk_grid_attach(GTK_GRID(w->calendar_grid),b,s->grid_x,s->grid_y,1,1); s->grid_x++; if(s->grid_x > 6) { s->grid_x=0; s->grid_y++; } s->day_to_add++; return G_SOURCE_CONTINUE; }
static void start_grid_population(CalendarWidget *widget) { if (gtk_widget_get_parent(GTK_WIDGET(widget->add_event_popover))) gtk_popover_popdown(widget->add_event_popover); if (widget->grid_population_timer_id>0) { g_source_remove(widget->grid_population_timer_id); GridPopulationState *os = g_object_get_data(G_OBJECT(widget->calendar_grid),"population-state"); if(os) g_free(os); g_object_set_data(G_OBJECT(widget->calendar_grid),"population-state",NULL); } gchar *ms = g_date_time_format(widget->current_date,"%B %Y"); gtk_label_set_text(widget->month_label,ms); g_free(ms); GtkWidget *child = gtk_widget_get_first_child(GTK_WIDGET(widget->calendar_grid)); while(child) { GtkWidget *next_child = gtk_widget_get_next_sibling(child); if (gtk_widget_has_css_class(child, "day-button")) gtk_grid_remove(GTK_GRID(widget->calendar_grid), child); child = next_child; } GridPopulationState *s=g_new0(GridPopulationState,1); s->day_to_add=1; s->current_y=g_date_time_get_year(widget->current_date); s->current_m=g_date_time_get_month(widget->current_date); s->days_in_month=g_date_get_days_in_month((GDateMonth)s->current_m,(GDateYear)s->current_y); GDateTime *fdom=g_date_time_new(g_date_time_get_timezone(widget->current_date),s->current_y,s->current_m,1,0,0,0); s->grid_x=g_date_time_get_day_of_week(fdom)%7; s->grid_y=1; g_date_time_unref(fdom); GDateTime *t=g_date_time_new_now_local(); s->today_y=g_date_time_get_year(t); s->today_m=g_date_time_get_month(t); s->today_d=g_date_time_get_day_of_month(t); g_date_time_unref(t); g_object_set_data(G_OBJECT(widget->calendar_grid),"population-state",s); widget->grid_population_timer_id=g_timeout_add(1,populate_one_day,widget); }
static GtkWidget* create_upcoming_event_row(UpcomingEvent *ue) { GtkWidget *r=gtk_list_box_row_new(); gtk_widget_add_css_class(r,"upcoming-row"); GtkWidget *h=gtk_box_new(GTK_ORIENTATION_HORIZONTAL,0); gtk_list_box_row_set_child(GTK_LIST_BOX_ROW(r),h); GtkWidget *db=gtk_box_new(GTK_ORIENTATION_VERTICAL,0); gtk_widget_set_valign(db,GTK_ALIGN_CENTER); gtk_widget_add_css_class(db,"upcoming-date-box"); gchar *ds=g_date_time_format(ue->datetime,"%d"), *ms=g_date_time_format(ue->datetime,"%b"); GtkWidget *dl=gtk_label_new(ds), *ml=gtk_label_new(ms); gtk_widget_add_css_class(dl,"upcoming-date-day"); gtk_widget_add_css_class(ml,"upcoming-date-month"); gtk_box_append(GTK_BOX(db),dl); gtk_box_append(GTK_BOX(db),ml); g_free(ds); g_free(ms); GtkWidget *detb=gtk_box_new(GTK_ORIENTATION_VERTICAL,0); GtkWidget *title=gtk_label_new(ue->event->title); gtk_label_set_xalign(GTK_LABEL(title),0.0); gtk_widget_add_css_class(title,"upcoming-event-title"); gchar *t12=format_time_to_12h(ue->event->time); GtkWidget *tl=gtk_label_new(t12); g_free(t12); gtk_label_set_xalign(GTK_LABEL(tl),0.0); gtk_widget_add_css_class(tl,"upcoming-event-time"); gtk_box_append(GTK_BOX(detb),title); gtk_box_append(GTK_BOX(detb),tl); gtk_box_append(GTK_BOX(h),db); gtk_box_append(GTK_BOX(h),detb); return r; }
static gint sort_upcoming_events(gconstpointer a, gconstpointer b) { return g_date_time_compare(((UpcomingEvent*)a)->datetime, ((UpcomingEvent*)b)->datetime); }
static void populate_upcoming_events_list(CalendarWidget *widget) { if(!widget->events&&!widget->permanent_events)return; GtkWidget *child=gtk_widget_get_first_child(GTK_WIDGET(widget->upcoming_list_box)); while(child){GtkWidget *next=gtk_widget_get_next_sibling(child);gtk_list_box_remove(GTK_LIST_BOX(widget->upcoming_list_box),child);child=next;} GList *ul=NULL; GDateTime *n=g_date_time_new_now_local(),*t=g_date_time_new(g_date_time_get_timezone(n),g_date_time_get_year(n),g_date_time_get_month(n),g_date_time_get_day_of_month(n),0,0,0); if (widget->events) {GHashTableIter i; gpointer k,v; g_hash_table_iter_init(&i,widget->events); while(g_hash_table_iter_next(&i,&k,&v)){ int y,m,d; sscanf((gchar*)k,"%d-%d-%d",&y,&m,&d); GDateTime *ed=g_date_time_new(g_date_time_get_timezone(t),y,m,d,0,0,0); if(g_date_time_compare(ed,t)>=0) for(GList *l=(GList*)v;l;l=l->next){ UpcomingEvent *ue=g_new(UpcomingEvent,1); ue->datetime=g_date_time_ref(ed); ue->event=(Event*)l->data; ul=g_list_prepend(ul,ue); } g_date_time_unref(ed);}} if(widget->permanent_events){GHashTableIter i; gpointer k,v; g_hash_table_iter_init(&i,widget->permanent_events); while(g_hash_table_iter_next(&i,&k,&v)){ int m,d; sscanf((gchar*)k,"%d-%d",&m,&d); GDateTime *edty=g_date_time_new(g_date_time_get_timezone(t),g_date_time_get_year(t),m,d,0,0,0), *no=NULL; if(g_date_time_compare(edty,t)>=0) no=g_date_time_ref(edty); else no=g_date_time_add_years(edty,1); g_date_time_unref(edty); for(GList *l=(GList*)v;l;l=l->next){ UpcomingEvent *ue=g_new(UpcomingEvent,1); ue->datetime=g_date_time_ref(no); ue->event=(Event*)l->data; ul=g_list_prepend(ul,ue); } g_date_time_unref(no);}} g_date_time_unref(n); g_date_time_unref(t); ul=g_list_sort(ul,(GCompareFunc)sort_upcoming_events); for(GList *l=ul;l;l=l->next) gtk_list_box_append(widget->upcoming_list_box,create_upcoming_event_row((UpcomingEvent*)l->data)); g_list_free_full(ul,free_upcoming_event); }

// --- Cleanup (Unchanged) ---
static void on_widget_destroy(GtkWidget *gtk_widget, gpointer user_data) { (void)gtk_widget; CalendarWidget *w = (CalendarWidget *)user_data; if (w->grid_population_timer_id > 0) g_source_remove(w->grid_population_timer_id); GridPopulationState *s = g_object_get_data(G_OBJECT(w->calendar_grid), "population-state"); if (s) g_free(s); if (w->events) g_hash_table_unref(w->events); if (w->permanent_events) g_hash_table_unref(w->permanent_events); if (w->current_date) g_date_time_unref(w->current_date); g_free(w); }


// ==============================================================================
//                 THE FINAL, FULLY RESTORED `create_widget`
// ==============================================================================
G_MODULE_EXPORT GtkWidget* create_widget(const char *config_string) {
    // We no longer use the config string inside the plugin for styling.
    (void)config_string;

    CalendarWidget *widget_data = g_new0(CalendarWidget, 1);

    // This is the plugin's ONLY responsibility for styling: set a unique name.
    // The orchestrator (main.c) will use this hook.
    widget_data->main_container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_set_name(widget_data->main_container, "calendar-widget");

    // --- ALL OF YOUR ORIGINAL UI-BUILDING LOGIC IS RESTORED BELOW ---

    gtk_widget_set_size_request(widget_data->main_container, WIDGET_WIDTH, -1);
    gtk_widget_set_halign(widget_data->main_container, GTK_ALIGN_CENTER);
    gtk_widget_set_valign(widget_data->main_container, GTK_ALIGN_CENTER);
    
    GtkWidget *header_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_add_css_class(header_box, "header-box");
    gtk_box_append(GTK_BOX(widget_data->main_container), header_box);

    GtkWidget *prev_button = gtk_button_new_with_label("");
    gtk_widget_add_css_class(prev_button, "nav-button");
    gtk_box_append(GTK_BOX(header_box), prev_button);

    GtkWidget *month_menu_button = gtk_menu_button_new();
    gtk_widget_add_css_class(month_menu_button, "month-button");
    gtk_widget_set_hexpand(month_menu_button, TRUE);
    gtk_box_append(GTK_BOX(header_box), month_menu_button);

    widget_data->month_label = GTK_LABEL(gtk_label_new("..."));
    gtk_widget_add_css_class(GTK_WIDGET(widget_data->month_label), "month-label");
    gtk_menu_button_set_child(GTK_MENU_BUTTON(month_menu_button), GTK_WIDGET(widget_data->month_label));

    GtkWidget *next_button = gtk_button_new_with_label("");
    gtk_widget_add_css_class(next_button, "nav-button");
    gtk_box_append(GTK_BOX(header_box), next_button);

    GtkWidget *upcoming_popover = gtk_popover_new();
    gtk_widget_add_css_class(upcoming_popover, "event-popover");
    gtk_menu_button_set_popover(GTK_MENU_BUTTON(month_menu_button), upcoming_popover);

    GtkWidget *panel_container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_add_css_class(panel_container, "upcoming-panel");
    gtk_popover_set_child(GTK_POPOVER(upcoming_popover), panel_container);

    GtkWidget *scrolled_window = gtk_scrolled_window_new();
    gtk_widget_set_size_request(scrolled_window, -1, 300);
    gtk_box_append(GTK_BOX(panel_container), scrolled_window);

    widget_data->upcoming_list_box = GTK_LIST_BOX(gtk_list_box_new());
    gtk_widget_add_css_class(GTK_WIDGET(widget_data->upcoming_list_box), "upcoming-list");
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_window), GTK_WIDGET(widget_data->upcoming_list_box));

    widget_data->calendar_grid = GTK_GRID(gtk_grid_new());
    gtk_widget_add_css_class(GTK_WIDGET(widget_data->calendar_grid), "calendar-grid");
    gtk_box_append(GTK_BOX(widget_data->main_container), GTK_WIDGET(widget_data->calendar_grid));

    const char *weekdays[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    for (int i=0; i < 7; i++) {
        GtkWidget *label = gtk_label_new(weekdays[i]);
        gtk_widget_add_css_class(label, "weekday-label");
        gtk_grid_attach(GTK_GRID(widget_data->calendar_grid), label, i, 0, 1, 1);
    }

    widget_data->add_event_popover = GTK_POPOVER(gtk_popover_new());
    gtk_widget_add_css_class(GTK_WIDGET(widget_data->add_event_popover), "event-popover");
    g_signal_connect(widget_data->add_event_popover, "closed", G_CALLBACK(on_add_event_popover_closed), NULL);

    GtkWidget *popover_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
    gtk_widget_set_margin_start(popover_vbox, 10); gtk_widget_set_margin_end(popover_vbox, 10); gtk_widget_set_margin_top(popover_vbox, 10); gtk_widget_set_margin_bottom(popover_vbox, 10);
    gtk_popover_set_child(widget_data->add_event_popover, popover_vbox);

    widget_data->add_event_title_entry = GTK_ENTRY(gtk_entry_new());
    gtk_entry_set_placeholder_text(widget_data->add_event_title_entry, "Event Title (Required)");
    gtk_box_append(GTK_BOX(popover_vbox), GTK_WIDGET(widget_data->add_event_title_entry));

    widget_data->add_event_allday_check = GTK_CHECK_BUTTON(gtk_check_button_new_with_label("All-day event"));
    gtk_box_append(GTK_BOX(popover_vbox), GTK_WIDGET(widget_data->add_event_allday_check));

    widget_data->add_event_time_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
    const char *hours[] = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", NULL};
    widget_data->add_event_hour_dropdown = GTK_DROP_DOWN(gtk_drop_down_new_from_strings(hours));
    const char *mins[] = {"00", "05", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55", NULL};
    widget_data->add_event_minute_dropdown = GTK_DROP_DOWN(gtk_drop_down_new_from_strings(mins));
    const char *am_pm[] = {"AM", "PM", NULL};
    widget_data->add_event_ampm_dropdown = GTK_DROP_DOWN(gtk_drop_down_new_from_strings(am_pm));
    gtk_box_append(GTK_BOX(widget_data->add_event_time_box), GTK_WIDGET(widget_data->add_event_hour_dropdown));
    gtk_box_append(GTK_BOX(widget_data->add_event_time_box), gtk_label_new(":"));
    gtk_box_append(GTK_BOX(widget_data->add_event_time_box), GTK_WIDGET(widget_data->add_event_minute_dropdown));
    gtk_box_append(GTK_BOX(widget_data->add_event_time_box), GTK_WIDGET(widget_data->add_event_ampm_dropdown));
    gtk_box_append(GTK_BOX(popover_vbox), widget_data->add_event_time_box);

    GtkWidget *save_button = gtk_button_new_with_label("Save Event");
    gtk_box_append(GTK_BOX(popover_vbox), save_button);
    
    // Connect only internal signals. main.c handles visibility.
    g_signal_connect(prev_button, "clicked", G_CALLBACK(on_prev_month_clicked), widget_data);
    g_signal_connect(next_button, "clicked", G_CALLBACK(on_next_month_clicked), widget_data);
    g_signal_connect(save_button, "clicked", G_CALLBACK(on_add_event_save), widget_data);
    g_signal_connect(widget_data->add_event_allday_check, "notify::active", G_CALLBACK(on_allday_toggled), widget_data);
    g_signal_connect(widget_data->main_container, "destroy", G_CALLBACK(on_widget_destroy), widget_data);
    
    // --- Load Data ---
    widget_data->current_date = g_date_time_new_now_local();
    GTask *task = g_task_new(NULL, NULL, on_data_loaded, widget_data);
    g_task_run_in_thread(task, load_data_in_thread);
    g_object_unref(task);

    return widget_data->main_container;
}
======================================================================
### FILE: ././widgets/calendar/meson.build
======================================================================
# widgets/calendar/meson.build

widget_install_dir = get_option('libdir') / 'aurora-shell' / 'widgets'
data_install_dir = get_option('datadir') / 'aurora-shell' / 'calendar'

dependencies = [
  dependency('gtk4'),
  dependency('json-glib-1.0'),
]

shared_library('calendar', 'calendar.c',
  dependencies: dependencies,
  install: true,
  install_dir: widget_install_dir,
  name_prefix: '',
)

install_data(
  ['data/events.json', 'data/permanent_events.json'],
  install_dir: data_install_dir,
  install_mode: 'rw-r--r--' 
)
======================================================================
### FILE: ././widgets/meson.build
======================================================================
# src/widgets/meson.build

subdir('uptime')
subdir('cheatsheet')
subdir('calendar')
subdir('control-center')
subdir('mpris_player')
subdir('topbar')
subdir('launcher') 
subdir('cachy-selector')
subdir('insight')
subdir('qscreen')
======================================================================
### FILE: ././widgets/cachy-selector/cachy-selector.c
======================================================================
#include <gtk/gtk.h>
#include <gtk4-layer-shell.h>
#include <gio/gio.h>
#include <glib.h>
#include <glib/gstdio.h>
#include <stdio.h>
#include <string.h>
#include <json-glib/json-glib.h>

typedef struct {
    GtkApplication *gtk_app;
    GtkWindow *window;
    GtkBox *hbox;
    GtkScrolledWindow *scrolled_window;
    GList *previews;
    int selected_index;
    GCancellable *cancellable;
} Application;

static void app_update_view(Application *app);
static void app_select_and_quit(GtkWidget *preview_widget, Application *app);
static void on_image_loaded_cb(GObject *source_object, GAsyncResult *res, gpointer user_data);
static void load_image_thread_func(GTask *task, gpointer source_object, gpointer task_data, GCancellable *cancellable);
static GtkWidget* ui_create_wallpaper_preview(Application *app, const char* path_str, int index);
static void app_populate_from_list(Application *app, GList *paths);
static void free_string_list(gpointer data);

// ===================================================================
//  Core Application Logic
// ===================================================================

static void free_string_list(gpointer data) {
    g_list_free_full((GList *)data, g_free);
}

static void app_select_and_quit(GtkWidget *preview_widget, Application *app) {
    const char* path = g_object_get_data(G_OBJECT(preview_widget), "wallpaper-path");
    if (path) { g_print("%s\n", path); fflush(stdout); }
    g_application_quit(G_APPLICATION(app->gtk_app));
}

static void ui_center_selected_item(Application *app) {
    if (g_list_length(app->previews) == 0) return;
    GtkWidget *selected_widget = g_list_nth_data(app->previews, app->selected_index);
    if (!selected_widget) return;
    
    GtkAdjustment *hadjustment = gtk_scrolled_window_get_hadjustment(app->scrolled_window);
    
    double item_x, item_y; 
    gtk_widget_translate_coordinates(selected_widget, GTK_WIDGET(app->hbox), 0, 0, &item_x, &item_y);

    double item_width = gtk_widget_get_width(selected_widget);
    double viewport_width = gtk_adjustment_get_page_size(hadjustment);
    double new_scroll_value = item_x + item_width / 2.0 - viewport_width / 2.0;

    double lower = gtk_adjustment_get_lower(hadjustment);
    double upper = gtk_adjustment_get_upper(hadjustment) - viewport_width;
    if (upper < lower) upper = lower;
    
    if (new_scroll_value < lower) new_scroll_value = lower;
    if (new_scroll_value > upper) new_scroll_value = upper;
    
    gtk_adjustment_set_value(hadjustment, new_scroll_value);
}

static void app_update_view(Application *app) {
    if (g_list_length(app->previews) == 0) return;
    for (GList *l = app->previews; l != NULL; l = g_list_next(l)) {
        GtkWidget *widget = l->data;
        int index = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(widget), "widget-index"));
        if (index == app->selected_index) gtk_widget_add_css_class(widget, "selected");
        else gtk_widget_remove_css_class(widget, "selected");
    }
    GtkWidget *selected_widget = g_list_nth_data(app->previews, app->selected_index);
    if (selected_widget) gtk_widget_grab_focus(selected_widget);
    ui_center_selected_item(app);
}

static gboolean on_key_pressed(GtkEventControllerKey *c, guint keyval, guint k, GdkModifierType s, gpointer user_data) {
    (void)c; (void)k; (void)s; Application *app = user_data; int count = g_list_length(app->previews);
    if (count == 0) return GDK_EVENT_PROPAGATE;
    switch (keyval) {
        case GDK_KEY_Left: case GDK_KEY_h: app->selected_index = (app->selected_index - 1 + count) % count; app_update_view(app); return GDK_EVENT_STOP;
        case GDK_KEY_Right: case GDK_KEY_l: app->selected_index = (app->selected_index + 1) % count; app_update_view(app); return GDK_EVENT_STOP;
        case GDK_KEY_Return: case GDK_KEY_KP_Enter: { GtkWidget *sel = g_list_nth_data(app->previews, app->selected_index); if (sel) app_select_and_quit(sel, app); return GDK_EVENT_STOP; }
        case GDK_KEY_Escape: case GDK_KEY_q: g_application_quit(G_APPLICATION(app->gtk_app)); return GDK_EVENT_STOP;
    }
    return GDK_EVENT_PROPAGATE;
}

static void on_item_clicked(GtkGestureClick *gesture, int n, double x, double y, gpointer user_data) {
    (void)n; (void)x; (void)y; Application *app = user_data;
    GtkWidget *w = gtk_event_controller_get_widget(GTK_EVENT_CONTROLLER(gesture));
    app_select_and_quit(w, app);
}

// ===================================================================
// THIS IS THE ORIGINAL, WORKING IMAGE LOADING LOGIC
// ===================================================================
static void on_image_loaded_cb(GObject *s, GAsyncResult *res, gpointer user_data) {
    (void)s; 
    GtkPicture *pic = GTK_PICTURE(user_data); 
    GError *err = NULL; 
    GdkPixbuf *pix = g_task_propagate_pointer(G_TASK(res), &err);
    if(err) { 
        if(!g_error_matches(err, G_IO_ERROR, G_IO_ERROR_CANCELLED)) g_warning("Async fail: %s", err->message);
        g_error_free(err); 
        return; 
    }
    if(pix) { 
        gtk_picture_set_pixbuf(pic, pix); 
        g_object_unref(pix); 
    }
}

static void load_image_thread_func(GTask *t, gpointer s, gpointer d, GCancellable *c) {
    (void)s; char *p=d; GError *err=NULL; if(g_cancellable_is_cancelled(c)) { g_task_return_error(t, g_error_new_literal(G_IO_ERROR, G_IO_ERROR_CANCELLED, "X")); return; }
    GdkPixbuf *final=NULL; gboolean is_u=FALSE; char *mime = g_content_type_guess(p, NULL, 0, &is_u);
    if(mime && g_content_type_equals(mime,"image/gif")){ GdkPixbufAnimation *a = gdk_pixbuf_animation_new_from_file(p, &err); if(a) { GdkPixbuf *f = gdk_pixbuf_animation_get_static_image(a); if(f) final = gdk_pixbuf_scale_simple(f, 220, 124, GDK_INTERP_BILINEAR); g_object_unref(a);}} g_free(mime);
    if(final==NULL){ g_clear_error(&err); final=gdk_pixbuf_new_from_file_at_scale(p,220,124,TRUE,&err);}
    if(err){ g_task_return_error(t,g_error_copy(err)); g_error_free(err); return; }
    g_task_return_pointer(t,final,g_object_unref);
}

// ===================================================================
//  UI Construction
// ===================================================================
static GtkWidget* ui_create_wallpaper_preview(Application *app, const char* path_str, int index) {
    GtkWidget *pic = gtk_picture_new();
    gtk_widget_add_css_class(pic, "preview-image");
    gtk_picture_set_can_shrink(GTK_PICTURE(pic), FALSE);
    gtk_picture_set_keep_aspect_ratio(GTK_PICTURE(pic), TRUE); // Reverted to old working function
    gtk_widget_set_vexpand(pic, TRUE);
    gtk_widget_set_valign(pic, GTK_ALIGN_FILL);

    GTask *t = g_task_new(NULL, app->cancellable, on_image_loaded_cb, pic);
    g_task_set_task_data(t, g_strdup(path_str), g_free);
    g_task_run_in_thread(t, (GTaskThreadFunc)load_image_thread_func);
    g_object_unref(t);

    GtkWidget *lbl = gtk_label_new(g_path_get_basename(path_str));
    gtk_label_set_ellipsize(GTK_LABEL(lbl), PANGO_ELLIPSIZE_END);
    gtk_widget_add_css_class(lbl, "filename-label");

    GtkWidget *vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_box_append(GTK_BOX(vbox), pic);
    gtk_box_append(GTK_BOX(vbox), lbl);
    
    GtkWidget *container = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_set_size_request(container, 220, -1);
    gtk_box_append(GTK_BOX(container), vbox);
    gtk_widget_set_can_focus(container, TRUE);
    gtk_widget_add_css_class(container, "preview-item");

    g_object_set_data_full(G_OBJECT(container), "wallpaper-path", g_strdup(path_str), g_free);
    g_object_set_data(G_OBJECT(container), "widget-index", GINT_TO_POINTER(index));

    GtkGesture *click = gtk_gesture_click_new();
    g_signal_connect(click, "pressed", G_CALLBACK(on_item_clicked), app);
    gtk_widget_add_controller(container, GTK_EVENT_CONTROLLER(click));

    return container;
}

static void app_populate_from_list(Application *app, GList *paths) {
    int index = 0;
    for (GList *l = paths; l != NULL; l = g_list_next(l)) {
        const char *path = l->data;
        GtkWidget *preview = ui_create_wallpaper_preview(app, path, index++);
        gtk_box_append(GTK_BOX(app->hbox), preview);
        app->previews = g_list_append(app->previews, preview);
    }
}

// ===================================================================
//  Application Activation and Main Loop
// ===================================================================
static void activate(GtkApplication *gtk_app, JsonObject *config_obj) {
    Application *app = g_object_get_data(G_OBJECT(gtk_app), "app-data");
    GList *paths = g_object_get_data(G_OBJECT(gtk_app), "paths-data");
    const char *config_name = g_object_get_data(G_OBJECT(gtk_app), "config-name");

    const char *css_filename = json_object_get_string_member_with_default(config_obj, "stylesheet", NULL);
    g_autofree gchar *css_path = NULL;
    if (css_filename) {
        css_path = g_build_filename(g_get_user_config_dir(), "aurora-shell", "templates", config_name, css_filename, NULL);
    }

    JsonObject *size_obj = json_object_has_member(config_obj, "size") ? json_object_get_object_member(config_obj, "size") : NULL;
    int width = size_obj ? json_object_get_int_member_with_default(size_obj, "width", 800) : 800;
    int height = size_obj ? json_object_get_int_member_with_default(size_obj, "height", 210) : 210;

    JsonObject *margins_obj = json_object_has_member(config_obj, "margins") ? json_object_get_object_member(config_obj, "margins") : NULL;
    int top_margin = margins_obj ? json_object_get_int_member_with_default(margins_obj, "top", 50) : 50;

    app->window = GTK_WINDOW(gtk_application_window_new(gtk_app));
    gtk_widget_set_name(GTK_WIDGET(app->window), "main-window");
    gtk_layer_init_for_window(app->window);
    gtk_layer_set_layer(app->window, GTK_LAYER_SHELL_LAYER_OVERLAY);
    gtk_layer_set_keyboard_mode(app->window, GTK_LAYER_SHELL_KEYBOARD_MODE_EXCLUSIVE);
    gtk_layer_set_anchor(app->window, GTK_LAYER_SHELL_EDGE_TOP, TRUE);
    gtk_layer_set_margin(app->window, GTK_LAYER_SHELL_EDGE_TOP, top_margin);

    app->scrolled_window = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new());
    gtk_scrolled_window_set_policy(app->scrolled_window, GTK_POLICY_AUTOMATIC, GTK_POLICY_NEVER);
    gtk_widget_set_size_request(GTK_WIDGET(app->scrolled_window), width, height);
    gtk_window_set_child(app->window, GTK_WIDGET(app->scrolled_window));

    app->hbox = GTK_BOX(gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 20));
    gtk_widget_set_name(GTK_WIDGET(app->hbox), "main-hbox");
    gtk_widget_set_halign(GTK_WIDGET(app->hbox), GTK_ALIGN_CENTER);
    gtk_widget_set_valign(GTK_WIDGET(app->hbox), GTK_ALIGN_CENTER);
    gtk_scrolled_window_set_child(app->scrolled_window, GTK_WIDGET(app->hbox));

    GtkCssProvider *provider = gtk_css_provider_new();
    if (css_path && g_file_test(css_path, G_FILE_TEST_IS_REGULAR)) {
        gtk_css_provider_load_from_path(provider, css_path);
    } else {
        if (css_path) g_warning("Failed to find CSS file at '%s'. Using fallback.", css_path);
        else g_warning("No CSS path specified. Using fallback.");
        gtk_css_provider_load_from_string(provider, "#main-window{background-color:rgba(30,30,46,0.85);}");
    }
    gtk_style_context_add_provider_for_display(gdk_display_get_default(), GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
    g_object_unref(provider);

    GtkEventController *key_controller = gtk_event_controller_key_new();
    g_signal_connect(key_controller, "key-pressed", G_CALLBACK(on_key_pressed), app);
    gtk_widget_add_controller(GTK_WIDGET(app->window), key_controller);
    
    app_populate_from_list(app, paths);

    if (g_list_length(app->previews) > 0) {
        gtk_window_present(app->window);
        app->selected_index = 0;
        app_update_view(app);
    } else {
        g_warning("No valid image paths provided via stdin. Exiting.");
        g_application_quit(G_APPLICATION(app->gtk_app));
    }
}

int main(int argc, char *argv[]) {
    if (argc < 2) { g_printerr("Usage: %s <config_name>\n", argv[0]); return 1; }
    const char *config_name = argv[1];
    
    GList *paths = NULL;
    char buffer[4096];
    while (fgets(buffer, sizeof(buffer), stdin)) {
        buffer[strcspn(buffer, "\n")] = 0;
        if (buffer[0] != '\0' && g_file_test(buffer, G_FILE_TEST_EXISTS)) {
            paths = g_list_append(paths, g_strdup(buffer));
        } else {
            if (buffer[0] != '\0') g_warning("Skipping invalid path: %s", buffer);
        }
    }

    Application *app = g_new0(Application, 1);
    app->selected_index = -1;
    app->cancellable = g_cancellable_new();
    app->gtk_app = gtk_application_new(NULL, G_APPLICATION_DEFAULT_FLAGS); 
    
    g_object_set_data(G_OBJECT(app->gtk_app), "app-data", app);
    g_object_set_data_full(G_OBJECT(app->gtk_app), "paths-data", paths, free_string_list);
    g_object_set_data(G_OBJECT(app->gtk_app), "config-name", (gpointer)config_name);

    g_autofree gchar *main_config_path = g_build_filename("/usr/local/share/aurora-shell", "config.json", NULL);
    g_autoptr(JsonParser) parser = json_parser_new();
    JsonObject *config_obj = NULL;
    
    if (json_parser_load_from_file(parser, main_config_path, NULL)) {
        JsonArray *root_array = json_node_get_array(json_parser_get_root(parser));
        for (guint i = 0; i < json_array_get_length(root_array); i++) {
            JsonObject *widget_obj = json_array_get_object_element(root_array, i);
            const char *name = json_object_get_string_member(widget_obj, "name");
            if (name && g_strcmp0(name, config_name) == 0) {
                if (json_object_has_member(widget_obj, "config")) {
                    config_obj = json_object_get_object_member(widget_obj, "config");
                }
                break;
            }
        }
    }

    if (!config_obj) { 
        g_printerr("Error: Could not find config block named '%s' or its 'config' object in %s.\n", config_name, main_config_path); 
        return 1; 
    }
    
    g_signal_connect(app->gtk_app, "activate", G_CALLBACK(activate), config_obj);
    int status = g_application_run(G_APPLICATION(app->gtk_app), 0, NULL);
    
    g_cancellable_cancel(app->cancellable); 
    g_list_free(app->previews); 
    g_object_unref(app->cancellable);
    g_object_unref(app->gtk_app); 
    g_free(app);
    return status;
}
======================================================================
### FILE: ././widgets/cachy-selector/meson.build
======================================================================
# Build instructions for the cachy-selector standalone utility

cachy_selector_sources = [
  'cachy-selector.c',
]

# List the libraries it needs. It's a full GTK app.
cachy_selector_deps = [
  dependency('gtk4'),
  dependency('gtk4-layer-shell-0'),
  dependency('json-glib-1.0')
]

# Tell Meson to build an EXECUTABLE, not a shared library
executable('cachy-selector',
  cachy_selector_sources,
  dependencies: cachy_selector_deps,
  install: true, # This installs it to /usr/local/bin by default
)
======================================================================
### FILE: ././widgets/mpris_player/src/lyrics.c
======================================================================
// src/lyrics.c

#include "lyrics.h"
#include "mpris.h" // Include mpris.h for the full MprisPopoutState definition
#include <glib/gregex.h>
#include <graphene.h>

// FIX: Define the CLAMP macro
#define CLAMP(x, low, high)  (((x) > (high)) ? (high) : (((x) < (low)) ? (low) : (x)))

static void free_lyric_line(gpointer data) {
    LyricLine *line = data;
    if (!line) return;
    g_free(line->line_text);
    g_free(line);
}

// NOTE: The LYRICS_SYNC_OFFSET_MS macro has been moved to mpris.c, where the sync logic now resides.
void lyrics_view_sync_to_position(MprisPopoutState* state, gint64 position_us) {
    if (!state || !state->lyrics_view_state) return;
    LyricsView *view = state->lyrics_view_state;

    if (!view->lyric_lines || g_list_length(view->lyric_lines) == 0) {
        return;
    }

    // The position adjustment now happens in mpris.c before this function is called.
    guint64 pos_ms = position_us / 1000;

    int new_line_index = -1;
    for (GList *l = g_list_last(view->lyric_lines); l != NULL; l = l->prev) {
        LyricLine *current_line = l->data;
        if (pos_ms >= current_line->timestamp_ms) {
            new_line_index = g_list_position(view->lyric_lines, l);
            break;
        }
    }

    if (new_line_index != view->current_line_index) {
        LyricLine *new_lyric = (new_line_index >= 0) ? g_list_nth_data(view->lyric_lines, new_line_index) : NULL;
        g_print("[SYNC] State Change! Pos: %.2fs. Old Index: %d, New Index: %d. New Lyric: \"%s\"\n",
                (double)pos_ms / 1000.0,
                view->current_line_index,
                new_line_index,
                (new_lyric && new_lyric->line_text) ? new_lyric->line_text : "---");

        if (view->current_line_index >= 0) {
            GList *old_link = g_list_nth(view->lyric_lines, view->current_line_index);
            if (old_link && old_link->data) {
                GtkWidget *label = ((LyricLine*)old_link->data)->label;
                if (GTK_IS_WIDGET(label)) gtk_widget_remove_css_class(label, "active-lyric");
            }
        }

        if (new_line_index >= 0) {
             GList *new_link = g_list_nth(view->lyric_lines, new_line_index);
             if (new_link && new_link->data) {
                GtkWidget *active_label = ((LyricLine*)new_link->data)->label;
                gtk_widget_add_css_class(active_label, "active-lyric");

                GtkAdjustment *v_adj = gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(view->scrolled_window));
                graphene_rect_t bounds;
                // Explicitly ignore the return value to silence the warning.
                (void)gtk_widget_compute_bounds(active_label, gtk_widget_get_parent(active_label), &bounds);
                double target_value = bounds.origin.y - (gtk_adjustment_get_page_size(v_adj) / 2.0) + (bounds.size.height / 2.0);
                target_value = CLAMP(target_value, gtk_adjustment_get_lower(v_adj), gtk_adjustment_get_upper(v_adj) - gtk_adjustment_get_page_size(v_adj));
                gtk_adjustment_set_value(v_adj, target_value);
             }
        }
        view->current_line_index = new_line_index;
    }
}

GtkWidget* create_lyrics_view(LyricsView **view_out) {
    LyricsView *view = g_new0(LyricsView, 1);
    view->current_line_index = -1;
    view->scrolled_window = gtk_scrolled_window_new();
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(view->scrolled_window), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
    gtk_widget_set_vexpand(view->scrolled_window, TRUE);
    view->lyrics_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
    gtk_widget_add_css_class(view->lyrics_box, "lyrics-box");
    gtk_widget_set_valign(view->lyrics_box, GTK_ALIGN_CENTER);
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(view->scrolled_window), view->lyrics_box);
    *view_out = view;
    return view->scrolled_window;
}

void destroy_lyrics_view(LyricsView *view) {
    if (!view) return;
    g_list_free_full(view->lyric_lines, free_lyric_line);
    g_free(view);
}

void clear_lyrics_display(LyricsView *view) {
    if (!view) return;
    GtkWidget *child;
    while ((child = gtk_widget_get_first_child(view->lyrics_box))) {
        gtk_box_remove(GTK_BOX(view->lyrics_box), child);
    }
}

void parse_and_populate_lyrics(LyricsView *view, const gchar *lrc_data) {
    if (!view) return;
    clear_lyrics_display(view);
    if (view->lyric_lines) {
        g_list_free_full(view->lyric_lines, free_lyric_line);
        view->lyric_lines = NULL;
    }
    view->current_line_index = -1;

    if (lrc_data == NULL) {
        GtkWidget *spinner = gtk_spinner_new();
        gtk_spinner_start(GTK_SPINNER(spinner));
        gtk_widget_set_halign(spinner, GTK_ALIGN_CENTER);
        gtk_widget_set_valign(spinner, GTK_ALIGN_CENTER);
        gtk_widget_set_vexpand(spinner, TRUE);
        gtk_box_append(GTK_BOX(view->lyrics_box), spinner);
        return;
    }

    g_autofree gchar **lines = g_strsplit(lrc_data, "\n", -1);
    g_autoptr(GRegex) regex = g_regex_new("\\[([0-9]{2}):([0-9]{2})[.:]([0-9]{2,3})\\](.*)", 0, 0, NULL);
    for (int i = 0; lines && lines[i] != NULL; i++) {
        g_autoptr(GMatchInfo) match_info = NULL;
        if (g_regex_match(regex, lines[i], 0, &match_info)) {
            g_autofree gchar *min_str = g_match_info_fetch(match_info, 1);
            g_autofree gchar *sec_str = g_match_info_fetch(match_info, 2);
            g_autofree gchar *cs_str = g_match_info_fetch(match_info, 3);
            g_autofree gchar *text = g_match_info_fetch(match_info, 4);
            if (min_str && sec_str && cs_str && text) {
                g_autofree gchar *trimmed_text = g_strstrip(g_strdup(text));
                if (strlen(trimmed_text) == 0) continue;
                LyricLine *line = g_new0(LyricLine, 1);
                guint64 ms_val = (guint64)atoi(cs_str);
                if (strlen(cs_str) == 2) ms_val *= 10;
                line->timestamp_ms = (guint64)atoi(min_str) * 60000 + (guint64)atoi(sec_str) * 1000 + ms_val;
                line->line_text = g_strdup(trimmed_text);
                line->label = gtk_label_new(line->line_text);
                gtk_widget_add_css_class(line->label, "lyrics-label");
                gtk_label_set_wrap(GTK_LABEL(line->label), TRUE);
                gtk_label_set_wrap_mode(GTK_LABEL(line->label), PANGO_WRAP_WORD_CHAR);
                // ALIGNMENT FIX: Ensure all lyrics are left-aligned.
                gtk_label_set_xalign(GTK_LABEL(line->label), 0.0);
                gtk_label_set_justify(GTK_LABEL(line->label), GTK_JUSTIFY_LEFT);
                gtk_box_append(GTK_BOX(view->lyrics_box), line->label);
                view->lyric_lines = g_list_append(view->lyric_lines, line);
            }
        }
    }

    if (g_list_length(view->lyric_lines) == 0) {
        GtkWidget *label = gtk_label_new("No synchronized lyrics found for this track.");
        gtk_label_set_wrap(GTK_LABEL(label), TRUE);
        gtk_label_set_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);
        // ALIGNMENT FIX: Ensure message is left-aligned and justified.
        gtk_label_set_xalign(GTK_LABEL(label), 0.0);
        gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
        gtk_widget_set_vexpand(label, TRUE);
        gtk_widget_set_valign(label, GTK_ALIGN_CENTER);
        gtk_box_append(GTK_BOX(view->lyrics_box), label);
    }
}
======================================================================
### FILE: ././widgets/mpris_player/src/utils.h
======================================================================
// src/utils.h

#ifndef UTILS_H
#define UTILS_H

#include <gio/gio.h>

void execute_command_async(const char* command, GAsyncReadyCallback callback, gpointer user_data);

// We only need stdout. The caller of this function receives ownership of the returned string.
gchar* get_command_stdout(GAsyncResult *res);

#endif
======================================================================
### FILE: ././widgets/mpris_player/src/mpris.h
======================================================================
// In mpris.h
#ifndef MPRIS_H
#define MPRIS_H

#include <gtk/gtk.h>
#include "lyrics.h"
#include "utils.h"

typedef struct _MprisPopoutState {
    GtkWindow *window;
    GDBusProxy *player_proxy;
    gchar *bus_name;
    GtkWidget *root_widget; 

    GtkImage *album_art_image;
    GtkLabel *title_label;
    GtkLabel *artist_label;
    GtkButton *play_pause_button;
    GtkButton *save_lyrics_button;
    
    GtkWidget *toast_label;

    LyricsView *lyrics_view_state;
    GCancellable *lyrics_cancellable;
    gint64 current_lyrics_id;
    gchar *current_track_signature;

    guint next_lyric_timer_id;
    guint resync_poll_timer_id;

    gulong properties_changed_id;
    gulong seeked_id;

    gint64 current_sync_offset_ms;
    GtkLabel *offset_label;
} MprisPopoutState;

// Correct function signature
GtkWidget* create_mpris_view(const gchar *bus_name, MprisPopoutState **state_out, gint width, gint height);

#endif // MPRIS_H
======================================================================
### FILE: ././widgets/mpris_player/src/mpris.c
======================================================================
// src/mpris.c

#include "mpris.h"
#include <libsoup/soup.h>
#include <json-glib/json-glib.h>
#include <glib/gstdio.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <math.h>

#define LYRICS_SAFETY_RESYNC_INTERVAL_S 10
#define LYRICS_SYNC_OFFSET_MS -550
#define LYRICS_OFFSET_ADJUSTMENT_STEP 50


static void fetch_lyrics(MprisPopoutState *state);
static void on_mpris_signal(GDBusProxy *proxy, const gchar *sender, const gchar *signal, GVariant *params, gpointer user_data);
static void launch_lyrics_search_request(MprisPopoutState *state);
static void update_display_metadata(MprisPopoutState *state, GVariantDict *dict);
static void update_playback_status_ui(MprisPopoutState *state, const gchar *status);
static void on_properties_changed(GDBusProxy *proxy, GVariant *changed_properties, const gchar *const *invalidated_properties, gpointer user_data);
static void on_prev_clicked(GtkButton *button, gpointer user_data);
static void on_play_pause_clicked(GtkButton *button, gpointer user_data);
static void on_next_clicked(GtkButton *button, gpointer user_data);
static void on_save_lyrics_clicked(GtkButton *button, gpointer user_data);
static void on_lyrics_api_response(GObject *source, GAsyncResult *res, gpointer user_data);
static gchar* create_track_signature(GVariantDict *dict);
static void save_lyrics_id_for_track(const gchar* signature, gint64 id);
static void update_mpris_state(MprisPopoutState *state);
static void stop_lyric_updates(MprisPopoutState *state);
static void start_lyric_updates(MprisPopoutState *state);
static void schedule_next_lyric_update(gpointer user_data);
static void on_player_position_for_resync(GObject *source, GAsyncResult *res, gpointer user_data);
static void on_offset_increase_clicked(GtkButton *button, gpointer user_data);
static void on_offset_decrease_clicked(GtkButton *button, gpointer user_data);
static void update_offset_label(MprisPopoutState *state);
static void show_toast(MprisPopoutState *state, const gchar *message);
static gboolean hide_toast_label(gpointer user_data);

static void free_popout_state(gpointer data) {
    MprisPopoutState *state = data;
    if (!state) return;
    g_print("[LIFECYCLE] Destroying MPRIS view state for %s\n", state->bus_name);
    stop_lyric_updates(state);
    if (state->lyrics_cancellable) g_cancellable_cancel(state->lyrics_cancellable);
    g_clear_object(&state->lyrics_cancellable);
    g_free(state->current_track_signature);
    destroy_lyrics_view(state->lyrics_view_state);
    if (state->player_proxy) {
        if (state->properties_changed_id > 0) g_signal_handler_disconnect(state->player_proxy, state->properties_changed_id);
        if (state->seeked_id > 0) g_signal_handler_disconnect(state->player_proxy, state->seeked_id);
        g_clear_object(&state->player_proxy);
    }
    g_free(state->bus_name);
    g_free(state);
}

static gboolean hide_toast_label(gpointer user_data) {
    GtkWidget *label = GTK_WIDGET(user_data);
    if (GTK_IS_WIDGET(label)) { gtk_widget_set_visible(label, FALSE); }
    return G_SOURCE_REMOVE;
}

static void show_toast(MprisPopoutState *state, const gchar *message) {
    if (!state || !state->toast_label) return;
    gtk_label_set_text(GTK_LABEL(state->toast_label), message);
    gtk_widget_set_visible(state->toast_label, TRUE);
    g_timeout_add_seconds(2, hide_toast_label, state->toast_label);
}

static void on_player_position_for_resync(GObject *source, GAsyncResult *res, gpointer user_data) {
    (void)source;
    MprisPopoutState *state = user_data;
    g_autofree gchar *stdout_str = get_command_stdout(res);
    if (!stdout_str || !state->lyrics_view_state || !state->lyrics_view_state->lyric_lines) { return; }
    gint64 pos_us = (gint64)(atof(stdout_str) * 1000000.0);
    gint64 adjusted_pos_us = pos_us - (state->current_sync_offset_ms * 1000);
    if (adjusted_pos_us < 0) adjusted_pos_us = 0;
    lyrics_view_sync_to_position(state, adjusted_pos_us);
    g_autoptr(GVariant) status_var = g_dbus_proxy_get_cached_property(state->player_proxy, "PlaybackStatus");
    const char *status = status_var ? g_variant_get_string(status_var, NULL) : "Paused";
    if (g_strcmp0(status, "Playing") != 0) { return; }
    LyricsView *view = state->lyrics_view_state;
    guint next_lyric_index = (view->current_line_index < 0) ? 0 : (guint)view->current_line_index + 1;
    if (next_lyric_index >= g_list_length(view->lyric_lines)) { return; }
    GList *next_link = g_list_nth(view->lyric_lines, next_lyric_index);
    LyricLine *next_line = next_link->data;
    guint64 next_timestamp_ms = next_line->timestamp_ms;
    guint64 adjusted_pos_ms = adjusted_pos_us / 1000;
    gint64 delay_ms = next_timestamp_ms - adjusted_pos_ms;
    if (delay_ms < 0) delay_ms = 20;
    state->next_lyric_timer_id = g_timeout_add_once((guint)delay_ms, (GSourceOnceFunc)schedule_next_lyric_update, state);
}

static void schedule_next_lyric_update(gpointer user_data) {
    MprisPopoutState *state = user_data;
    if (!state) return;
    state->next_lyric_timer_id = 0;
    execute_command_async("playerctl position", on_player_position_for_resync, state);
}

static gboolean safety_resync_callback(gpointer user_data) {
    MprisPopoutState *state = user_data;
    if (state->next_lyric_timer_id > 0) {
        g_source_remove(state->next_lyric_timer_id);
        state->next_lyric_timer_id = 0;
    }
    schedule_next_lyric_update(state);
    return G_SOURCE_CONTINUE;
}

static void stop_lyric_updates(MprisPopoutState *state) {
    if (state->next_lyric_timer_id > 0) { g_source_remove(state->next_lyric_timer_id); state->next_lyric_timer_id = 0; }
    if (state->resync_poll_timer_id > 0) { g_source_remove(state->resync_poll_timer_id); state->resync_poll_timer_id = 0; }
}

static void start_lyric_updates(MprisPopoutState *state) {
    stop_lyric_updates(state);
    g_autoptr(GVariant) status_var = g_dbus_proxy_get_cached_property(state->player_proxy, "PlaybackStatus");
    const char *status = status_var ? g_variant_get_string(status_var, NULL) : "Paused";
    if (g_strcmp0(status, "Playing") == 0) {
        schedule_next_lyric_update(state);
        state->resync_poll_timer_id = g_timeout_add_seconds(LYRICS_SAFETY_RESYNC_INTERVAL_S, safety_resync_callback, state);
    } else {
        execute_command_async("playerctl position", on_player_position_for_resync, state);
    }
}

static gchar* get_saved_lyrics_path(void) {
    return g_build_filename(g_get_user_cache_dir(), "mpris-lyrics-viewer", "saved_lyrics.json", NULL);
}

static void save_lyrics_id_for_track(const gchar* signature, gint64 id) {
    if (!signature) return;
    g_autoptr(GError) error = NULL;
    g_autofree gchar *path = get_saved_lyrics_path();
    g_autoptr(JsonParser) parser = json_parser_new();
    JsonObject *root_obj = NULL;
    if (g_file_test(path, G_FILE_TEST_EXISTS)) {
        if (json_parser_load_from_file(parser, path, &error)) {
            root_obj = json_node_get_object(json_parser_get_root(parser));
            if(root_obj) json_object_ref(root_obj);
        } else { g_clear_error(&error); }
    }
    if (!root_obj) root_obj = json_object_new();
    if (id > 0) {
        json_object_set_int_member(root_obj, signature, id);
    } else {
        if (json_object_has_member(root_obj, signature)) json_object_remove_member(root_obj, signature);
    }
    g_autoptr(JsonGenerator) generator = json_generator_new();
    JsonNode *root_node = json_node_new(JSON_NODE_OBJECT);
    json_node_take_object(root_node, root_obj);
    json_generator_set_root(generator, root_node);
    json_generator_set_pretty(generator, TRUE);
    g_autofree gchar *dir = g_path_get_dirname(path);
    g_mkdir_with_parents(dir, 0755);
    json_generator_to_file(generator, path, NULL);
}

static gint64 load_lyrics_id_for_track(const gchar* signature) {
    if (!signature) return 0;
    g_autofree gchar *path = get_saved_lyrics_path();
    if (!g_file_test(path, G_FILE_TEST_EXISTS)) return 0;
    g_autoptr(GError) error = NULL;
    g_autoptr(JsonParser) parser = json_parser_new();
    if (!json_parser_load_from_file(parser, path, &error)) return 0;
    JsonObject *root_obj = json_node_get_object(json_parser_get_root(parser));
    if (json_object_has_member(root_obj, signature)) {
        return json_object_get_int_member(root_obj, signature);
    }
    return 0;
}

static gchar* create_track_signature(GVariantDict *dict) {
    const char *title = NULL, *artist = NULL;
    gchar **artists = NULL;
    if (!dict) return NULL;
    g_variant_dict_lookup(dict, "xesam:title", "&s", &title);
    g_variant_dict_lookup(dict, "xesam:artist", "^as", &artists);
    if (artists && artists[0]) artist = artists[0];
    gchar *signature = (title && artist) ? g_strdup_printf("%s - %s", artist, title) : NULL;
    g_strfreev(artists);
    return signature;
}

static void process_lyrics_response_node(JsonNode *root_node, MprisPopoutState *state) {
    const char *best_match_lyrics = NULL;
    gint64 best_match_id = 0;

    if (JSON_NODE_HOLDS_OBJECT(root_node)) {
        JsonObject *root_obj = json_node_get_object(root_node);
        if (json_object_has_member(root_obj, "code") && json_object_get_int_member(root_obj, "code") == 404) {
            if (state->current_track_signature) save_lyrics_id_for_track(state->current_track_signature, 0);
            launch_lyrics_search_request(state);
            return;
        }
        best_match_lyrics = json_object_get_string_member_with_default(root_obj, "syncedLyrics", NULL);
        best_match_id = json_object_get_int_member_with_default(root_obj, "id", 0);
    } else if (JSON_NODE_HOLDS_ARRAY(root_node)) {
        JsonArray *results_array = json_node_get_array(root_node);
        double min_duration_diff = 1000.0;
        // The window is now stored in the state struct, retrieve it from there.
        gint64 original_duration_us = GPOINTER_TO_INT(g_object_get_data(G_OBJECT(state->root_widget), "current-track-duration"));
        guint original_duration_s = (guint)(original_duration_us / 1000000);
        for (guint i = 0; i < json_array_get_length(results_array); i++) {
            JsonObject *track_obj = json_array_get_object_element(results_array, i);
            const char *synced_lyrics = json_object_get_string_member_with_default(track_obj, "syncedLyrics", NULL);
            if (synced_lyrics && *synced_lyrics) {
                if (original_duration_us <= 0) {
                    best_match_lyrics = synced_lyrics;
                    best_match_id = json_object_get_int_member_with_default(track_obj, "id", 0);
                    break;
                }
                gint result_duration = json_object_get_int_member_with_default(track_obj, "duration", -1);
                double diff = fabs((double)result_duration - (double)original_duration_s);
                if (diff < min_duration_diff) {
                    min_duration_diff = diff;
                    best_match_lyrics = synced_lyrics;
                    best_match_id = json_object_get_int_member_with_default(track_obj, "id", 0);
                }
            }
        }
        if (best_match_lyrics && !(min_duration_diff <= 2.0 || original_duration_us <= 0)) {
            best_match_lyrics = NULL;
            best_match_id = 0;
        }
    }

    if (best_match_lyrics && *best_match_lyrics) {
        state->current_lyrics_id = best_match_id;
        gtk_widget_set_sensitive(GTK_WIDGET(state->save_lyrics_button), TRUE);
        parse_and_populate_lyrics(state->lyrics_view_state, best_match_lyrics);
        start_lyric_updates(state);
    } else {
        if (g_object_get_data(G_OBJECT(state->root_widget), "is-fallback-search")) {
            parse_and_populate_lyrics(state->lyrics_view_state, "");
        } else {
            launch_lyrics_search_request(state);
        }
    }
}

static void on_lyrics_api_response(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    MprisPopoutState *state = user_data;
    g_autoptr(GError) error = NULL;
    if (g_cancellable_is_cancelled(state->lyrics_cancellable)) return;
    g_autoptr(GInputStream) stream = soup_session_send_finish(SOUP_SESSION(source_object), res, &error);
    if (error) {
        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) launch_lyrics_search_request(state);
        return;
    }
    g_autoptr(JsonParser) parser = json_parser_new();
    if (!json_parser_load_from_stream(parser, stream, state->lyrics_cancellable, &error)) {
        if (!g_error_matches(error, G_IO_ERROR, G_IO_ERROR_CANCELLED)) launch_lyrics_search_request(state);
        return;
    }
    process_lyrics_response_node(json_parser_get_root(parser), state);
}

static void launch_lyrics_search_request(MprisPopoutState *state) {
    g_object_set_data(G_OBJECT(state->root_widget), "is-fallback-search", GINT_TO_POINTER(1));
    g_autoptr(GVariant) metadata_var = g_dbus_proxy_get_cached_property(state->player_proxy, "Metadata");
    if (!metadata_var) { parse_and_populate_lyrics(state->lyrics_view_state, ""); return; }
    g_autoptr(GVariantDict) dict = g_variant_dict_new(metadata_var);
    const char *title = NULL; gchar **artists = NULL;
    g_variant_dict_lookup(dict, "xesam:title", "&s", &title);
    g_variant_dict_lookup(dict, "xesam:artist", "^as", &artists);
    if (title && artists && artists[0]) {
        g_autofree gchar *artist_encoded = g_uri_escape_string(artists[0], NULL, FALSE);
        g_autofree gchar *title_encoded = g_uri_escape_string(title, NULL, FALSE);
        g_autofree gchar *search_url = g_strdup_printf("https://lrclib.net/api/search?track_name=%s&artist_name=%s", title_encoded, artist_encoded);
        g_autoptr(SoupSession) session = soup_session_new();
        g_autoptr(SoupMessage) msg = soup_message_new("GET", search_url);
        soup_message_headers_append(soup_message_get_request_headers(msg), "User-Agent", "MPRISLyricsViewer(v1.0)");
        soup_session_send_async(session, msg, G_PRIORITY_DEFAULT, state->lyrics_cancellable, (GAsyncReadyCallback)on_lyrics_api_response, state);
    } else {
        parse_and_populate_lyrics(state->lyrics_view_state, "");
    }
    g_strfreev(artists);
}

static void update_playback_status_ui(MprisPopoutState *state, const gchar *status) {
    if (!state || !status) return;
    gtk_button_set_icon_name(state->play_pause_button, g_strcmp0(status, "Playing") == 0 ? "media-playback-pause-symbolic" : "media-playback-start-symbolic");
}

static void fetch_lyrics(MprisPopoutState *state) {
    if (state->lyrics_cancellable) { g_cancellable_cancel(state->lyrics_cancellable); g_clear_object(&state->lyrics_cancellable); }
    state->lyrics_cancellable = g_cancellable_new();
    state->current_lyrics_id = 0;
    gtk_widget_set_sensitive(GTK_WIDGET(state->save_lyrics_button), FALSE);
    g_object_set_data(G_OBJECT(state->root_widget), "is-fallback-search", NULL);
    parse_and_populate_lyrics(state->lyrics_view_state, NULL);
    gint64 saved_id = load_lyrics_id_for_track(state->current_track_signature);
    g_autoptr(SoupSession) session = soup_session_new();
    if (saved_id > 0) {
        g_autofree gchar *url = g_strdup_printf("https://lrclib.net/api/get/%"G_GINT64_FORMAT, saved_id);
        g_autoptr(SoupMessage) msg = soup_message_new("GET", url);
        soup_message_headers_append(soup_message_get_request_headers(msg), "User-Agent", "MPRISLyricsViewer(v1.0)");
        soup_session_send_async(session, msg, G_PRIORITY_DEFAULT, state->lyrics_cancellable, (GAsyncReadyCallback)on_lyrics_api_response, state);
        return;
    }
    g_autoptr(GVariant) metadata_var = g_dbus_proxy_get_cached_property(state->player_proxy, "Metadata");
    if (!metadata_var) { launch_lyrics_search_request(state); return; }
    g_autoptr(GVariantDict) dict = g_variant_dict_new(metadata_var);
    const char *title = NULL, *album = NULL; gchar **artists = NULL; gint64 length_us = 0;
    g_variant_dict_lookup(dict, "xesam:title", "&s", &title);
    g_variant_dict_lookup(dict, "xesam:artist", "^as", &artists);
    g_variant_dict_lookup(dict, "mpris:length", "t", &length_us);
    g_variant_dict_lookup(dict, "xesam:album", "&s", &album);
    g_object_set_data(G_OBJECT(state->root_widget), "current-track-duration", GINT_TO_POINTER(length_us));
    if (title && artists && artists[0] && album && length_us > 0) {
        g_autofree gchar *artist_enc = g_uri_escape_string(artists[0], NULL, FALSE);
        g_autofree gchar *title_enc = g_uri_escape_string(title, NULL, FALSE);
        g_autofree gchar *album_enc = g_uri_escape_string(album, NULL, FALSE);
        guint duration_s = (guint)(length_us / 1000000);
        g_autofree gchar *url = g_strdup_printf("https://lrclib.net/api/get?track_name=%s&artist_name=%s&album_name=%s&duration=%u", title_enc, artist_enc, album_enc, duration_s);
        g_autoptr(SoupMessage) msg = soup_message_new("GET", url);
        soup_message_headers_append(soup_message_get_request_headers(msg), "User-Agent", "MPRISLyricsViewer(v1.0)");
        soup_session_send_async(session, msg, G_PRIORITY_DEFAULT, state->lyrics_cancellable, (GAsyncReadyCallback)on_lyrics_api_response, state);
    } else {
        launch_lyrics_search_request(state);
    }
    g_strfreev(artists);
}

static void update_display_metadata(MprisPopoutState *state, GVariantDict *dict) {
    if (!state || !dict) return;
    const char *title = NULL, *art_url = NULL; gchar **artists = NULL;
    g_variant_dict_lookup(dict, "xesam:title", "&s", &title);
    g_variant_dict_lookup(dict, "xesam:artist", "^as", &artists);
    g_variant_dict_lookup(dict, "mpris:artUrl", "&s", &art_url);
    gtk_label_set_text(state->title_label, title ? title : "Unknown Title");
    gtk_label_set_text(state->artist_label, (artists && artists[0]) ? artists[0] : "Unknown Artist");
    if (art_url && g_str_has_prefix(art_url, "file://")) {
        g_autofree gchar *path = g_filename_from_uri(art_url, NULL, NULL);
        gtk_image_set_from_file(state->album_art_image, path);
    } else {
        gtk_image_set_from_icon_name(state->album_art_image, "audio-x-generic");
    }
    g_strfreev(artists);
}

static void on_mpris_signal(GDBusProxy *proxy, const gchar *sender, const gchar *name, GVariant *params, gpointer user_data) {
    (void)proxy; (void)sender; (void)params;
    MprisPopoutState *state = user_data;
    if (g_strcmp0(name, "Seeked") == 0) { schedule_next_lyric_update(state); }
}

static void on_properties_changed(GDBusProxy *proxy, GVariant *changed_properties, const gchar *const *invalidated_properties, gpointer user_data) {
    (void)proxy; (void)changed_properties; (void)invalidated_properties;
    update_mpris_state(user_data);
}

static void update_mpris_state(MprisPopoutState *state) {
    if (!state || !state->player_proxy) return;
    g_autoptr(GVariant) metadata_var = g_dbus_proxy_get_cached_property(state->player_proxy, "Metadata");
    g_autoptr(GVariantDict) dict = metadata_var ? g_variant_dict_new(metadata_var) : NULL;
    g_autoptr(GVariant) status_var = g_dbus_proxy_get_cached_property(state->player_proxy, "PlaybackStatus");
    const char *status = status_var ? g_variant_get_string(status_var, NULL) : "Paused";
    update_display_metadata(state, dict);
    update_playback_status_ui(state, status);
    g_autofree gchar *new_signature = create_track_signature(dict);
    if (g_strcmp0(new_signature, state->current_track_signature) != 0) {
        g_print("[STATE] New Track Detected: %s\n", new_signature);
        g_free(state->current_track_signature);
        state->current_track_signature = g_strdup(new_signature);
        stop_lyric_updates(state);
        fetch_lyrics(state);
    } else {
        start_lyric_updates(state);
    }
}

static void on_prev_clicked(GtkButton*b,gpointer d){(void)b;g_dbus_proxy_call(((MprisPopoutState*)d)->player_proxy,"Previous",NULL,G_DBUS_CALL_FLAGS_NONE,-1,NULL,NULL,NULL);}
static void on_play_pause_clicked(GtkButton*b,gpointer d){(void)b;g_dbus_proxy_call(((MprisPopoutState*)d)->player_proxy,"PlayPause",NULL,G_DBUS_CALL_FLAGS_NONE,-1,NULL,NULL,NULL);}
static void on_next_clicked(GtkButton*b,gpointer d){(void)b;g_dbus_proxy_call(((MprisPopoutState*)d)->player_proxy,"Next",NULL,G_DBUS_CALL_FLAGS_NONE,-1,NULL,NULL,NULL);}
static void on_save_lyrics_clicked(GtkButton *b,gpointer d){
    (void)b; MprisPopoutState*s=d;
    if(!s||!s->current_track_signature||s->current_lyrics_id<=0)return;
    save_lyrics_id_for_track(s->current_track_signature,s->current_lyrics_id);
    show_toast(s, "Lyrics preference saved");
}
static void update_offset_label(MprisPopoutState *state) {
    g_autofree gchar *label_text = g_strdup_printf("Sync Offset: %+ld ms", state->current_sync_offset_ms);
    gtk_label_set_text(state->offset_label, label_text);
}
static void on_offset_decrease_clicked(GtkButton *b, gpointer d) { (void)b; ((MprisPopoutState*)d)->current_sync_offset_ms -= LYRICS_OFFSET_ADJUSTMENT_STEP; update_offset_label(d); schedule_next_lyric_update(d); }
static void on_offset_increase_clicked(GtkButton *b, gpointer d) { (void)b; ((MprisPopoutState*)d)->current_sync_offset_ms += LYRICS_OFFSET_ADJUSTMENT_STEP; update_offset_label(d); schedule_next_lyric_update(d); }


// --- Main Public Function ---
GtkWidget* create_mpris_view(const gchar *bus_name, MprisPopoutState **state_out, gint width, gint height) {
    g_return_val_if_fail(bus_name != NULL, NULL);
    
    MprisPopoutState *state = g_new0(MprisPopoutState, 1);
    state->bus_name = g_strdup(bus_name);
    state->current_sync_offset_ms = LYRICS_SYNC_OFFSET_MS;
    
    GtkWidget *root_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 12);

    // =======================================================================
    // THE FORCED METHOD IS BACK: This line forces the widget's size.
    gtk_widget_set_size_request(root_box, width, height); 
    // =======================================================================
    
    state->root_widget = root_box;
    g_object_set_data_full(G_OBJECT(root_box), "mpris-state", state, free_popout_state);

    // ... the rest of the function is exactly the same as you provided ...
    gtk_widget_set_margin_start(root_box, 15);
    gtk_widget_set_margin_end(root_box, 15);
    gtk_widget_set_margin_top(root_box, 15);
    gtk_widget_set_margin_bottom(root_box, 15);
    
    GtkWidget *info_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 15);
    state->album_art_image = GTK_IMAGE(gtk_image_new());
    gtk_image_set_pixel_size(state->album_art_image, 84);
    gtk_widget_add_css_class(GTK_WIDGET(state->album_art_image), "album-art");
    
    GtkWidget *text_box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 3);
    gtk_widget_set_hexpand(text_box, TRUE); 
    gtk_widget_set_valign(text_box, GTK_ALIGN_CENTER);
    state->title_label = GTK_LABEL(gtk_label_new(""));
    gtk_widget_add_css_class(GTK_WIDGET(state->title_label), "title-label");
    gtk_label_set_xalign(state->title_label, 0.0);
    gtk_label_set_wrap(state->title_label, TRUE);
    state->artist_label = GTK_LABEL(gtk_label_new(""));
    gtk_widget_add_css_class(GTK_WIDGET(state->artist_label), "artist-label");
    gtk_label_set_xalign(state->artist_label, 0.0);
    gtk_label_set_wrap(state->artist_label, TRUE);
    gtk_label_set_wrap_mode(state->artist_label, PANGO_WRAP_WORD_CHAR);
    gtk_box_append(GTK_BOX(text_box), GTK_WIDGET(state->title_label));
    gtk_box_append(GTK_BOX(text_box), GTK_WIDGET(state->artist_label));
    gtk_box_append(GTK_BOX(info_box), GTK_WIDGET(state->album_art_image));
    gtk_box_append(GTK_BOX(info_box), text_box);
    gtk_box_append(GTK_BOX(root_box), info_box); 
    
    GtkWidget *ctrl_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_box_set_homogeneous(GTK_BOX(ctrl_box), TRUE); 
    gtk_widget_set_halign(ctrl_box, GTK_ALIGN_CENTER); 
    gtk_widget_add_css_class(ctrl_box, "linked");
    
    GtkWidget *prev = gtk_button_new_from_icon_name("media-skip-backward-symbolic");
    state->play_pause_button = GTK_BUTTON(gtk_button_new_from_icon_name("media-playback-start-symbolic"));
    GtkWidget *next = gtk_button_new_from_icon_name("media-skip-forward-symbolic");
    state->save_lyrics_button = GTK_BUTTON(gtk_button_new_from_icon_name("document-save-symbolic"));
    GtkWidget *offset_decrease_btn = gtk_button_new_from_icon_name("go-previous-symbolic");
    GtkWidget *offset_increase_btn = gtk_button_new_from_icon_name("go-next-symbolic");
    
    gtk_widget_set_tooltip_text(prev, "Previous Track");
    gtk_widget_set_tooltip_text(GTK_WIDGET(state->play_pause_button), "Play/Pause");
    gtk_widget_set_tooltip_text(next, "Next Track");
    gtk_widget_set_tooltip_text(GTK_WIDGET(state->save_lyrics_button), "Save this lyric version for future plays");
    gtk_widget_set_tooltip_text(offset_decrease_btn, "Sync Lyrics Earlier (-50ms)");
    gtk_widget_set_tooltip_text(offset_increase_btn, "Sync Lyrics Later (+50ms)");
    gtk_widget_set_sensitive(GTK_WIDGET(state->save_lyrics_button), FALSE);
    
    g_signal_connect(prev, "clicked", G_CALLBACK(on_prev_clicked), state);
    g_signal_connect(state->play_pause_button, "clicked", G_CALLBACK(on_play_pause_clicked), state);
    g_signal_connect(next, "clicked", G_CALLBACK(on_next_clicked), state);
    g_signal_connect(state->save_lyrics_button, "clicked", G_CALLBACK(on_save_lyrics_clicked), state);
    g_signal_connect(offset_decrease_btn, "clicked", G_CALLBACK(on_offset_decrease_clicked), state);
    g_signal_connect(offset_increase_btn, "clicked", G_CALLBACK(on_offset_increase_clicked), state);
    
    gtk_box_append(GTK_BOX(ctrl_box), prev);
    gtk_box_append(GTK_BOX(ctrl_box), GTK_WIDGET(state->play_pause_button));
    gtk_box_append(GTK_BOX(ctrl_box), next);
    gtk_box_append(GTK_BOX(ctrl_box), offset_decrease_btn);
    gtk_box_append(GTK_BOX(ctrl_box), offset_increase_btn);
    gtk_box_append(GTK_BOX(ctrl_box), GTK_WIDGET(state->save_lyrics_button));
    gtk_box_append(GTK_BOX(root_box), ctrl_box);

    GtkWidget *offset_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
    gtk_widget_set_halign(offset_box, GTK_ALIGN_CENTER);
    state->offset_label = GTK_LABEL(gtk_label_new(""));
    gtk_widget_add_css_class(GTK_WIDGET(state->offset_label), "offset-label");
    update_offset_label(state); 
    gtk_box_append(GTK_BOX(offset_box), GTK_WIDGET(state->offset_label));
    gtk_box_append(GTK_BOX(root_box), offset_box);

    GtkWidget *lyrics_widget = create_lyrics_view(&state->lyrics_view_state);
    gtk_widget_set_vexpand(lyrics_widget, TRUE);
    gtk_box_append(GTK_BOX(root_box), lyrics_widget);
    
    GtkWidget *overlay_container = gtk_overlay_new();
    gtk_overlay_set_child(GTK_OVERLAY(overlay_container), root_box);

    state->toast_label = gtk_label_new("");
    gtk_widget_add_css_class(state->toast_label, "toast-label");
    gtk_widget_set_visible(state->toast_label, FALSE);
    gtk_widget_set_halign(state->toast_label, GTK_ALIGN_CENTER);
    gtk_widget_set_valign(state->toast_label, GTK_ALIGN_END);
    gtk_widget_set_margin_bottom(state->toast_label, 20);
    gtk_overlay_add_overlay(GTK_OVERLAY(overlay_container), state->toast_label);

    g_autoptr(GError) error = NULL;
    state->player_proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SESSION, G_DBUS_PROXY_FLAGS_NONE, NULL, bus_name, "/org/mpris/MediaPlayer2", "org.mpris.MediaPlayer2.Player", NULL, &error);
    if (error) {
        g_warning("Could not connect to player: %s", error->message);
    } else {
        state->properties_changed_id = g_signal_connect(state->player_proxy, "g-properties-changed", G_CALLBACK(on_properties_changed), state);
        state->seeked_id = g_signal_connect(state->player_proxy, "g-signal", G_CALLBACK(on_mpris_signal), state);
        update_mpris_state(state);
    }
    
    *state_out = state;
    return overlay_container;
}

======================================================================
### FILE: ././widgets/mpris_player/src/main.c
======================================================================
// In aurora-shell/widgets/mpris_player/main.c

#include <gtk/gtk.h>
#include <json-glib/json-glib.h>
#include "mpris.h"

// State struct remains the same, as we need width/height for our trick.
typedef struct {
    GtkWidget *view_stack;
    MprisPopoutState *mpris_state;
    GList *mpris_players;
    GDBusConnection *dbus_connection;
    guint name_watcher_id;
    gint width;
    gint height;
} MprisPluginState;

// All helper functions (update_view, etc.) are correct and remain unchanged.
static void update_view(MprisPluginState *state);
static GtkWidget* create_default_view();
static void plugin_cleanup(gpointer data);
static void on_mpris_name_appeared(const gchar *name, gpointer user_data) {
    MprisPluginState *state = user_data;
    if (g_list_find_custom(state->mpris_players, name, (GCompareFunc)g_strcmp0) == NULL) {
        state->mpris_players = g_list_append(state->mpris_players, g_strdup(name));
        update_view(state);
    }
}
static void on_mpris_name_vanished(const gchar *name, gpointer user_data) {
    MprisPluginState *state = user_data;
    GList *link = g_list_find_custom(state->mpris_players, name, (GCompareFunc)g_strcmp0);
    if (link) { g_free(link->data); state->mpris_players = g_list_delete_link(state->mpris_players, link); update_view(state); }
}
static void on_name_owner_changed(GDBusConnection *c, const gchar *s, const gchar *o, const gchar *i, const gchar *sig, GVariant *p, gpointer d) {
    (void)c; (void)s; (void)o; (void)i; (void)sig;
    const gchar *name, *old_owner, *new_owner;
    g_variant_get(p, "(sss)", &name, &old_owner, &new_owner);
    if (name && g_str_has_prefix(name, "org.mpris.MediaPlayer2.")) {
        if (new_owner && *new_owner) { on_mpris_name_appeared(name, d); }
        else { on_mpris_name_vanished(name, d); }
    }
}
static void update_view(MprisPluginState *state) {
    gboolean has_players = (state->mpris_players != NULL);
    if (has_players && state->mpris_state == NULL) {
        const gchar *bus_name = state->mpris_players->data;
        GtkWidget *old_view = gtk_stack_get_child_by_name(GTK_STACK(state->view_stack), "player-view");
        if (old_view) { gtk_stack_remove(GTK_STACK(state->view_stack), old_view); }
        GtkWidget *new_view = create_mpris_view(bus_name, &state->mpris_state, state->width, state->height);
        if (new_view) {
            state->mpris_state->window = GTK_WINDOW(gtk_widget_get_root(state->view_stack));
            gtk_stack_add_named(GTK_STACK(state->view_stack), new_view, "player-view");
            gtk_stack_set_visible_child_name(GTK_STACK(state->view_stack), "player-view");
        }
    } 
    else if (!has_players && state->mpris_state != NULL) {
        state->mpris_state = NULL;
        gtk_stack_set_visible_child_name(GTK_STACK(state->view_stack), "default-view");
        GtkWidget *old_view = gtk_stack_get_child_by_name(GTK_STACK(state->view_stack), "player-view");
        if (old_view) { gtk_stack_remove(GTK_STACK(state->view_stack), old_view); }
    }
}
static void setup_mpris_watcher(MprisPluginState *state) {
    g_autoptr(GError) error = NULL;
    state->dbus_connection = g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, &error);
    if (state->dbus_connection == NULL) { g_critical("MPRIS Plugin: FAILED to get D-Bus session connection. Error: %s", error ? error->message : "Unknown error"); return; }
    g_autoptr(GVariant) result = g_dbus_connection_call_sync(state->dbus_connection, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus", "ListNames", NULL, G_VARIANT_TYPE("(as)"), G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);
    if (error) { g_warning("MPRIS Plugin: DBus ListNames call failed: %s", error->message); }
    else if (result) {
        g_autoptr(GVariantIter) iter;
        g_variant_get(result, "(as)", &iter);
        gchar *name;
        while (g_variant_iter_loop(iter, "s", &name)) { if (g_str_has_prefix(name, "org.mpris.MediaPlayer2.")) { on_mpris_name_appeared(name, state); } }
    }
    state->name_watcher_id = g_dbus_connection_signal_subscribe(state->dbus_connection, "org.freedesktop.DBus", "org.freedesktop.DBus", "NameOwnerChanged", "/org/freedesktop/DBus", NULL, G_DBUS_SIGNAL_FLAGS_NONE, on_name_owner_changed, state, NULL);
}
static GtkWidget* create_default_view() {
    GtkWidget *box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 20);
    gtk_widget_set_vexpand(box, TRUE);
    gtk_widget_set_valign(box, GTK_ALIGN_CENTER);
    GtkWidget *image = gtk_image_new_from_icon_name("audio-headphones-symbolic");
    gtk_image_set_pixel_size(GTK_IMAGE(image), 96);
    gtk_widget_add_css_class(image, "artist-label");
    GtkWidget *label = gtk_label_new("No active player");
    gtk_widget_add_css_class(label, "title-label");
    gtk_box_append(GTK_BOX(box), image);
    gtk_box_append(GTK_BOX(box), label);
    return box;
}
static void plugin_cleanup(gpointer data) {
    MprisPluginState *state = (MprisPluginState*)data;
    if (!state) return;
    if (state->name_watcher_id > 0) { g_dbus_connection_signal_unsubscribe(state->dbus_connection, state->name_watcher_id); }
    g_clear_object(&state->dbus_connection);
    g_list_free_full(state->mpris_players, g_free);
    g_free(state);
}

// ===================================================================
//  Plugin Entry Point (Using GtkSizeGroup to FORCE size)
// ===================================================================
G_MODULE_EXPORT GtkWidget* create_widget(const char *config_string) {
    MprisPluginState *state = g_new0(MprisPluginState, 1);
    
    state->width = 300;
    state->height = 450;

    if (config_string && *config_string) {
        g_autoptr(JsonParser) parser = json_parser_new();
        if (json_parser_load_from_data(parser, config_string, -1, NULL)) {
            JsonObject *root_obj = json_node_get_object(json_parser_get_root(parser));
            if (json_object_has_member(root_obj, "size")) {
                JsonObject *size_obj = json_object_get_object_member(root_obj, "size");
                state->width = json_object_get_int_member_with_default(size_obj, "width", state->width);
                state->height = json_object_get_int_member_with_default(size_obj, "height", state->height);
            }
        }
    }
    // This print statement is now our proof. It MUST show 700.
    g_print("MPRIS Plugin: Forcing size with GtkSizeGroup -> Width: %d, Height: %d\n", state->width, state->height);

    // 1. Create a size group that will manage both width and height.
    GtkSizeGroup *size_group = gtk_size_group_new(GTK_SIZE_GROUP_BOTH);

    // 2. Create our main UI widget, the GtkStack.
    state->view_stack = gtk_stack_new();
    gtk_widget_set_name(state->view_stack, "aurora-mpris-player");
    gtk_widget_add_css_class(state->view_stack, "mpris-player-widget");
    gtk_stack_set_transition_type(GTK_STACK(state->view_stack), GTK_STACK_TRANSITION_TYPE_CROSSFADE);

    // 3. Create an invisible "dummy" widget. Its only purpose is to hold our size request.
    GtkWidget *sizing_dummy = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
    gtk_widget_set_size_request(sizing_dummy, state->width, state->height);

    // 4. Add BOTH widgets to the size group.
    gtk_size_group_add_widget(size_group, state->view_stack);
    gtk_size_group_add_widget(size_group, sizing_dummy);

    // 5. Attach state AND the size group to the main widget for cleanup.
    g_object_set_data_full(G_OBJECT(state->view_stack), "plugin-state", state, plugin_cleanup);
    g_object_set_data_full(G_OBJECT(state->view_stack), "size-group", size_group, g_object_unref);

    // 6. Setup the rest of the widget.
    GtkWidget *default_view = create_default_view();
    gtk_stack_add_named(GTK_STACK(state->view_stack), default_view, "default-view");
    setup_mpris_watcher(state);

    // 7. Return the view_stack, which has been forcibly resized by the group.
    return state->view_stack;
}
======================================================================
### FILE: ././widgets/mpris_player/src/utils.c
======================================================================
// src/utils.c

#include "utils.h"
#include <stdio.h>

typedef struct {
    GTask *task;
    char *command;
} CommandData;

static void on_command_finished(GObject *source_object, GAsyncResult *res, gpointer user_data) {
    CommandData *data = (CommandData*)user_data;
    GSubprocess *proc = G_SUBPROCESS(source_object);
    g_autoptr(GError) error = NULL;
    gchar *stdout_buffer = NULL;
    gchar *stderr_buffer = NULL;

    g_subprocess_communicate_utf8_finish(proc, res, &stdout_buffer, &stderr_buffer, &error);
    
    if (error) {
        g_warning("COMMAND FAILED: \"%s\"\n--- ERROR ---\n%s\n-------------\n", data->command, error->message);
        g_task_return_error(data->task, error);
    } else {
        // This is the robust pattern. We return ownership of stdout_buffer to the task.
        // The task will call g_free on it if nothing else claims it.
        g_task_return_pointer(data->task, stdout_buffer, g_free);
    }
    
    // We are done with stderr, free it immediately.
    g_free(stderr_buffer);
    
    g_object_unref(data->task);
    g_free(data->command);
    g_free(data);
}

void execute_command_async(const char* command, GAsyncReadyCallback callback, gpointer user_data) {
    g_autoptr(GError) error = NULL;
    gchar **argv = NULL;
    if (!g_shell_parse_argv(command, NULL, &argv, &error)) {
        g_warning("Error parsing command: %s", error->message);
        g_error_free(error);
        return;
    }

    GSubprocess *proc = g_subprocess_newv((const gchar * const *)argv,
                                          G_SUBPROCESS_FLAGS_STDOUT_PIPE | G_SUBPROCESS_FLAGS_STDERR_PIPE,
                                          &error);
    g_strfreev(argv);
    if (error) {
        g_warning("Error creating subprocess: %s", error->message);
        g_error_free(error);
        return;
    }
    
    CommandData *data = g_new(CommandData, 1);
    data->task = g_task_new(proc, NULL, callback, user_data);
    data->command = g_strdup(command);
    
    g_subprocess_communicate_utf8_async(proc, NULL, NULL, on_command_finished, data);
}

// This function now correctly propagates ownership of the string.
gchar* get_command_stdout(GAsyncResult *res) {
    g_autoptr(GError) error = NULL;
    // This transfers ownership of the string from the task to us.
    gchar *stdout_str = g_task_propagate_pointer(G_TASK(res), &error);
    if (error) {
        g_warning("Could not get command stdout: %s", error->message);
        g_clear_pointer(&stdout_str, g_free); // Free the string if an error occurred.
        return NULL;
    }
    return stdout_str; // The caller now owns the string.
}
======================================================================
### FILE: ././widgets/mpris_player/src/lyrics.h
======================================================================
// src/lyrics.h

#ifndef LYRICS_H
#define LYRICS_H

#include <gtk/gtk.h>
#include <gio/gio.h>

// Forward declare the MprisPopoutState struct.
// This tells the compiler that the type exists without needing its full definition,
// breaking the circular include chain.
typedef struct _MprisPopoutState MprisPopoutState;

typedef struct {
    guint64 timestamp_ms;
    gchar *line_text;
    GtkWidget *label;
} LyricLine;

typedef struct {
    GtkWidget *scrolled_window;
    GtkWidget *lyrics_box;
    GList *lyric_lines;
    gint current_line_index;
} LyricsView;

GtkWidget* create_lyrics_view(LyricsView **view_out);
void destroy_lyrics_view(LyricsView *view);
void clear_lyrics_display(LyricsView *view);
void parse_and_populate_lyrics(LyricsView *view, const gchar *lrc_data);

// The function signature remains the same, using the now-known forward-declared type.
void lyrics_view_sync_to_position(MprisPopoutState* state, gint64 position_us);

#endif // LYRICS_H
======================================================================
### FILE: ././widgets/mpris_player/meson.build
======================================================================
# widgets/mpris_player/meson.build

# Define all necessary dependencies for the widget
gtk_dep = dependency('gtk4')
adwaita_dep = dependency('libadwaita-1')
json_glib_dep = dependency('json-glib-1.0')
libsoup_dep = dependency('libsoup-3.0')

# Get the C compiler to find the math library (libm)
cc = meson.get_compiler('c')
math_dep = cc.find_library('m', required : true)

# List of all C source files for this widget
mpris_sources = [
  'src/main.c',
  'src/mpris.c',
  'src/lyrics.c',
  'src/utils.c',
]

# This is the corrected build instruction for the shared library plugin.
shared_library('mpris_player', mpris_sources,
  c_args : ['-pthread', '-D_GNU_SOURCE'],
  dependencies : [
    gtk_dep,
    adwaita_dep,
    json_glib_dep,
    libsoup_dep,
    math_dep
  ],
  install : true,
  install_dir: get_option('libdir') / 'aurora-shell' / 'widgets',
  name_prefix: '' # <-- This is the crucial fix
)
======================================================================
### FILE: ././src/aurora-shell/main.c
======================================================================
// ===============================================
//  Aurora Shell - Main Host Application
// ===============================================

#include <glib.h>
#include <glib/gstdio.h> // Needed for g_remove
#include <gtk/gtk.h>
#include <gtk4-layer-shell.h>
#include <dlfcn.h>
#include <json-glib/json-glib.h>
#include <string.h>
#include <gio/gio.h>
#include <unistd.h>
#include <sys/wait.h>

// ===============================================
// --- Type Definitions ---
// ===============================================
typedef struct {
    GtkWindow *window;
    GtkWidget *widget;
    gboolean is_interactive;
    JsonObject *config_obj;
} WidgetState;

typedef struct {
    GtkApplication *app;
    GHashTable *widgets;
    GFileMonitor *config_monitor;
    JsonNode *config_root;
} AuroraShell;

typedef GtkWidget* (*CreateWidgetFunc)(const char *config_string);

typedef struct {
    GtkCssProvider *provider;
    char *path;
} CssReloadData;

// *** NEW: Data for qscreen's "Capture First" logic ***
typedef struct {
    AuroraShell *shell;
    JsonObject *config_obj;
    gchar *temp_path;
} QScreenLaunchData;

static void load_all_widgets(AuroraShell *shell);
static WidgetState* create_single_widget(AuroraShell *shell, JsonObject *item_obj); // Forward declare


// ===============================================
// --- Helper and Utility Functions ---
// ===============================================
static void ensure_user_config_exists() {
    g_autofree gchar *user_config_dir_path = g_build_filename(g_get_user_config_dir(), "aurora-shell", NULL);
    g_autofree gchar *user_config_file_path = g_build_filename(user_config_dir_path, "config.json", NULL);
    if (g_file_test(user_config_file_path, G_FILE_TEST_EXISTS)) { return; }
    g_print("First run: User config not found. Creating default configuration at %s\n", user_config_dir_path);
    g_autoptr(GError) error = NULL;
    g_autoptr(GFile) user_config_dir = g_file_new_for_path(user_config_dir_path);
    if (!g_file_make_directory_with_parents(user_config_dir, NULL, &error)) { g_warning("Failed to create user config directory: %s", error->message); return; }
    g_autoptr(GFile) default_config_file = g_file_new_for_path("/usr/local/share/aurora-shell/config.json");
    g_autoptr(GFile) user_config_file = g_file_new_for_path(user_config_file_path);
    if (!g_file_copy(default_config_file, user_config_file, G_FILE_COPY_NONE, NULL, NULL, NULL, &error)) { g_warning("Failed to copy default config.json: %s", error->message); }
    g_autofree gchar *cp_command = g_strdup_printf("cp -r /usr/local/share/aurora-shell/templates %s", user_config_dir_path);
    g_spawn_command_line_sync(cp_command, NULL, NULL, NULL, NULL);
}

static void on_stylesheet_changed(GFileMonitor *monitor, GFile *file, GFile *other_file, GFileMonitorEvent event_type, gpointer user_data) {
    (void)monitor; (void)file; (void)other_file;
    if (event_type == G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT) {
        CssReloadData *data = (CssReloadData *)user_data;
        g_print("CSS file changed, reloading: %s\n", data->path);
        gtk_css_provider_load_from_path(data->provider, data->path);
    }
}

static void free_css_reload_data(gpointer data, GClosure *closure) {
    (void)closure;
    CssReloadData *reload_data = (CssReloadData *)data;
    g_free(reload_data->path);
    g_free(reload_data);
}

static void hide_widget(WidgetState *state) {
    if (state && gtk_widget_get_visible(GTK_WIDGET(state->window))) {
        gtk_widget_set_visible(GTK_WIDGET(state->window), FALSE);
    }
}

static void on_mouse_enter(GtkEventControllerMotion *controller, double x, double y, gpointer user_data) {
    (void)controller; (void)x; (void)y;
    WidgetState *state = (WidgetState *)user_data;
    gtk_widget_grab_focus(GTK_WIDGET(state->window));
}

static gboolean on_key_pressed(GtkEventControllerKey *controller, guint keyval, guint keycode, GdkModifierType state, gpointer user_data) {
    (void)controller; (void)keycode; (void)state;
    if (keyval == GDK_KEY_Escape) {
        hide_widget((WidgetState *)user_data);
        return GDK_EVENT_STOP;
    }
    return GDK_EVENT_PROPAGATE;
}


// ===============================================
// --- Core Shell Logic ---
// ===============================================
static void unload_all_widgets(AuroraShell *shell) {
    g_print("Unloading all widgets...\n");
    GHashTableIter iter;
    gpointer key, value;
    g_hash_table_iter_init(&iter, shell->widgets);
    while (g_hash_table_iter_next(&iter, &key, &value)) {
        WidgetState *state = (WidgetState *)value;
        if (GTK_IS_WINDOW(state->window)) { gtk_window_destroy(state->window); }
    }
    g_hash_table_remove_all(shell->widgets);
    while (g_main_context_pending(NULL)) { g_main_context_iteration(NULL, FALSE); }
    g_print("All widgets unloaded.\n");
}

static void on_config_changed(GFileMonitor *monitor, GFile *file, GFile *other_file, GFileMonitorEvent event_type, gpointer user_data) {
    (void)monitor; (void)file; (void)other_file;
    if (event_type == G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT) {
        g_print("Configuration file changed. Reloading shell...\n");
        AuroraShell *shell = (AuroraShell *)user_data;
        unload_all_widgets(shell);
        if (shell->config_root) { json_node_free(shell->config_root); shell->config_root = NULL; }
        load_all_widgets(shell);
    }
}

static GtkLayerShellLayer parse_layer_string(const gchar *layer_str) {
    if (g_strcmp0(layer_str, "bottom") == 0) return GTK_LAYER_SHELL_LAYER_BOTTOM;
    if (g_strcmp0(layer_str, "background") == 0) return GTK_LAYER_SHELL_LAYER_BACKGROUND;
    if (g_strcmp0(layer_str, "overlay") == 0) return GTK_LAYER_SHELL_LAYER_OVERLAY;
    return GTK_LAYER_SHELL_LAYER_TOP;
}

static void apply_anchor_and_margins(GtkWindow *window, GtkWidget *widget, JsonObject *widget_obj) {
    const char *anchor_str = json_object_get_string_member_with_default(widget_obj, "anchor", "center");
    if (strstr(anchor_str, "top"))    gtk_layer_set_anchor(window, GTK_LAYER_SHELL_EDGE_TOP, TRUE);
    if (strstr(anchor_str, "bottom")) gtk_layer_set_anchor(window, GTK_LAYER_SHELL_EDGE_BOTTOM, TRUE);
    if (strstr(anchor_str, "left"))   gtk_layer_set_anchor(window, GTK_LAYER_SHELL_EDGE_LEFT, TRUE);
    if (strstr(anchor_str, "right"))  gtk_layer_set_anchor(window, GTK_LAYER_SHELL_EDGE_RIGHT, TRUE);
    if (strstr(anchor_str, "left"))       gtk_widget_set_halign(widget, GTK_ALIGN_START);
    else if (strstr(anchor_str, "right")) gtk_widget_set_halign(widget, GTK_ALIGN_END);
    else                                  gtk_widget_set_halign(widget, GTK_ALIGN_CENTER);
    if (strstr(anchor_str, "top"))        gtk_widget_set_valign(widget, GTK_ALIGN_START);
    else if (strstr(anchor_str, "bottom"))gtk_widget_set_valign(widget, GTK_ALIGN_END);
    else                                  gtk_widget_set_valign(widget, GTK_ALIGN_CENTER);
    if (json_object_has_member(widget_obj, "margin")) {
        JsonObject *margin_obj = json_object_get_object_member(widget_obj, "margin");
        gtk_layer_set_margin(window, GTK_LAYER_SHELL_EDGE_TOP, json_object_get_int_member_with_default(margin_obj, "top", 0));
        gtk_layer_set_margin(window, GTK_LAYER_SHELL_EDGE_BOTTOM, json_object_get_int_member_with_default(margin_obj, "bottom", 0));
        gtk_layer_set_margin(window, GTK_LAYER_SHELL_EDGE_LEFT, json_object_get_int_member_with_default(margin_obj, "left", 0));
        gtk_layer_set_margin(window, GTK_LAYER_SHELL_EDGE_RIGHT, json_object_get_int_member_with_default(margin_obj, "right", 0));
    }
}

static void launch_daemon_if_needed(const char *command) {
    g_autofree gchar *check_pattern = g_strdup_printf("[%c]%s", command[0], command + 1);
    char *argv[] = { "/usr/bin/pgrep", "-f", check_pattern, NULL };
    g_autoptr(GError) error = NULL; gint exit_status = 0;
    gboolean success = g_spawn_sync(NULL, (gchar**)argv, NULL, G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL, NULL, NULL, NULL, NULL, &exit_status, &error);
    if (!success) { g_warning("Failed to run pgrep to check for daemon '%s': %s", command, error->message); }
    if (success && WIFEXITED(exit_status) && WEXITSTATUS(exit_status) == 0) { g_print("Daemon '%s' is already running.\n", command); return; }
    g_print("Spawning daemon: '%s'\n", command);
    g_autoptr(GError) spawn_error = NULL;
    g_spawn_command_line_async(command, &spawn_error);
    if (spawn_error) { g_warning("Failed to spawn daemon '%s': %s", command, spawn_error->message); }
}

// *** NEW: Create a widget from config. This is used by qscreen callback and load_all_widgets. ***
static WidgetState* create_single_widget(AuroraShell *shell, JsonObject *item_obj) {
    const char *name = json_object_get_string_member(item_obj, "name");
    const char *plugin_path = json_object_get_string_member(item_obj, "plugin");

    GtkWindow *window = GTK_WINDOW(gtk_application_window_new(shell->app));
    gtk_window_set_decorated(GTK_WINDOW(window), FALSE);
    GdkDisplay *display = gtk_widget_get_display(GTK_WIDGET(window));
    GtkCssProvider *transparency_provider = gtk_css_provider_new();
    gtk_css_provider_load_from_string(transparency_provider, "window { background: transparent; }");
    gtk_style_context_add_provider_for_display(display, GTK_STYLE_PROVIDER(transparency_provider), GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
    g_object_unref(transparency_provider);

    // *** THIS IS THE CRITICAL LOGIC FOR QSCREEN vs OTHER WIDGETS ***
    gboolean use_layer_shell = json_object_get_boolean_member_with_default(item_obj, "layer_shell", TRUE);
    if (use_layer_shell) {
        gtk_layer_init_for_window(window);
    } else {
        // This path is for qscreen: a normal, non-layer-shell fullscreen window.
        gtk_window_fullscreen(window);
    }
    
    void* handle = dlopen(plugin_path, RTLD_LAZY);
    if (!handle) { g_warning("Failed to open plugin '%s' for widget '%s': %s", plugin_path, name, dlerror()); gtk_window_destroy(window); return NULL; }
    CreateWidgetFunc create_widget = (CreateWidgetFunc)dlsym(handle, "create_widget");
    if (!create_widget) { g_warning("No 'create_widget' function in plugin '%s' for widget '%s'.", plugin_path, name); dlclose(handle); gtk_window_destroy(window); return NULL; }
    g_autofree gchar *config_string_to_pass = NULL;
    JsonNode *widget_node = json_node_new(JSON_NODE_OBJECT);
    json_node_set_object(widget_node, item_obj);
    g_autoptr(JsonGenerator) generator = json_generator_new();
    json_generator_set_root(generator, widget_node);
    config_string_to_pass = json_generator_to_data(generator, NULL);
    json_node_free(widget_node);
    GtkWidget *widget = create_widget(config_string_to_pass);
    if (!widget) { g_warning("Plugin '%s' for widget '%s' returned a NULL widget.", plugin_path, name); dlclose(handle); gtk_window_destroy(window); return NULL; }
    gtk_window_set_child(window, widget);

    gboolean is_exclusive = json_object_get_boolean_member_with_default(item_obj, "exclusive", FALSE);
    gboolean is_interactive = json_object_get_boolean_member_with_default(item_obj, "interactive", FALSE);

    if (use_layer_shell) {
        if (is_exclusive) {
            gtk_layer_auto_exclusive_zone_enable(window);
            gtk_layer_set_keyboard_mode(window, GTK_LAYER_SHELL_KEYBOARD_MODE_NONE);
        } else {
            gtk_layer_set_keyboard_mode(window, GTK_LAYER_SHELL_KEYBOARD_MODE_ON_DEMAND);
        }
        gtk_layer_set_layer(window, parse_layer_string(json_object_get_string_member_with_default(item_obj, "layer", "top")));
        apply_anchor_and_margins(window, widget, item_obj);
    }

    if (json_object_has_member(item_obj, "stylesheet")) {
        const char *stylesheet_name = json_object_get_string_member(item_obj, "stylesheet");
        g_autofree gchar *user_templates_dir = g_build_filename(g_get_user_config_dir(), "aurora-shell", "templates", name, NULL);
        g_autofree gchar *stylesheet_path = g_build_filename(user_templates_dir, stylesheet_name, NULL);
        if (stylesheet_path && g_file_test(stylesheet_path, G_FILE_TEST_IS_REGULAR)) {
            g_print("Loading stylesheet: %s\n", stylesheet_path);
            GtkCssProvider *provider = gtk_css_provider_new();
            gtk_css_provider_load_from_path(provider, stylesheet_path);
            gtk_style_context_add_provider_for_display(display, GTK_STYLE_PROVIDER(provider), GTK_STYLE_PROVIDER_PRIORITY_USER);
            GFile *css_file = g_file_new_for_path(stylesheet_path);
            GFileMonitor *monitor = g_file_monitor_file(css_file, G_FILE_MONITOR_NONE, NULL, NULL);
            CssReloadData *reload_data = g_new(CssReloadData, 1);
            reload_data->provider = provider; reload_data->path = g_strdup(stylesheet_path);
            g_signal_connect_data(monitor, "changed", G_CALLBACK(on_stylesheet_changed), reload_data, (GClosureNotify)free_css_reload_data, 0);
            g_object_set_data_full(G_OBJECT(window), "css-monitor", monitor, g_object_unref);
            g_object_unref(css_file);
        } else { g_warning("Stylesheet not found for '%s'. Searched at: %s", name, stylesheet_path ? stylesheet_path : "(null)"); }
    }
    
    WidgetState *state = g_new0(WidgetState, 1);
    state->window = window; state->widget = widget; state->is_interactive = is_interactive; state->config_obj = item_obj;

    if (!is_exclusive) {
        GtkEventController *key_controller = gtk_event_controller_key_new();
        g_signal_connect(key_controller, "key-pressed", G_CALLBACK(on_key_pressed), state);
        gtk_widget_add_controller(GTK_WIDGET(window), key_controller);
        GtkEventController *motion_controller = gtk_event_controller_motion_new();
        g_signal_connect(motion_controller, "enter", G_CALLBACK(on_mouse_enter), state);
        gtk_widget_add_controller(GTK_WIDGET(window), motion_controller);
    }
    return state;
}

static void load_all_widgets(AuroraShell *shell) {
    g_autoptr(JsonParser) parser = json_parser_new();
    g_autofree gchar *user_config_file_path = g_build_filename(g_get_user_config_dir(), "aurora-shell", "config.json", NULL);
    if (!json_parser_load_from_file(parser, user_config_file_path, NULL)) { g_warning("Failed to load or parse user config: %s", user_config_file_path); return; }
    shell->config_root = json_parser_steal_root(parser);
    if (!shell->config_root || !JSON_NODE_HOLDS_ARRAY(shell->config_root)) { g_warning("Config file root is not a valid JSON array."); if (shell->config_root) json_node_free(shell->config_root); shell->config_root = NULL; return; }
    JsonArray *config_array = json_node_get_array(shell->config_root);
    for (guint i = 0; i < json_array_get_length(config_array); i++) {
        if (!JSON_NODE_HOLDS_OBJECT(json_array_get_element(config_array, i))) continue;
        JsonObject *item_obj = json_array_get_object_element(config_array, i);
        const char *type = json_object_get_string_member_with_default(item_obj, "type", "widget");
        if (g_strcmp0(type, "daemon") == 0) { const char *command = json_object_get_string_member(item_obj, "command"); if (command) launch_daemon_if_needed(command); continue; }
        if (g_strcmp0(type, "widget") != 0) { continue; }
        const char *name = json_object_get_string_member(item_obj, "name");
        if (!name || !json_object_has_member(item_obj, "plugin")) continue;
        
        WidgetState *state = create_single_widget(shell, item_obj);
        if (state) {
            if (json_object_get_boolean_member_with_default(item_obj, "visible_on_start", TRUE)) {
                gtk_window_present(state->window);
            }
            g_hash_table_insert(shell->widgets, g_strdup(name), state);
        }
    }
}


// ===============================================
// --- GApplication Signal Handlers ---
// ===============================================
// *** NEW: Callback for qscreen after grim finishes ***
static void on_qscreen_pre_capture_finished(GPid pid, gint status, gpointer user_data) {
    g_spawn_close_pid(pid);
    QScreenLaunchData *data = (QScreenLaunchData *)user_data;
    if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
        g_print("qscreen pre-capture successful. Creating window.\n");
        json_object_set_string_member(data->config_obj, "temp_screenshot_path", data->temp_path);
        const char *name = json_object_get_string_member(data->config_obj, "name");
        WidgetState *new_state = create_single_widget(data->shell, data->config_obj);
        if (new_state) {
            gtk_window_present(new_state->window);
            g_hash_table_replace(data->shell->widgets, g_strdup(name), new_state);
        }
    } else {
        g_warning("qscreen pre-capture command (grim) failed. Aborting.");
        g_remove(data->temp_path);
    }
    g_free(data->temp_path);
    g_free(data);
}

static int command_line_handler(GApplication *app, GApplicationCommandLine *cmdline, gpointer user_data) {
    AuroraShell *shell = (AuroraShell *)user_data;
    gchar **argv = g_application_command_line_get_arguments(cmdline, NULL);
    if (argv[1] && g_strcmp0(argv[1], "--toggle") == 0 && argv[2]) {
        const char *widget_name = argv[2];
        JsonArray *config_array = json_node_get_array(shell->config_root);
        JsonObject *item_obj = NULL;
        for (guint i = 0; i < json_array_get_length(config_array); i++) {
            JsonObject *current_obj = json_array_get_object_element(config_array, i);
            const char *name = json_object_get_string_member(current_obj, "name");
            if (name && g_strcmp0(name, widget_name) == 0) { item_obj = current_obj; break; }
        }
        if (!item_obj) { g_warning("Command line: No config for '%s' found.", widget_name); }
        // *** NEW: Special handling for qscreen ***
        else if (g_strcmp0(widget_name, "qscreen") == 0) {
            g_autofree gchar *temp_template = g_build_filename(g_get_tmp_dir(), "aurora-qscreen-XXXXXX.png", NULL);
            gint fd = g_mkstemp(temp_template);
            if (fd == -1) { g_warning("Failed to create temp file for qscreen"); g_strfreev(argv); return 1; }
            close(fd);
            QScreenLaunchData *launch_data = g_new0(QScreenLaunchData, 1);
            launch_data->shell = shell;
            launch_data->config_obj = item_obj;
            launch_data->temp_path = g_strdup(temp_template);
            g_autofree gchar *command = g_strdup_printf("grim \"%s\"", launch_data->temp_path);
            g_autoptr(GError) error = NULL;
            GPid child_pid;
            g_spawn_command_line_async(command, &error);
            // We need to wait for the command to finish. Let's use g_spawn_async_with_pipes and a watch.
            g_spawn_async(NULL, (gchar*[]){"/bin/sh", "-c", command, NULL}, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &child_pid, &error);
            if (error) {
                g_warning("Failed to spawn grim: %s", error->message);
                g_free(launch_data->temp_path); g_free(launch_data);
            } else {
                g_child_watch_add(child_pid, on_qscreen_pre_capture_finished, launch_data);
            }
        }
        else {
            const char *type = json_object_get_string_member_with_default(item_obj, "type", "widget");
            if (g_strcmp0(type, "command") == 0 && json_object_has_member(item_obj, "command")) {
                const char *command_to_run = json_object_get_string_member(item_obj, "command");
                g_spawn_command_line_async(command_to_run, NULL);
            } else {
                WidgetState *state = g_hash_table_lookup(shell->widgets, widget_name);
                if (state) {
                    gboolean is_visible = gtk_widget_get_visible(GTK_WIDGET(state->window));
                    gtk_widget_set_visible(GTK_WIDGET(state->window), !is_visible);
                    if (!is_visible) {
                        if (state->is_interactive) { gtk_widget_grab_focus(GTK_WIDGET(state->window)); }
                        if (json_object_has_member(item_obj, "close")) {
                            JsonArray *widgets_to_close = json_object_get_array_member(item_obj, "close");
                            for (guint j = 0; j < json_array_get_length(widgets_to_close); j++) {
                                const char *name_to_close = json_array_get_string_element(widgets_to_close, j);
                                WidgetState *other_state = g_hash_table_lookup(shell->widgets, name_to_close);
                                if (other_state) hide_widget(other_state);
                            }
                        }
                    }
                } else { g_warning("No loaded widget named '%s' found.", widget_name); }
            }
        }
    } else { g_application_activate(app); }
    g_strfreev(argv);
    return 0;
}

static void activate_handler(GApplication *app, gpointer user_data) {
    (void)app;
    AuroraShell *shell = (AuroraShell *)user_data;
    ensure_user_config_exists();
    load_all_widgets(shell);
    g_autofree gchar *user_config_file_path = g_build_filename(g_get_user_config_dir(), "aurora-shell", "config.json", NULL);
    GFile *config_file = g_file_new_for_path(user_config_file_path);
    shell->config_monitor = g_file_monitor_file(config_file, G_FILE_MONITOR_NONE, NULL, NULL);
    if (shell->config_monitor) {
        g_print("Monitoring config file for changes: %s\n", user_config_file_path);
        g_signal_connect(shell->config_monitor, "changed", G_CALLBACK(on_config_changed), shell);
    } else { g_warning("Could not create file monitor for config file."); }
    g_object_unref(config_file);
}

static void free_widget_state(gpointer data) {
    g_free(data);
}


// ===============================================
// --- Main Program Entry Point ---
// ===============================================

int main(int argc, char **argv) {
    AuroraShell shell_data = {0};
    shell_data.widgets = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, free_widget_state);
    shell_data.app = gtk_application_new("com.meismeric.aurora.shell", G_APPLICATION_HANDLES_COMMAND_LINE);
    g_signal_connect(shell_data.app, "activate", G_CALLBACK(activate_handler), &shell_data);
    g_signal_connect(G_APPLICATION(shell_data.app), "command-line", G_CALLBACK(command_line_handler), &shell_data);
    int status = g_application_run(G_APPLICATION(shell_data.app), argc, argv);
    if (shell_data.config_monitor) { g_object_unref(shell_data.config_monitor); }
    if (shell_data.config_root) { json_node_free(shell_data.config_root); }
    g_hash_table_destroy(shell_data.widgets);
    g_object_unref(shell_data.app);
    return status;
}
======================================================================
### FILE: ././src/aurora-shell/meson.build
======================================================================
# This is the build script for the main aurora-shell executable.
# It is called from the root meson.build via subdir().

aurora_shell_sources = [
  'main.c',  # <-- THE FIX: Path is relative to this file.
]

aurora_shell_deps = [
  dependency('gtk4'),
  dependency('libadwaita-1'),
  dependency('gtk4-layer-shell-0'),
  dependency('dl'),
  dependency('json-glib-1.0'),
  dependency('libadwaita-1'),
]

executable('aurora-shell',
  aurora_shell_sources,
  dependencies: aurora_shell_deps,
  install: true,
  c_args: '-rdynamic', # Important for dlopen
)
======================================================================
### FILE: ././daemons/insight-daemon/meson.build
======================================================================
# This file should start directly with the dependencies and target
sqlite_dep = dependency('sqlite3')

executable('aurora-insight-daemon',
  'insight-daemon.c',
  dependencies : [sqlite_dep],
  install : true
)
======================================================================
### FILE: ././daemons/insight-daemon/insight-daemon.c
======================================================================
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sqlite3.h>
#include <signal.h>
#include <sys/select.h>

static sqlite3* db;
static char current_app_class[256] = {0};
static time_t focus_start_time = 0;

// --- Database Functions ---
int db_init(const char* db_path) {
    if (sqlite3_open(db_path, &db)) {
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        return 1;
    }
    const char* sql_create_table =
        "CREATE TABLE IF NOT EXISTS app_usage ("
        "  id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "  app_class TEXT NOT NULL,"
        "  date TEXT NOT NULL,"
        "  usage_seconds INTEGER NOT NULL,"
        "  UNIQUE(app_class, date)"
        ");";
    char* err_msg = 0;
    if (sqlite3_exec(db, sql_create_table, 0, 0, &err_msg) != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err_msg);
        sqlite3_free(err_msg);
        sqlite3_close(db);
        return 1;
    }
    printf("Database initialized successfully at %s\n", db_path);
    return 0;
}

void db_log_usage(const char* app_class, long duration) {
    if (duration <= 0 || strlen(app_class) == 0) {
        return;
    }
    char today_str[11];
    time_t now = time(NULL);
    strftime(today_str, sizeof(today_str), "%Y-%m-%d", localtime(&now));
    const char* sql_upsert =
        "INSERT INTO app_usage (app_class, date, usage_seconds) VALUES (?, ?, ?)"
        "ON CONFLICT(app_class, date) DO UPDATE SET usage_seconds = usage_seconds + excluded.usage_seconds;";
    sqlite3_stmt* stmt;
    if (sqlite3_prepare_v2(db, sql_upsert, -1, &stmt, 0) == SQLITE_OK) {
        sqlite3_bind_text(stmt, 1, app_class, -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, today_str, -1, SQLITE_STATIC);
        sqlite3_bind_int(stmt, 3, duration);
        if (sqlite3_step(stmt) != SQLITE_DONE) {
            fprintf(stderr, "Failed to execute statement: %s\n", sqlite3_errmsg(db));
        } else {
            printf("DB_LOG: Added %ld seconds to '%s' for %s\n", duration, app_class, today_str);
            system("touch ~/.local/share/aurora-insight.trigger > /dev/null 2>&1");
        }
        sqlite3_finalize(stmt);
    } else {
        fprintf(stderr, "Failed to prepare statement: %s\n", sqlite3_errmsg(db));
    }
}

// --- Event & Signal Handling ---
void log_current_session() {
    if (focus_start_time > 0 && strlen(current_app_class) > 0) {
        long time_spent = time(NULL) - focus_start_time;
        db_log_usage(current_app_class, time_spent);
    }
    focus_start_time = time(NULL);
}

void handle_exit_signal(int sig) {
    (void)sig;
    printf("\nCaught signal, logging final session and exiting...\n");
    log_current_session();
    sqlite3_close(db);
    exit(0);
}

void process_event(char* event_line) {
    const char* prefix = "activewindow>>";
    if (strncmp(event_line, prefix, strlen(prefix)) != 0) return;
    char* app_data = event_line + strlen(prefix);
    char* comma = strchr(app_data, ',');
    if (!comma) return;
    int class_len = comma - app_data;
    char new_app_class[256];
    strncpy(new_app_class, app_data, class_len);
    new_app_class[class_len] = '\0';
    if (strcmp(current_app_class, new_app_class) != 0) {
        log_current_session();
        strcpy(current_app_class, new_app_class);
        focus_start_time = time(NULL);
        if (strlen(current_app_class) > 0) {
            printf("FOCUS: '%s'\n", current_app_class);
        }
    }
}

// --- Main Loop ---
int main() {
    char db_path[256];
    snprintf(db_path, sizeof(db_path), "%s/.local/share/aurora-insight.db", getenv("HOME"));
    if (db_init(db_path) != 0) return 1;
    signal(SIGINT, handle_exit_signal);
    signal(SIGTERM, handle_exit_signal);
    const char* instance_signature = getenv("HYPRLAND_INSTANCE_SIGNATURE");
    if (!instance_signature) { fprintf(stderr, "ERROR: HYPRLAND_INSTANCE_SIGNATURE is not set.\n"); return 1; }
    char socket_path[256];
    snprintf(socket_path, sizeof(socket_path), "%s/hypr/%s/.socket2.sock", getenv("XDG_RUNTIME_DIR"), instance_signature);
    int sock_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sock_fd == -1) { perror("socket"); return 1; }
    struct sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path) - 1);
    if (connect(sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        perror("connect"); close(sock_fd); return 1;
    }
    printf("Successfully connected! Tracking app focus...\n");
    while (1) {
        fd_set fds;
        FD_ZERO(&fds);
        FD_SET(sock_fd, &fds);
        struct timeval tv;
        tv.tv_sec = 30;
        tv.tv_usec = 0;
        int retval = select(sock_fd + 1, &fds, NULL, NULL, &tv);
        if (retval == -1) {
            perror("select()");
            break;
        } else if (retval > 0) {
            if (FD_ISSET(sock_fd, &fds)) {
                char buffer[4096];
                ssize_t bytes_read = read(sock_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    char* line = strtok(buffer, "\n");
                    while (line != NULL) {
                        process_event(line);
                        line = strtok(NULL, "\n");
                    }
                } else {
                    if (bytes_read == 0) printf("Connection closed by peer.\n");
                    else perror("read");
                    break;
                }
            }
        } else {
            printf("PERIODIC LOG: 30s timeout reached.\n");
            log_current_session();
        }
    }
    handle_exit_signal(0);
    return 0;
}
======================================================================
### FILE: ././daemons/meson.build
======================================================================
subdir('insight-daemon')
======================================================================
### FILE: ././build/meson-private/sanitycheckc.c
======================================================================
int main(void) { int class=0; return class; }

======================================================================
### FILE: ././build/meson-private/__CMake_compiler_info__/CMakeFiles/4.1.2/CompilerIdC/CMakeCCompilerId.c
======================================================================
#ifdef __cplusplus
# error "A C++ compiler has been selected for C."
#endif

#if defined(__18CXX)
# define ID_VOID_MAIN
#endif
#if defined(__CLASSIC_C__)
/* cv-qualifiers did not exist in K&R C */
# define const
# define volatile
#endif

#if !defined(__has_include)
/* If the compiler does not have __has_include, pretend the answer is
   always no.  */
#  define __has_include(x) 0
#endif


/* Version number components: V=Version, R=Revision, P=Patch
   Version date components:   YYYY=Year, MM=Month,   DD=Day  */

#if defined(__INTEL_COMPILER) || defined(__ICC)
# define COMPILER_ID "Intel"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# if defined(__GNUC__)
#  define SIMULATE_ID "GNU"
# endif
  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,
     except that a few beta releases use the old format with V=2021.  */
# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)
#  if defined(__INTEL_COMPILER_UPDATE)
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)
#  else
#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)
#  endif
# else
#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)
#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)
   /* The third version component from --version is an update index,
      but no macro is provided for it.  */
#  define COMPILER_VERSION_PATCH DEC(0)
# endif
# if defined(__INTEL_COMPILER_BUILD_DATE)
   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */
#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)
# endif
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# if defined(__GNUC__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
# elif defined(__GNUG__)
#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
# endif
# if defined(__GNUC_MINOR__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)
# define COMPILER_ID "IntelLLVM"
#if defined(_MSC_VER)
# define SIMULATE_ID "MSVC"
#endif
#if defined(__GNUC__)
# define SIMULATE_ID "GNU"
#endif
/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and
 * later.  Look for 6 digit vs. 8 digit version number to decide encoding.
 * VVVV is no smaller than the current year when a version is released.
 */
#if __INTEL_LLVM_COMPILER < 1000000L
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)
#else
# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)
# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)
#endif
#if defined(_MSC_VER)
  /* _MSC_VER = VVRR */
# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
#endif
#if defined(__GNUC__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#elif defined(__GNUG__)
# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)
#endif
#if defined(__GNUC_MINOR__)
# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#endif
#if defined(__GNUC_PATCHLEVEL__)
# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#endif

#elif defined(__PATHCC__)
# define COMPILER_ID "PathScale"
# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)
# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)
# if defined(__PATHCC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)
# endif

#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)
# define COMPILER_ID "Embarcadero"
# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)
# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)
# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)

#elif defined(__BORLANDC__)
# define COMPILER_ID "Borland"
  /* __BORLANDC__ = 0xVRR */
# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)
# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)

#elif defined(__WATCOMC__) && __WATCOMC__ < 1200
# define COMPILER_ID "Watcom"
   /* __WATCOMC__ = VVRR */
# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__WATCOMC__)
# define COMPILER_ID "OpenWatcom"
   /* __WATCOMC__ = VVRP + 1100 */
# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)
# if (__WATCOMC__ % 10) > 0
#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)
# endif

#elif defined(__SUNPRO_C)
# define COMPILER_ID "SunPro"
# if __SUNPRO_C >= 0x5100
   /* __SUNPRO_C = 0xVRRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>12)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xFF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
# else
   /* __SUNPRO_CC = 0xVRP */
#  define COMPILER_VERSION_MAJOR HEX(__SUNPRO_C>>8)
#  define COMPILER_VERSION_MINOR HEX(__SUNPRO_C>>4 & 0xF)
#  define COMPILER_VERSION_PATCH HEX(__SUNPRO_C    & 0xF)
# endif

#elif defined(__HP_cc)
# define COMPILER_ID "HP"
  /* __HP_cc = VVRRPP */
# define COMPILER_VERSION_MAJOR DEC(__HP_cc/10000)
# define COMPILER_VERSION_MINOR DEC(__HP_cc/100 % 100)
# define COMPILER_VERSION_PATCH DEC(__HP_cc     % 100)

#elif defined(__DECC)
# define COMPILER_ID "Compaq"
  /* __DECC_VER = VVRRTPPPP */
# define COMPILER_VERSION_MAJOR DEC(__DECC_VER/10000000)
# define COMPILER_VERSION_MINOR DEC(__DECC_VER/100000  % 100)
# define COMPILER_VERSION_PATCH DEC(__DECC_VER         % 10000)

#elif defined(__IBMC__) && defined(__COMPILER_VER__)
# define COMPILER_ID "zOS"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__open_xl__) && defined(__clang__)
# define COMPILER_ID "IBMClang"
# define COMPILER_VERSION_MAJOR DEC(__open_xl_version__)
# define COMPILER_VERSION_MINOR DEC(__open_xl_release__)
# define COMPILER_VERSION_PATCH DEC(__open_xl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__open_xl_ptf_fix_level__)
# define COMPILER_VERSION_INTERNAL_STR  __clang_version__


#elif defined(__ibmxl__) && defined(__clang__)
# define COMPILER_ID "XLClang"
# define COMPILER_VERSION_MAJOR DEC(__ibmxl_version__)
# define COMPILER_VERSION_MINOR DEC(__ibmxl_release__)
# define COMPILER_VERSION_PATCH DEC(__ibmxl_modification__)
# define COMPILER_VERSION_TWEAK DEC(__ibmxl_ptf_fix_level__)


#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ >= 800
# define COMPILER_ID "XL"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__IBMC__) && !defined(__COMPILER_VER__) && __IBMC__ < 800
# define COMPILER_ID "VisualAge"
  /* __IBMC__ = VRP */
# define COMPILER_VERSION_MAJOR DEC(__IBMC__/100)
# define COMPILER_VERSION_MINOR DEC(__IBMC__/10 % 10)
# define COMPILER_VERSION_PATCH DEC(__IBMC__    % 10)

#elif defined(__NVCOMPILER)
# define COMPILER_ID "NVHPC"
# define COMPILER_VERSION_MAJOR DEC(__NVCOMPILER_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__NVCOMPILER_MINOR__)
# if defined(__NVCOMPILER_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__NVCOMPILER_PATCHLEVEL__)
# endif

#elif defined(__PGI)
# define COMPILER_ID "PGI"
# define COMPILER_VERSION_MAJOR DEC(__PGIC__)
# define COMPILER_VERSION_MINOR DEC(__PGIC_MINOR__)
# if defined(__PGIC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__PGIC_PATCHLEVEL__)
# endif

#elif defined(__clang__) && defined(__cray__)
# define COMPILER_ID "CrayClang"
# define COMPILER_VERSION_MAJOR DEC(__cray_major__)
# define COMPILER_VERSION_MINOR DEC(__cray_minor__)
# define COMPILER_VERSION_PATCH DEC(__cray_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(_CRAYC)
# define COMPILER_ID "Cray"
# define COMPILER_VERSION_MAJOR DEC(_RELEASE_MAJOR)
# define COMPILER_VERSION_MINOR DEC(_RELEASE_MINOR)

#elif defined(__TI_COMPILER_VERSION__)
# define COMPILER_ID "TI"
  /* __TI_COMPILER_VERSION__ = VVVRRRPPP */
# define COMPILER_VERSION_MAJOR DEC(__TI_COMPILER_VERSION__/1000000)
# define COMPILER_VERSION_MINOR DEC(__TI_COMPILER_VERSION__/1000   % 1000)
# define COMPILER_VERSION_PATCH DEC(__TI_COMPILER_VERSION__        % 1000)

#elif defined(__CLANG_FUJITSU)
# define COMPILER_ID "FujitsuClang"
# define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
# define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
# define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# define COMPILER_VERSION_INTERNAL_STR __clang_version__


#elif defined(__FUJITSU)
# define COMPILER_ID "Fujitsu"
# if defined(__FCC_version__)
#   define COMPILER_VERSION __FCC_version__
# elif defined(__FCC_major__)
#   define COMPILER_VERSION_MAJOR DEC(__FCC_major__)
#   define COMPILER_VERSION_MINOR DEC(__FCC_minor__)
#   define COMPILER_VERSION_PATCH DEC(__FCC_patchlevel__)
# endif
# if defined(__fcc_version)
#   define COMPILER_VERSION_INTERNAL DEC(__fcc_version)
# elif defined(__FCC_VERSION)
#   define COMPILER_VERSION_INTERNAL DEC(__FCC_VERSION)
# endif


#elif defined(__ghs__)
# define COMPILER_ID "GHS"
/* __GHS_VERSION_NUMBER = VVVVRP */
# ifdef __GHS_VERSION_NUMBER
# define COMPILER_VERSION_MAJOR DEC(__GHS_VERSION_NUMBER / 100)
# define COMPILER_VERSION_MINOR DEC(__GHS_VERSION_NUMBER / 10 % 10)
# define COMPILER_VERSION_PATCH DEC(__GHS_VERSION_NUMBER      % 10)
# endif

#elif defined(__TASKING__)
# define COMPILER_ID "Tasking"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION__/1000)
  # define COMPILER_VERSION_MINOR DEC(__VERSION__ % 100)
# define COMPILER_VERSION_INTERNAL DEC(__VERSION__)

#elif defined(__ORANGEC__)
# define COMPILER_ID "OrangeC"
# define COMPILER_VERSION_MAJOR DEC(__ORANGEC_MAJOR__)
# define COMPILER_VERSION_MINOR DEC(__ORANGEC_MINOR__)
# define COMPILER_VERSION_PATCH DEC(__ORANGEC_PATCHLEVEL__)

#elif defined(__RENESAS__)
# define COMPILER_ID "Renesas"
/* __RENESAS_VERSION__ = 0xVVRRPP00 */
# define COMPILER_VERSION_MAJOR HEX(__RENESAS_VERSION__ >> 24 & 0xFF)
# define COMPILER_VERSION_MINOR HEX(__RENESAS_VERSION__ >> 16 & 0xFF)
# define COMPILER_VERSION_PATCH HEX(__RENESAS_VERSION__ >> 8  & 0xFF)

#elif defined(__TINYC__)
# define COMPILER_ID "TinyCC"

#elif defined(__BCC__)
# define COMPILER_ID "Bruce"

#elif defined(__SCO_VERSION__)
# define COMPILER_ID "SCO"

#elif defined(__ARMCC_VERSION) && !defined(__clang__)
# define COMPILER_ID "ARMCC"
#if __ARMCC_VERSION >= 1000000
  /* __ARMCC_VERSION = VRRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION     % 10000)
#else
  /* __ARMCC_VERSION = VRPPPP */
  # define COMPILER_VERSION_MAJOR DEC(__ARMCC_VERSION/100000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCC_VERSION/10000 % 10)
  # define COMPILER_VERSION_PATCH DEC(__ARMCC_VERSION    % 10000)
#endif


#elif defined(__clang__) && defined(__apple_build_version__)
# define COMPILER_ID "AppleClang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif
# define COMPILER_VERSION_TWEAK DEC(__apple_build_version__)

#elif defined(__clang__) && defined(__ARMCOMPILER_VERSION)
# define COMPILER_ID "ARMClang"
  # define COMPILER_VERSION_MAJOR DEC(__ARMCOMPILER_VERSION/1000000)
  # define COMPILER_VERSION_MINOR DEC(__ARMCOMPILER_VERSION/10000 % 100)
  # define COMPILER_VERSION_PATCH DEC(__ARMCOMPILER_VERSION/100   % 100)
# define COMPILER_VERSION_INTERNAL DEC(__ARMCOMPILER_VERSION)

#elif defined(__clang__) && defined(__ti__)
# define COMPILER_ID "TIClang"
  # define COMPILER_VERSION_MAJOR DEC(__ti_major__)
  # define COMPILER_VERSION_MINOR DEC(__ti_minor__)
  # define COMPILER_VERSION_PATCH DEC(__ti_patchlevel__)
# define COMPILER_VERSION_INTERNAL DEC(__ti_version__)

#elif defined(__clang__)
# define COMPILER_ID "Clang"
# if defined(_MSC_VER)
#  define SIMULATE_ID "MSVC"
# endif
# define COMPILER_VERSION_MAJOR DEC(__clang_major__)
# define COMPILER_VERSION_MINOR DEC(__clang_minor__)
# define COMPILER_VERSION_PATCH DEC(__clang_patchlevel__)
# if defined(_MSC_VER)
   /* _MSC_VER = VVRR */
#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)
#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)
# endif

#elif defined(__LCC__) && (defined(__GNUC__) || defined(__GNUG__) || defined(__MCST__))
# define COMPILER_ID "LCC"
# define COMPILER_VERSION_MAJOR DEC(__LCC__ / 100)
# define COMPILER_VERSION_MINOR DEC(__LCC__ % 100)
# if defined(__LCC_MINOR__)
#  define COMPILER_VERSION_PATCH DEC(__LCC_MINOR__)
# endif
# if defined(__GNUC__) && defined(__GNUC_MINOR__)
#  define SIMULATE_ID "GNU"
#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)
#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)
#  if defined(__GNUC_PATCHLEVEL__)
#   define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
#  endif
# endif

#elif defined(__GNUC__)
# define COMPILER_ID "GNU"
# define COMPILER_VERSION_MAJOR DEC(__GNUC__)
# if defined(__GNUC_MINOR__)
#  define COMPILER_VERSION_MINOR DEC(__GNUC_MINOR__)
# endif
# if defined(__GNUC_PATCHLEVEL__)
#  define COMPILER_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)
# endif

#elif defined(_MSC_VER)
# define COMPILER_ID "MSVC"
  /* _MSC_VER = VVRR */
# define COMPILER_VERSION_MAJOR DEC(_MSC_VER / 100)
# define COMPILER_VERSION_MINOR DEC(_MSC_VER % 100)
# if defined(_MSC_FULL_VER)
#  if _MSC_VER >= 1400
    /* _MSC_FULL_VER = VVRRPPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 100000)
#  else
    /* _MSC_FULL_VER = VVRRPPPP */
#   define COMPILER_VERSION_PATCH DEC(_MSC_FULL_VER % 10000)
#  endif
# endif
# if defined(_MSC_BUILD)
#  define COMPILER_VERSION_TWEAK DEC(_MSC_BUILD)
# endif

#elif defined(_ADI_COMPILER)
# define COMPILER_ID "ADSP"
#if defined(__VERSIONNUM__)
  /* __VERSIONNUM__ = 0xVVRRPPTT */
#  define COMPILER_VERSION_MAJOR DEC(__VERSIONNUM__ >> 24 & 0xFF)
#  define COMPILER_VERSION_MINOR DEC(__VERSIONNUM__ >> 16 & 0xFF)
#  define COMPILER_VERSION_PATCH DEC(__VERSIONNUM__ >> 8 & 0xFF)
#  define COMPILER_VERSION_TWEAK DEC(__VERSIONNUM__ & 0xFF)
#endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# define COMPILER_ID "IAR"
# if defined(__VER__) && defined(__ICCARM__)
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 1000000)
#  define COMPILER_VERSION_MINOR DEC(((__VER__) / 1000) % 1000)
#  define COMPILER_VERSION_PATCH DEC((__VER__) % 1000)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# elif defined(__VER__) && (defined(__ICCAVR__) || defined(__ICCRX__) || defined(__ICCRH850__) || defined(__ICCRL78__) || defined(__ICC430__) || defined(__ICCRISCV__) || defined(__ICCV850__) || defined(__ICC8051__) || defined(__ICCSTM8__))
#  define COMPILER_VERSION_MAJOR DEC((__VER__) / 100)
#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
#  define COMPILER_VERSION_PATCH DEC(__SUBVERSION__)
#  define COMPILER_VERSION_INTERNAL DEC(__IAR_SYSTEMS_ICC__)
# endif

#elif defined(__DCC__) && defined(_DIAB_TOOL)
# define COMPILER_ID "Diab"
  # define COMPILER_VERSION_MAJOR DEC(__VERSION_MAJOR_NUMBER__)
  # define COMPILER_VERSION_MINOR DEC(__VERSION_MINOR_NUMBER__)
  # define COMPILER_VERSION_PATCH DEC(__VERSION_ARCH_FEATURE_NUMBER__)
  # define COMPILER_VERSION_TWEAK DEC(__VERSION_BUG_FIX_NUMBER__)


#elif defined(__SDCC_VERSION_MAJOR) || defined(SDCC)
# define COMPILER_ID "SDCC"
# if defined(__SDCC_VERSION_MAJOR)
#  define COMPILER_VERSION_MAJOR DEC(__SDCC_VERSION_MAJOR)
#  define COMPILER_VERSION_MINOR DEC(__SDCC_VERSION_MINOR)
#  define COMPILER_VERSION_PATCH DEC(__SDCC_VERSION_PATCH)
# else
  /* SDCC = VRP */
#  define COMPILER_VERSION_MAJOR DEC(SDCC/100)
#  define COMPILER_VERSION_MINOR DEC(SDCC/10 % 10)
#  define COMPILER_VERSION_PATCH DEC(SDCC    % 10)
# endif


/* These compilers are either not known or too old to define an
  identification macro.  Try to identify the platform and guess that
  it is the native compiler.  */
#elif defined(__hpux) || defined(__hpua)
# define COMPILER_ID "HP"

#else /* unknown compiler */
# define COMPILER_ID ""
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";
#ifdef SIMULATE_ID
char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";
#endif

#ifdef __QNXNTO__
char const* qnxnto = "INFO" ":" "qnxnto[]";
#endif

#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";
#endif

#define STRINGIFY_HELPER(X) #X
#define STRINGIFY(X) STRINGIFY_HELPER(X)

/* Identify known platforms by name.  */
#if defined(__linux) || defined(__linux__) || defined(linux)
# define PLATFORM_ID "Linux"

#elif defined(__MSYS__)
# define PLATFORM_ID "MSYS"

#elif defined(__CYGWIN__)
# define PLATFORM_ID "Cygwin"

#elif defined(__MINGW32__)
# define PLATFORM_ID "MinGW"

#elif defined(__APPLE__)
# define PLATFORM_ID "Darwin"

#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
# define PLATFORM_ID "Windows"

#elif defined(__FreeBSD__) || defined(__FreeBSD)
# define PLATFORM_ID "FreeBSD"

#elif defined(__NetBSD__) || defined(__NetBSD)
# define PLATFORM_ID "NetBSD"

#elif defined(__OpenBSD__) || defined(__OPENBSD)
# define PLATFORM_ID "OpenBSD"

#elif defined(__sun) || defined(sun)
# define PLATFORM_ID "SunOS"

#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)
# define PLATFORM_ID "AIX"

#elif defined(__hpux) || defined(__hpux__)
# define PLATFORM_ID "HP-UX"

#elif defined(__HAIKU__)
# define PLATFORM_ID "Haiku"

#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)
# define PLATFORM_ID "BeOS"

#elif defined(__QNX__) || defined(__QNXNTO__)
# define PLATFORM_ID "QNX"

#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)
# define PLATFORM_ID "Tru64"

#elif defined(__riscos) || defined(__riscos__)
# define PLATFORM_ID "RISCos"

#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)
# define PLATFORM_ID "SINIX"

#elif defined(__UNIX_SV__)
# define PLATFORM_ID "UNIX_SV"

#elif defined(__bsdos__)
# define PLATFORM_ID "BSDOS"

#elif defined(_MPRAS) || defined(MPRAS)
# define PLATFORM_ID "MP-RAS"

#elif defined(__osf) || defined(__osf__)
# define PLATFORM_ID "OSF1"

#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)
# define PLATFORM_ID "SCO_SV"

#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)
# define PLATFORM_ID "ULTRIX"

#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)
# define PLATFORM_ID "Xenix"

#elif defined(__WATCOMC__)
# if defined(__LINUX__)
#  define PLATFORM_ID "Linux"

# elif defined(__DOS__)
#  define PLATFORM_ID "DOS"

# elif defined(__OS2__)
#  define PLATFORM_ID "OS2"

# elif defined(__WINDOWS__)
#  define PLATFORM_ID "Windows3x"

# elif defined(__VXWORKS__)
#  define PLATFORM_ID "VxWorks"

# else /* unknown platform */
#  define PLATFORM_ID
# endif

#elif defined(__INTEGRITY)
# if defined(INT_178B)
#  define PLATFORM_ID "Integrity178"

# else /* regular Integrity */
#  define PLATFORM_ID "Integrity"
# endif

# elif defined(_ADI_COMPILER)
#  define PLATFORM_ID "ADSP"

#else /* unknown platform */
# define PLATFORM_ID

#endif

/* For windows compilers MSVC and Intel we can determine
   the architecture of the compiler being used.  This is because
   the compilers do not have flags that can change the architecture,
   but rather depend on which compiler is being used
*/
#if defined(_WIN32) && defined(_MSC_VER)
# if defined(_M_IA64)
#  define ARCHITECTURE_ID "IA64"

# elif defined(_M_ARM64EC)
#  define ARCHITECTURE_ID "ARM64EC"

# elif defined(_M_X64) || defined(_M_AMD64)
#  define ARCHITECTURE_ID "x64"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# elif defined(_M_ARM64)
#  define ARCHITECTURE_ID "ARM64"

# elif defined(_M_ARM)
#  if _M_ARM == 4
#   define ARCHITECTURE_ID "ARMV4I"
#  elif _M_ARM == 5
#   define ARCHITECTURE_ID "ARMV5I"
#  else
#   define ARCHITECTURE_ID "ARMV" STRINGIFY(_M_ARM)
#  endif

# elif defined(_M_MIPS)
#  define ARCHITECTURE_ID "MIPS"

# elif defined(_M_SH)
#  define ARCHITECTURE_ID "SHx"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__WATCOMC__)
# if defined(_M_I86)
#  define ARCHITECTURE_ID "I86"

# elif defined(_M_IX86)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__IAR_SYSTEMS_ICC__) || defined(__IAR_SYSTEMS_ICC)
# if defined(__ICCARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__ICCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__ICCRH850__)
#  define ARCHITECTURE_ID "RH850"

# elif defined(__ICCRL78__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__ICCRISCV__)
#  define ARCHITECTURE_ID "RISCV"

# elif defined(__ICCAVR__)
#  define ARCHITECTURE_ID "AVR"

# elif defined(__ICC430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__ICCV850__)
#  define ARCHITECTURE_ID "V850"

# elif defined(__ICC8051__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__ICCSTM8__)
#  define ARCHITECTURE_ID "STM8"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__ghs__)
# if defined(__PPC64__)
#  define ARCHITECTURE_ID "PPC64"

# elif defined(__ppc__)
#  define ARCHITECTURE_ID "PPC"

# elif defined(__ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__x86_64__)
#  define ARCHITECTURE_ID "x64"

# elif defined(__i386__)
#  define ARCHITECTURE_ID "X86"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__clang__) && defined(__ti__)
# if defined(__ARM_ARCH)
#  define ARCHITECTURE_ID "ARM"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__TI_COMPILER_VERSION__)
# if defined(__TI_ARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__MSP430__)
#  define ARCHITECTURE_ID "MSP430"

# elif defined(__TMS320C28XX__)
#  define ARCHITECTURE_ID "TMS320C28x"

# elif defined(__TMS320C6X__) || defined(_TMS320C6X)
#  define ARCHITECTURE_ID "TMS320C6x"

# else /* unknown architecture */
#  define ARCHITECTURE_ID ""
# endif

# elif defined(__ADSPSHARC__)
#  define ARCHITECTURE_ID "SHARC"

# elif defined(__ADSPBLACKFIN__)
#  define ARCHITECTURE_ID "Blackfin"

#elif defined(__TASKING__)

# if defined(__CTC__) || defined(__CPTC__)
#  define ARCHITECTURE_ID "TriCore"

# elif defined(__CMCS__)
#  define ARCHITECTURE_ID "MCS"

# elif defined(__CARM__) || defined(__CPARM__)
#  define ARCHITECTURE_ID "ARM"

# elif defined(__CARC__)
#  define ARCHITECTURE_ID "ARC"

# elif defined(__C51__)
#  define ARCHITECTURE_ID "8051"

# elif defined(__CPCP__)
#  define ARCHITECTURE_ID "PCP"

# else
#  define ARCHITECTURE_ID ""
# endif

#elif defined(__RENESAS__)
# if defined(__CCRX__)
#  define ARCHITECTURE_ID "RX"

# elif defined(__CCRL__)
#  define ARCHITECTURE_ID "RL78"

# elif defined(__CCRH__)
#  define ARCHITECTURE_ID "RH850"

# else
#  define ARCHITECTURE_ID ""
# endif

#else
#  define ARCHITECTURE_ID
#endif

/* Convert integer to decimal digit literals.  */
#define DEC(n)                   \
  ('0' + (((n) / 10000000)%10)), \
  ('0' + (((n) / 1000000)%10)),  \
  ('0' + (((n) / 100000)%10)),   \
  ('0' + (((n) / 10000)%10)),    \
  ('0' + (((n) / 1000)%10)),     \
  ('0' + (((n) / 100)%10)),      \
  ('0' + (((n) / 10)%10)),       \
  ('0' +  ((n) % 10))

/* Convert integer to hex digit literals.  */
#define HEX(n)             \
  ('0' + ((n)>>28 & 0xF)), \
  ('0' + ((n)>>24 & 0xF)), \
  ('0' + ((n)>>20 & 0xF)), \
  ('0' + ((n)>>16 & 0xF)), \
  ('0' + ((n)>>12 & 0xF)), \
  ('0' + ((n)>>8  & 0xF)), \
  ('0' + ((n)>>4  & 0xF)), \
  ('0' + ((n)     & 0xF))

/* Construct a string literal encoding the version number. */
#ifdef COMPILER_VERSION
char const* info_version = "INFO" ":" "compiler_version[" COMPILER_VERSION "]";

/* Construct a string literal encoding the version number components. */
#elif defined(COMPILER_VERSION_MAJOR)
char const info_version[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','[',
  COMPILER_VERSION_MAJOR,
# ifdef COMPILER_VERSION_MINOR
  '.', COMPILER_VERSION_MINOR,
#  ifdef COMPILER_VERSION_PATCH
   '.', COMPILER_VERSION_PATCH,
#   ifdef COMPILER_VERSION_TWEAK
    '.', COMPILER_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct a string literal encoding the internal version number. */
#ifdef COMPILER_VERSION_INTERNAL
char const info_version_internal[] = {
  'I', 'N', 'F', 'O', ':',
  'c','o','m','p','i','l','e','r','_','v','e','r','s','i','o','n','_',
  'i','n','t','e','r','n','a','l','[',
  COMPILER_VERSION_INTERNAL,']','\0'};
#elif defined(COMPILER_VERSION_INTERNAL_STR)
char const* info_version_internal = "INFO" ":" "compiler_version_internal[" COMPILER_VERSION_INTERNAL_STR "]";
#endif

/* Construct a string literal encoding the version number components. */
#ifdef SIMULATE_VERSION_MAJOR
char const info_simulate_version[] = {
  'I', 'N', 'F', 'O', ':',
  's','i','m','u','l','a','t','e','_','v','e','r','s','i','o','n','[',
  SIMULATE_VERSION_MAJOR,
# ifdef SIMULATE_VERSION_MINOR
  '.', SIMULATE_VERSION_MINOR,
#  ifdef SIMULATE_VERSION_PATCH
   '.', SIMULATE_VERSION_PATCH,
#   ifdef SIMULATE_VERSION_TWEAK
    '.', SIMULATE_VERSION_TWEAK,
#   endif
#  endif
# endif
  ']','\0'};
#endif

/* Construct the string literal in pieces to prevent the source from
   getting matched.  Store it in a pointer rather than an array
   because some compilers will just produce instructions to fill the
   array rather than assigning a pointer to a static array.  */
char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";
char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";



#define C_STD_99 199901L
#define C_STD_11 201112L
#define C_STD_17 201710L
#define C_STD_23 202311L

#ifdef __STDC_VERSION__
#  define C_STD __STDC_VERSION__
#endif

#if !defined(__STDC__) && !defined(__clang__) && !defined(__RENESAS__)
# if defined(_MSC_VER) || defined(__ibmxl__) || defined(__IBMC__)
#  define C_VERSION "90"
# else
#  define C_VERSION
# endif
#elif C_STD > C_STD_17
# define C_VERSION "23"
#elif C_STD > C_STD_11
# define C_VERSION "17"
#elif C_STD > C_STD_99
# define C_VERSION "11"
#elif C_STD >= C_STD_99
# define C_VERSION "99"
#else
# define C_VERSION "90"
#endif
const char* info_language_standard_default =
  "INFO" ":" "standard_default[" C_VERSION "]";

const char* info_language_extensions_default = "INFO" ":" "extensions_default["
#if (defined(__clang__) || defined(__GNUC__) || defined(__xlC__) ||           \
     defined(__TI_COMPILER_VERSION__) || defined(__RENESAS__)) &&             \
  !defined(__STRICT_ANSI__)
  "ON"
#else
  "OFF"
#endif
"]";

/*--------------------------------------------------------------------------*/

#ifdef ID_VOID_MAIN
void main() {}
#else
# if defined(__CLASSIC_C__)
int main(argc, argv) int argc; char *argv[];
# else
int main(int argc, char* argv[])
# endif
{
  int require = 0;
  require += info_compiler[argc];
  require += info_platform[argc];
  require += info_arch[argc];
#ifdef COMPILER_VERSION_MAJOR
  require += info_version[argc];
#endif
#if defined(COMPILER_VERSION_INTERNAL) || defined(COMPILER_VERSION_INTERNAL_STR)
  require += info_version_internal[argc];
#endif
#ifdef SIMULATE_ID
  require += info_simulate[argc];
#endif
#ifdef SIMULATE_VERSION_MAJOR
  require += info_simulate_version[argc];
#endif
#if defined(__CRAYXT_COMPUTE_LINUX_TARGET)
  require += info_cray[argc];
#endif
  require += info_language_standard_default[argc];
  require += info_language_extensions_default[argc];
  (void)argv;
  return require;
}
#endif

======================================================================
### FILE: ././meson.build
======================================================================
# aurora-shell/meson.build

project('aurora-shell', 'c',
  version: '0.1.0',
  default_options: [
    'c_std=c11',
    'warning_level=2',
  ]
)

# Process the build files in our subdirectories
subdir('src/aurora-shell')
subdir('widgets')
subdir('daemons')

# Install the templates directory
install_subdir(
  'templates',
  install_dir: get_option('datadir') / 'aurora-shell',
  install_mode: 'rw-r--r--'
)

# Install the default config.json
install_data(
  'config.json',
  install_dir: get_option('datadir') / 'aurora-shell',
  install_mode: 'rw-r--r--'
)

install_data(
  'themer/wallpaper.sh',
  'themer/toggle-selector.sh',   
  'themer/lighten_color.py',       
  install_dir: get_option('bindir'), 
  install_mode: 'rwxr-xr-x'          
)

# Install the MPRIS resetter daemon script to the binary directory
install_data(
  'daemons/mpris-resetter/mpris-resetter.sh',
  install_dir: get_option('bindir'),
  rename: 'aurora-mpris-resetter', # Rename it for a clean command name
  install_mode: 'rwxr-xr-x'         # Make it executable
)
